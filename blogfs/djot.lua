-- Autogenerated with "go run ./cmd/vendordjot". Do not edit.
-- https://github.com/jgm/djot/blob/main/LICENSE
-- Copyright (C) 2022 John MacFarlane
--
-- Permission is hereby granted, free of charge, to any person obtaining
-- a copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to
-- permit persons to whom the Software is furnished to do so, subject to
-- the following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-- IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-- CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-- TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-- SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
package.preload["djot.attributes"] = function()
local find, sub = string.find, string.sub

-- Parser for attributes
-- attributes { id = "foo", class = "bar baz",
--              key1 = "val1", key2 = "val2" }
-- syntax:
--
-- attributes <- '{' whitespace* attribute (whitespace attribute)* whitespace* '}'
-- attribute <- identifier | class | keyval
-- identifier <- '#' name
-- class <- '.' name
-- name <- (nonspace, nonpunctuation other than ':', '_', '-')+
-- keyval <- key '=' val
-- key <- (ASCII_ALPHANUM | ':' | '_' | '-')+
-- val <- bareval | quotedval
-- bareval <- (ASCII_ALPHANUM | ':' | '_' | '-')+
-- quotedval <- '"' ([^"] | '\"') '"'

-- states:
local SCANNING = 0
local SCANNING_ID = 1
local SCANNING_CLASS= 2
local SCANNING_KEY = 3
local SCANNING_VALUE = 4
local SCANNING_BARE_VALUE = 5
local SCANNING_QUOTED_VALUE = 6
local SCANNING_ESCAPED = 7
local SCANNING_COMMENT = 8
local FAIL = 9
local DONE = 10
local START = 11

local AttributeParser = {}

local handlers = {}

handlers[START] = function(self, pos)
  if find(self.subject, "^{", pos) then
    return SCANNING
  else
    return FAIL
  end
end

handlers[FAIL] = function(_self, _pos)
  return FAIL
end

handlers[DONE] = function(_self, _pos)
  return DONE
end

handlers[SCANNING] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == ' ' or c == '\t' or c == '\n' or c == '\r' then
    return SCANNING
  elseif c == '}' then
    return DONE
  elseif c == '#' then
    self.begin = pos
    return SCANNING_ID
  elseif c == '%' then
    self.begin = pos
    return SCANNING_COMMENT
  elseif c == '.' then
    self.begin = pos
    return SCANNING_CLASS
  elseif find(c, "^[%a%d_:-]") then
    self.begin = pos
    return SCANNING_KEY
  else -- TODO
    return FAIL
  end
end

handlers[SCANNING_COMMENT] = function(self, pos)
  if sub(self.subject, pos, pos) == "%" then
    return SCANNING
  else
    return SCANNING_COMMENT
  end
end

handlers[SCANNING_ID] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if find(c, "^[^%s%p]") or c == "_" or c == "-" or c == ":" then
    return SCANNING_ID
  elseif c == '}' then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "id")
    end
    self.begin = nil
    return DONE
  elseif find(c, "^%s") then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "id")
    end
    self.begin = nil
    return SCANNING
  else
    return FAIL
  end
end

handlers[SCANNING_CLASS] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if find(c, "^[^%s%p]") or c == "_" or c == "-" or c == ":" then
    return SCANNING_CLASS
  elseif c == '}' then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "class")
    end
    self.begin = nil
    return DONE
  elseif find(c, "^%s") then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "class")
    end
    self.begin = nil
    return SCANNING
  else
    return FAIL
  end
end

handlers[SCANNING_KEY] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == "=" then
    self:add_match(self.begin, self.lastpos, "key")
    self.begin = nil
    return SCANNING_VALUE
  elseif find(c, "^[%a%d_:-]") then
    return SCANNING_KEY
  else
    return FAIL
  end
end

handlers[SCANNING_VALUE] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == '"' then
    self.begin = pos
    return SCANNING_QUOTED_VALUE
  elseif find(c, "^[%a%d_:-]") then
    self.begin = pos
    return SCANNING_BARE_VALUE
  else
    return FAIL
  end
end

handlers[SCANNING_BARE_VALUE] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if find(c, "^[%a%d_:-]") then
    return SCANNING_BARE_VALUE
  elseif c == '}' then
    self:add_match(self.begin, self.lastpos, "value")
    self.begin = nil
    return DONE
  elseif find(c, "^%s") then
    self:add_match(self.begin, self.lastpos, "value")
    self.begin = nil
    return SCANNING
  else
    return FAIL
  end
end

handlers[SCANNING_ESCAPED] = function(_self, _pos)
  return SCANNING_QUOTED_VALUE
end

handlers[SCANNING_QUOTED_VALUE] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == '"' then
    self:add_match(self.begin + 1, self.lastpos, "value")
    self.begin = nil
    return SCANNING
  elseif c == "\\" then
    return SCANNING_ESCAPED
  else
    return SCANNING_QUOTED_VALUE
  end
end

function AttributeParser:new(subject)
  local state = {
    subject = subject,
    state = START,
    begin = nil,
    lastpos = nil,
    matches = {}
    }
  setmetatable(state, self)
  self.__index = self
  return state
end

function AttributeParser:add_match(sp, ep, tag)
  self.matches[#self.matches + 1] = {sp, ep, tag}
end

function AttributeParser:get_matches()
  return self.matches
end

-- Feed parser a slice of text from the subject, between
-- startpos and endpos inclusive.  Return status, position,
-- where status is either "done" (position should point to
-- final '}'), "fail" (position should point to first character
-- that could not be parsed), or "continue" (position should
-- point to last character parsed).
function AttributeParser:feed(startpos, endpos)
  local pos = startpos
  while pos <= endpos do
    self.state = handlers[self.state](self, pos)
    if self.state == DONE then
      return "done", pos
    elseif self.state == FAIL then
      self.lastpos = pos
      return "fail", pos
    else
      self.lastpos = pos
      pos = pos + 1
    end
  end
  return "continue", endpos
end

--[[
local test = function()
  local parser = AttributeParser:new("{a=b #ident\n.class\nkey=val1\n .class key2=\"val two \\\" ok\" x")
  local x,y,z = parser:feed(1,56)
  print(require'inspect'(parser:get_matches{}))
end

test()
--]]

return { AttributeParser = AttributeParser }

end

package.preload["djot.inline"] = function()
-- this allows the code to work with both lua and luajit:
local unpack = unpack or table.unpack
local attributes = require("djot.attributes")
local find, byte = string.find, string.byte

-- allow up to 3 captures...
local function bounded_find(subj, patt, startpos, endpos)
  local sp,ep,c1,c2,c3 = find(subj, patt, startpos)
  if ep and ep <= endpos then
    return sp,ep,c1,c2,c3
  end
end

-- General note on the parsing strategy:  our objective is to
-- parse without backtracking. To that end, we keep a stack of
-- potential 'openers' for links, images, emphasis, and other
-- inline containers.  When we parse a potential closer for
-- one of these constructions, we can scan the stack of openers
-- for a match, which will tell us the location of the potential
-- opener. We can then change the annotation of the match at
-- that location to '+emphasis' or whatever.

local InlineParser = {}

function InlineParser:new(subject, warn)
  local state =
    { warn = warn or function() end, -- function to issue warnings
      subject = subject, -- text to parse
      matches = {}, -- table pos : (endpos, annotation)
      openers = {}, -- map from closer_type to array of (pos, data) in reverse order
      verbatim = 0, -- parsing verbatim span to be ended by n backticks
      verbatim_type = nil, -- whether verbatim is math or regular
      destination = false, -- parsing link destination in ()
      firstpos = 0, -- position of first slice
      lastpos = 0,  -- position of last slice
      allow_attributes = true, -- allow parsing of attributes
      attribute_parser = nil,  -- attribute parser
      attribute_start = nil,  -- start of potential attribute
      attribute_slices = nil, -- slices we've tried to parse as attributes
    }
  setmetatable(state, self)
  self.__index = self
  return state
end

function InlineParser:add_match(startpos, endpos, annotation)
  self.matches[startpos] = {startpos, endpos, annotation}
end

function InlineParser:add_opener(name, ...)
  -- 1 = startpos, 2 = endpos, 3 = annotation, 4 = substartpos, 5 = endpos
  --
  -- [link text](url)
  -- ^         ^^
  -- 1,2      4 5  3 = "explicit_link"

  if not self.openers[name] then
    self.openers[name] = {}
  end
  table.insert(self.openers[name], {...})
end

function InlineParser:clear_openers(startpos, endpos)
  -- remove other openers in between the matches
  for _,v in pairs(self.openers) do
    local i = #v
    while v[i] do
      local sp,ep,_,sp2,ep2 = unpack(v[i])
      if sp >= startpos and ep <= endpos then
        v[i] = nil
      elseif (sp2 and sp2 >= startpos) and (ep2 and ep2 <= endpos) then
        v[i][3] = nil
        v[i][4] = nil
        v[i][5] = nil
      else
        break
      end
      i = i - 1
    end
  end
end

function InlineParser:str_matches(startpos, endpos)
  for i = startpos, endpos do
    local m = self.matches[i]
    if m then
      local sp, ep, annot = unpack(m)
      if annot ~= "str" and annot ~= "escape" then
        self.matches[i] = {sp, ep, "str"}
      end
    end
  end
end

local function matches_pattern(match, patt)
  if match then
    return string.find(match[3], patt)
  end
end


function InlineParser.between_matched(c, annotation, defaultmatch, opentest)
  return function(self, pos, endpos)
    defaultmatch = defaultmatch or "str"
    local subject = self.subject
    local can_open = find(subject, "^%S", pos + 1)
    local can_close = find(subject, "^%S", pos - 1)
    local has_open_marker = matches_pattern(self.matches[pos - 1], "^open%_marker")
    local has_close_marker = pos + 1 <= endpos and
                              byte(subject, pos + 1) == 125 -- }
    local endcloser = pos
    local startopener = pos

    if type(opentest) == "function" then
      can_open = can_open and opentest(self, pos)
    end

    -- allow explicit open/close markers to override:
    if has_open_marker then
      can_open = true
      can_close = false
      startopener = pos - 1
    end
    if not has_open_marker and has_close_marker then
      can_close = true
      can_open = false
      endcloser = pos + 1
    end

    if has_open_marker and defaultmatch:match("^right") then
      defaultmatch = defaultmatch:gsub("^right", "left")
    elseif has_close_marker and defaultmatch:match("^left") then
      defaultmatch = defaultmatch:gsub("^left", "right")
    end

    local d
    if has_close_marker then
      d = "{" .. c
    else
      d = c
    end
    local openers = self.openers[d]
    if can_close and openers and #openers > 0 then
       -- check openers for a match
      local openpos, openposend = unpack(openers[#openers])
      if openposend ~= pos - 1 then -- exclude empty emph
        self:clear_openers(openpos, pos)
        self:add_match(openpos, openposend, "+" .. annotation)
        self:add_match(pos, endcloser, "-" .. annotation)
        return endcloser + 1
      end
    end

    -- if we get here, we didn't match an opener
    if can_open then
      if has_open_marker then
        d = "{" .. c
      else
        d = c
      end
      self:add_opener(d, startopener, pos)
      self:add_match(startopener, pos, defaultmatch)
      return pos + 1
    else
      self:add_match(pos, endcloser, defaultmatch)
      return endcloser + 1
    end
  end
end

InlineParser.matchers = {
    -- 96 = `
    [96] = function(self, pos, endpos)
      local subject = self.subject
      local _, endchar = bounded_find(subject, "^`*", pos, endpos)
      if not endchar then
        return nil
      end
      if find(subject, "^%$%$", pos - 2) and
          not find(subject, "^\\", pos - 3) then
        self.matches[pos - 2] = nil
        self.matches[pos - 1] = nil
        self:add_match(pos - 2, endchar, "+display_math")
        self.verbatim_type = "display_math"
      elseif find(subject, "^%$", pos - 1) then
        self.matches[pos - 1] = nil
        self:add_match(pos - 1, endchar, "+inline_math")
        self.verbatim_type = "inline_math"
      else
        self:add_match(pos, endchar, "+verbatim")
        self.verbatim_type = "verbatim"
      end
      self.verbatim = endchar - pos + 1
      return endchar + 1
    end,

    -- 92 = \
    [92] = function(self, pos, endpos)
      local subject = self.subject
      local _, endchar = bounded_find(subject, "^[ \t]*\r?\n",  pos + 1, endpos)
      self:add_match(pos, pos, "escape")
      if endchar then
        -- see if there were preceding spaces
        if #self.matches > 0 then
          local sp, ep, annot = unpack(self.matches[#self.matches])
          if annot == "str" then
            while ep >= sp and
                 (subject:byte(ep) == 32 or subject:byte(ep) == 9) do
              ep = ep -1
            end
            if ep < sp then
              self.matches[#self.matches] = nil
            else
              self:add_match(sp, ep, "str")
            end
          end
        end
        self:add_match(pos + 1, endchar, "hardbreak")
        return endchar + 1
      else
        local _, ec = bounded_find(subject, "^[%p ]", pos + 1, endpos)
        if not ec then
          self:add_match(pos, pos, "str")
          return pos + 1
        else
          self:add_match(pos, pos, "escape")
          if find(subject, "^ ", pos + 1) then
            self:add_match(pos + 1, ec, "nbsp")
          else
            self:add_match(pos + 1, ec, "str")
          end
          return ec + 1
        end
      end
    end,

    -- 60 = <
    [60] = function(self, pos, endpos)
      local subject = self.subject
      local starturl, endurl =
              bounded_find(subject, "^%<[^<>%s]+%>", pos, endpos)
      if starturl then
        local is_url = bounded_find(subject, "^%a+:", pos + 1, endurl)
        local is_email = bounded_find(subject, "^[^:]+%@", pos + 1, endurl)
        if is_email then
          self:add_match(starturl, starturl, "+email")
          self:add_match(starturl + 1, endurl - 1, "str")
          self:add_match(endurl, endurl, "-email")
          return endurl + 1
        elseif is_url then
          self:add_match(starturl, starturl, "+url")
          self:add_match(starturl + 1, endurl - 1, "str")
          self:add_match(endurl, endurl, "-url")
          return endurl + 1
        end
      end
    end,

    -- 126 = ~
    [126] = InlineParser.between_matched('~', 'subscript'),

    -- 94 = ^
    [94] = InlineParser.between_matched('^', 'superscript'),

    -- 91 = [
    [91] = function(self, pos, endpos)
      local sp, ep = bounded_find(self.subject, "^%^([^]]+)%]", pos + 1, endpos)
      if sp then -- footnote ref
        self:add_match(pos, ep, "footnote_reference")
        return ep + 1
      else
        self:add_opener("[", pos, pos)
        self:add_match(pos, pos, "str")
        return pos + 1
      end
    end,

    -- 93 = ]
    [93] = function(self, pos, endpos)
      local openers = self.openers["["]
      local subject = self.subject
      if openers and #openers > 0 then
        local opener = openers[#openers]
        if opener[3] == "reference_link" then
          -- found a reference link
          -- add the matches
          local is_image = bounded_find(subject, "^!", opener[1] - 1, endpos)
                  and not bounded_find(subject, "^[\\]", opener[1] - 2, endpos)
          if is_image then
            self:add_match(opener[1] - 1, opener[1] - 1, "image_marker")
            self:add_match(opener[1], opener[2], "+imagetext")
            self:add_match(opener[4], opener[4], "-imagetext")
          else
            self:add_match(opener[1], opener[2], "+linktext")
            self:add_match(opener[4], opener[4], "-linktext")
          end
          self:add_match(opener[5], opener[5], "+reference")
          self:add_match(pos, pos, "-reference")
          -- convert all matches to str
          self:str_matches(opener[5] + 1, pos - 1)
          -- remove from openers
          self:clear_openers(opener[1], pos)
          return pos + 1
        elseif bounded_find(subject, "^%[", pos + 1, endpos) then
          opener[3] = "reference_link"
          opener[4] = pos  -- intermediate ]
          opener[5] = pos + 1  -- intermediate [
          self:add_match(pos, pos + 1, "str")
          -- remove any openers between [ and ]
          self:clear_openers(opener[1] + 1, pos - 1)
          return pos + 2
        elseif bounded_find(subject, "^%(", pos + 1, endpos) then
          self.openers["("] = {} -- clear ( openers
          opener[3] = "explicit_link"
          opener[4] = pos  -- intermediate ]
          opener[5] = pos + 1  -- intermediate (
          self.destination = true
          self:add_match(pos, pos + 1, "str")
          -- remove any openers between [ and ]
          self:clear_openers(opener[1] + 1, pos - 1)
          return pos + 2
        elseif bounded_find(subject, "^%{", pos + 1, endpos) then
          -- assume this is attributes, bracketed span
          self:add_match(opener[1], opener[2], "+span")
          self:add_match(pos, pos, "-span")
          -- remove any openers between [ and ]
          self:clear_openers(opener[1], pos)
          return pos + 1
        end
      end
    end,


    -- 40 = (
    [40] = function(self, pos)
      if not self.destination then return nil end
      self:add_opener("(", pos, pos)
      self:add_match(pos, pos, "str")
      return pos + 1
    end,

    -- 41 = )
    [41] = function(self, pos, endpos)
      if not self.destination then return nil end
      local parens = self.openers["("]
      if parens and #parens > 0 and parens[#parens][1] then
        parens[#parens] = nil -- clear opener
        self:add_match(pos, pos, "str")
        return pos + 1
      else
        local subject = self.subject
        local openers = self.openers["["]
        if openers and #openers > 0
            and openers[#openers][3] == "explicit_link" then
          local opener = openers[#openers]
          -- we have inline link
          local is_image = bounded_find(subject, "^!", opener[1] - 1, endpos)
                 and not bounded_find(subject, "^[\\]", opener[1] - 2, endpos)
          if is_image then
            self:add_match(opener[1] - 1, opener[1] - 1, "image_marker")
            self:add_match(opener[1], opener[2], "+imagetext")
            self:add_match(opener[4], opener[4], "-imagetext")
          else
            self:add_match(opener[1], opener[2], "+linktext")
            self:add_match(opener[4], opener[4], "-linktext")
          end
          self:add_match(opener[5], opener[5], "+destination")
          self:add_match(pos, pos, "-destination")
          self.destination = false
          -- convert all matches to str
          self:str_matches(opener[5] + 1, pos - 1)
          -- remove from openers
          self:clear_openers(opener[1], pos)
          return pos + 1
        end
      end
    end,

    -- 95 = _
    [95] = InlineParser.between_matched('_', 'emph'),

    -- 42 = *
    [42] = InlineParser.between_matched('*', 'strong'),

    -- 123 = {
    [123] = function(self, pos, endpos)
      if bounded_find(self.subject, "^[_*~^+='\"-]", pos + 1, endpos) then
        self:add_match(pos, pos, "open_marker")
        return pos + 1
      elseif self.allow_attributes then
        self.attribute_parser = attributes.AttributeParser:new(self.subject)
        self.attribute_start = pos
        self.attribute_slices = {}
        return pos
      else
        self:add_match(pos, pos, "str")
        return pos + 1
      end
    end,

    -- 58 = :
    [58] = function(self, pos, endpos)
      local sp, ep = bounded_find(self.subject, "^%:[%w_+-]+%:", pos, endpos)
      if sp then
        self:add_match(sp, ep, "emoji")
        return ep + 1
      else
        self:add_match(pos, pos, "str")
        return pos + 1
      end
    end,

    -- 43 = +
    [43] = InlineParser.between_matched("+", "insert", "str",
                           function(self, pos)
                             return find(self.subject, "^%{", pos - 1) or
                                    find(self.subject, "^%}", pos + 1)
                           end),

    -- 61 = =
    [61] = InlineParser.between_matched("=", "mark", "str",
                           function(self, pos)
                             return find(self.subject, "^%{", pos - 1) or
                                    find(self.subject, "^%}", pos + 1)
                           end),

    -- 39 = '
    [39] = InlineParser.between_matched("'", "single_quoted", "right_single_quote",
                           function(self, pos) -- test to open
                             return pos == 1 or
                               find(self.subject, "^[%s\"'-([]", pos - 1)
                             end),

    -- 34 = "
    [34] = InlineParser.between_matched('"', "double_quoted", "left_double_quote"),

    -- 45 = -
    [45] = function(self, pos, endpos)
      local subject = self.subject
      local nextpos
      if byte(subject, pos - 1) == 123 or
         byte(subject, pos + 1) == 125 then -- (123 = { 125 = })
        nextpos = InlineParser.between_matched("-", "delete", "str",
                           function(slf, p)
                             return find(slf.subject, "^%{", p - 1) or
                                    find(slf.subject, "^%}", p + 1)
                           end)(self, pos, endpos)
        return nextpos
      end
      -- didn't match a del, try for smart hyphens:
      local _, ep = find(subject, "^%-*", pos)
      if endpos < ep then
        ep = endpos
      end
      local hyphens = 1 + ep - pos
      if byte(subject, ep + 1) == 125 then -- 125 = }
        hyphens = hyphens - 1 -- last hyphen is close del
      end
      if hyphens == 0 then  -- this means we have '-}'
        self:add_match(pos, pos + 1, "str")
        return pos + 2
      end
      -- Try to construct a homogeneous sequence of dashes
      local all_em = hyphens % 3 == 0
      local all_en = hyphens % 2 == 0
      while hyphens > 0 do
        if all_em then
          self:add_match(pos, pos + 2, "em_dash")
          pos = pos + 3
          hyphens = hyphens - 3
        elseif all_en then
          self:add_match(pos, pos + 1, "en_dash")
          pos = pos + 2
          hyphens = hyphens - 2
        elseif hyphens >= 3 and (hyphens % 2 ~= 0 or hyphens > 4) then
          self:add_match(pos, pos + 2, "em_dash")
          pos = pos + 3
          hyphens = hyphens - 3
        elseif hyphens >= 2 then
          self:add_match(pos, pos + 1, "en_dash")
          pos = pos + 2
          hyphens = hyphens - 2
        else
          self:add_match(pos, pos, "str")
          pos = pos + 1
          hyphens = hyphens - 1
        end
      end
      return pos
    end,

    -- 46 = .
    [46] = function(self, pos, endpos)
      if bounded_find(self.subject, "^%.%.", pos + 1, endpos) then
        self:add_match(pos, pos +2, "ellipses")
        return pos + 3
      end
    end
  }

function InlineParser:single_char(pos)
  self:add_match(pos, pos, "str")
  return pos + 1
end

-- Reparse attribute_slices that we tried to parse as an attribute
function InlineParser:reparse_attributes()
  local slices = self.attribute_slices
  if not slices then
    return
  end
  self.allow_attributes = false
  self.attribute_parser = nil
  self.attribute_start = nil
  if slices then
    for i=1,#slices do
      self:feed(unpack(slices[i]))
    end
  end
  self.allow_attributes = true
  self.attribute_slices = nil
end

-- Feed a slice to the parser, updating state.
function InlineParser:feed(spos, endpos)
  local special = "[][\\`{}_*()!<>~^:=+$\r\n'\".-]"
  local subject = self.subject
  local matchers = self.matchers
  local pos
  if self.firstpos == 0 or spos < self.firstpos then
    self.firstpos = spos
  end
  if self.lastpos == 0 or endpos > self.lastpos then
    self.lastpos = endpos
  end
  pos = spos
  while pos <= endpos do
    if self.attribute_parser then
      local sp = pos
      local ep2 = bounded_find(subject, special, pos, endpos)
      if not ep2 or ep2 > endpos then
        ep2 = endpos
      end
      local status, ep = self.attribute_parser:feed(sp, ep2)
      if status == "done" then
        local attribute_start = self.attribute_start
        -- add attribute matches
        self:add_match(attribute_start, attribute_start, "+attributes")
        self:add_match(ep, ep, "-attributes")
        local attr_matches = self.attribute_parser:get_matches()
        -- add attribute matches
        for i=1,#attr_matches do
          self:add_match(unpack(attr_matches[i]))
        end
        -- restore state to prior to adding attribute parser:
        self.attribute_parser = nil
        self.attribute_start = nil
        self.attribute_slices = nil
        pos = ep + 1
      elseif status == "fail" then
        self:reparse_attributes()
        pos = sp  -- we'll want to go over the whole failed portion again,
                  -- as no slice was added for it
      elseif status == "continue" then
        if #self.attribute_slices == 0 then
          self.attribute_slices = {}
        end
        self.attribute_slices[#self.attribute_slices + 1] = {sp,ep}
        pos = ep + 1
      end
    else
      -- find next interesting character:
      local newpos = bounded_find(subject, special, pos, endpos) or endpos + 1
      if newpos > pos then
        self:add_match(pos, newpos - 1, "str")
        pos = newpos
        if pos > endpos then
          break -- otherwise, fall through:
        end
      end
      -- if we get here, then newpos = pos,
      -- i.e. we have something interesting at pos
      local c = byte(subject, pos)

      if c == 13 or c == 10 then -- cr or lf
        if c == 13 and bounded_find(subject, "^[%n]", pos + 1, endpos) then
          self:add_match(pos, pos + 1, "softbreak")
          pos = pos + 2
        else
          self:add_match(pos, pos, "softbreak")
          pos = pos + 1
        end
      elseif self.verbatim > 0 then
        if c == 96 then
          local _, endchar = bounded_find(subject, "^`+", pos, endpos)
          if endchar and endchar - pos + 1 == self.verbatim then
            -- check for raw attribute
            local sp, ep =
              bounded_find(subject, "^%{%=[^%s{}`]+%}", endchar + 1, endpos)
            if sp and self.verbatim_type == "verbatim" then -- raw
              self:add_match(pos, endchar, "-" .. self.verbatim_type)
              self:add_match(sp, ep, "raw_format")
              pos = ep + 1
            else
              self:add_match(pos, endchar, "-" .. self.verbatim_type)
              pos = endchar + 1
            end
            self.verbatim = 0
            self.verbatim_type = nil
          else
            endchar = endchar or endpos
            self:add_match(pos, endchar, "str")
            pos = endchar + 1
          end
        else
          self:add_match(pos, pos, "str")
          pos = pos + 1
        end
      else
        local matcher = matchers[c]
        pos = (matcher and matcher(self, pos, endpos)) or self:single_char(pos)
      end
    end
  end
end

  -- Return true if we're parsing verbatim content.
function InlineParser:in_verbatim()
  return self.verbatim > 0
end

function InlineParser:get_matches()
  local sorted = {}
  local subject = self.subject
  local lastsp, lastep, lastannot
  if self.attribute_parser then -- we're still in an attribute parse
    self:reparse_attributes()
  end
  for i=self.firstpos, self.lastpos do
    if self.matches[i] then
      local sp, ep, annot = unpack(self.matches[i])
      if annot == "str" and lastannot == "str" and lastep + 1 == sp then
          -- consolidate adjacent strs
        sorted[#sorted] = {lastsp, ep, annot}
        lastsp, lastep, lastannot = lastsp, ep, annot
      else
        sorted[#sorted + 1] = self.matches[i]
        lastsp, lastep, lastannot = sp, ep, annot
      end
    end
  end
  if #sorted > 0 then
    local last = sorted[#sorted]
    local startpos, endpos, annot = unpack(last)
    -- remove final softbreak
    if annot == "softbreak" then
      sorted[#sorted] = nil
      last = sorted[#sorted]
      if not last then
        return sorted
      end
      startpos, endpos, annot = unpack(last)
    end
    -- remove trailing spaces
    if annot == "str" and byte(subject, endpos) == 32 then
      while endpos > startpos and byte(subject, endpos) == 32 do
        endpos = endpos - 1
      end
      sorted[#sorted] = {startpos, endpos, annot}
    end
    if self.verbatim > 0 then -- unclosed verbatim
      self.warn({ message = "Unclosed verbatim", pos = endpos })
      sorted[#sorted + 1] = {endpos, endpos, "-" .. self.verbatim_type}
    end
  end
  return sorted
end

return { InlineParser = InlineParser }

end

package.preload["djot.block"] = function()
local InlineParser = require("djot.inline").InlineParser
local attributes = require("djot.attributes")
local unpack = unpack or table.unpack
local find, sub, byte = string.find, string.sub, string.byte

local Container = {}

function Container:new(spec, data)
  self = spec
  local contents = {}
  setmetatable(contents, self)
  self.__index = self
  if data then
    for k,v in pairs(data) do
      contents[k] = v
    end
  end
  return contents
end

local function get_list_styles(marker)
  if marker == "+" or marker == "-" or marker == "*" or marker == ":" then
    return {marker}
  elseif find(marker, "^[+*-] %[[Xx ]%]") then
    return {"X"} -- task list
  elseif find(marker, "^%[[Xx ]%]") then
    return {"X"}
  elseif find(marker, "^[(]?%d+[).]") then
    return {(marker:gsub("%d+","1"))}
  -- in ambiguous cases we return two values
  elseif find(marker, "^[(]?[ivxlcdm][).]") then
    return {(marker:gsub("%a+", "a")), (marker:gsub("%a+", "i"))}
  elseif find(marker, "^[(]?[IVXLCDM][).]") then
    return {(marker:gsub("%a+", "A")), (marker:gsub("%a+", "I"))}
  elseif find(marker, "^[(]?%l[).]") then
    return {(marker:gsub("%l", "a"))}
  elseif find(marker, "^[(]?%u[).]") then
    return {(marker:gsub("%u", "A"))}
  elseif find(marker, "^[(]?[ivxlcdm]+[).]") then
    return {(marker:gsub("%a+", "i"))}
  elseif find(marker, "^[(]?[IVXLCDM]+[).]") then
    return {(marker:gsub("%a+", "I"))}
  else -- doesn't match any list style
    return {}
  end
end

local Parser = {}

function Parser:new(subject, warn)
  -- ensure the subject ends with a newline character
  if not subject:find("[\r\n]$") then
    subject = subject .. "\n"
  end
  local state = {
    warn = warn or function() end,
    subject = subject,
    indent = 0,
    startline = nil,
    starteol = nil,
    endeol = nil,
    matches = {},
    containers = {},
    pos = 1,
    last_matched_container = 0,
    timer = {},
    finished_line = false,
    returned = 0 }
  setmetatable(state, self)
  self.__index = self
  return state
end

-- parameters are start and end position
function Parser:parse_table_row(sp, ep)
  local orig_matches = #self.matches  -- so we can rewind
  local startpos = self.pos
  self:add_match(sp, sp, "+row")
  -- skip | and any initial space in the cell:
  self.pos = find(self.subject, "%S", sp + 1)
  -- check to see if we have a separator line
  local seps = {}
  local p = self.pos
  local sepfound = false
  while not sepfound do
    local sepsp, sepep, left, right, trailing =
      find(self.subject, "^(%:?)%-%-*(%:?)([ \t]*%|[ \t]*)", p)
    if sepep then
      local st = "separator_default"
      if #left > 0 and #right > 0 then
        st = "separator_center"
      elseif #right > 0 then
        st = "separator_right"
      elseif #left > 0 then
        st = "separator_left"
      end
      seps[#seps + 1] = {sepsp, sepep - #trailing, st}
      p = sepep + 1
      if p == self.starteol then
        sepfound = true
        break
      end
    else
      break
    end
  end
  if sepfound then
    for i=1,#seps do
      self:add_match(unpack(seps[i]))
    end
    self:add_match(self.starteol - 1, self.starteol - 1, "-row")
    self.pos = self.starteol
    self.finished_line = true
    return true
  end
  local inline_parser = InlineParser:new(self.subject, self.warn)
  self:add_match(sp, sp, "+cell")
  local complete_cell = false
  while self.pos <= ep do
    -- parse a chunk as inline content
    local nextbar, _
    while not nextbar do
      _, nextbar = self:find("^[^|\r\n]*|")
      if not nextbar then
        break
      end
      if string.find(self.subject, "^\\", nextbar - 1) then -- \|
        inline_parser:feed(self.pos, nextbar)
        self.pos = nextbar + 1
        nextbar = nil
      else
        inline_parser:feed(self.pos, nextbar - 1)
        if inline_parser:in_verbatim() then
          inline_parser:feed(nextbar, nextbar)
          self.pos = nextbar + 1
          nextbar = nil
        else
          self.pos = nextbar + 1
        end
      end
    end
    complete_cell = nextbar
    if not complete_cell then
      break
    end
    -- add a table cell
    local cell_matches = inline_parser:get_matches()
    for i=1,#cell_matches do
      local s,e,ann = unpack(cell_matches[i])
      if i == #cell_matches and ann == "str" then
        -- strip trailing space
        while byte(self.subject, e) == 32 and e >= s do
          e = e - 1
        end
      end
      self:add_match(s,e,ann)
    end
    self:add_match(nextbar, nextbar, "-cell")
    if nextbar < ep then
      -- reset inline parser state
      inline_parser = InlineParser:new(self.subject, self.warn)
      self:add_match(nextbar, nextbar, "+cell")
      self.pos = find(self.subject, "%S", self.pos)
    end
  end
  if not complete_cell then
    -- rewind, this is not a valid table row
    self.pos = startpos
    for i = orig_matches,#self.matches do
      self.matches[i] = nil
    end
    return false
  else
    self:add_match(self.pos, self.pos, "-row")
    self.pos = self.starteol
    self.finished_line = true
    return true
  end
end

function Parser:specs()
  return {
    { name = "para",
      is_para = true,
      content = "inline",
      continue = function()
        if self:find("^%S") then
          return true
        else
          return false
        end
      end,
      open = function(spec)
        self:add_container(Container:new(spec,
            { inline_parser =
                InlineParser:new(self.subject, self.warn) }))
        self:add_match(self.pos, self.pos, "+para")
        return true
      end,
      close = function()
        self:get_inline_matches()
        self:add_match(self.pos - 1, self.pos - 1, "-para")
        self.containers[#self.containers] = nil
      end
    },

    { name = "caption",
      is_para = false,
      content = "inline",
      continue = function()
        return self:find("^%S")
      end,
      open = function(spec)
        local _, ep = self:find("^%^[ \t]+")
        if ep then
          self.pos = ep + 1
          self:add_container(Container:new(spec,
            { inline_parser =
                InlineParser:new(self.subject, self.warn) }))
          self:add_match(self.pos, self.pos, "+caption")
          return true
        end
      end,
      close = function()
        self:get_inline_matches()
        self:add_match(self.pos - 1, self.pos - 1, "-caption")
        self.containers[#self.containers] = nil
      end
    },

    { name = "blockquote",
      content = "block",
      continue = function()
        if self:find("^%>%s") then
          self.pos = self.pos + 1
          return true
        else
          return false
        end
      end,
      open = function(spec)
        if self:find("^%>%s") then
          self:add_container(Container:new(spec))
          self:add_match(self.pos, self.pos, "+blockquote")
          self.pos = self.pos + 1
          return true
        end
      end,
      close = function()
        self:add_match(self.pos, self.pos, "-blockquote")
        self.containers[#self.containers] = nil
      end
    },

    -- should go before reference definitions
    { name = "footnote",
      content = "block",
      continue = function(container)
        if self.indent > container.indent or self:find("^[\r\n]") then
          return true
        else
          return false
        end
      end,
      open = function(spec)
        local sp, ep, label = self:find("^%[%^([^]]+)%]:%s")
        if not sp then
          return nil
        end
        -- adding container will close others
        self:add_container(Container:new(spec, {note_label = label,
                                                indent = self.indent}))
        self:add_match(sp, sp, "+footnote")
        self:add_match(sp + 2, ep - 3, "note_label")
        self.pos = ep
        return true
      end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-footnote")
        self.containers[#self.containers] = nil
      end
    },

    -- should go before list_item_spec
    { name = "thematic_break",
      content = nil,
      continue = function()
        return false
      end,
      open = function(spec)
        local sp, ep = self:find("^[-*][ \t]*[-*][ \t]*[-*][-* \t]*[\r\n]")
        if ep then
          self:add_container(Container:new(spec))
          self:add_match(sp, ep, "thematic_break")
          self.pos = ep
          return true
        end
      end,
      close = function(_container)
        self.containers[#self.containers] = nil
      end
    },

    { name = "list_item",
      content = "block",
      continue = function(container)
        if self.indent > container.indent or self:find("^[\r\n]") then
          return true
        else
          return false
        end
      end,
      open = function(spec)
        local sp, ep = self:find("^[-*+:]%s")
        if not sp then
          sp, ep = self:find("^%d+[.)]%s")
        end
        if not sp then
          sp, ep = self:find("^%(%d+%)%s")
        end
        if not sp then
          sp, ep = self:find("^[ivxlcdmIVXLCDM]+[.)]%s")
        end
        if not sp then
          sp, ep = self:find("^%([ivxlcdmIVXLCDM]+%)%s")
        end
        if not sp then
          sp, ep = self:find("^%a[.)]%s")
        end
        if not sp then
          sp, ep = self:find("^%(%a%)%s")
        end
        if not sp then
          return nil
        end
        local marker = sub(self.subject, sp, ep - 1)
        local checkbox = nil
        if self:find("^[*+-] %[[Xx ]%]%s", sp + 1) then -- task list
          marker = sub(self.subject, sp, sp + 4)
          checkbox = sub(self.subject, sp + 3, sp + 3)
        end
        -- some items have ambiguous style
        local styles = get_list_styles(marker)
        if #styles == 0 then
          return nil
        end
        local data = { styles = styles,
                       indent = self.indent }
        -- adding container will close others
        self:add_container(Container:new(spec, data))
        local annot = "+list_item"
        for i=1,#styles do
          annot = annot .. "[" .. styles[i] .. "]"
        end
        self:add_match(sp, ep - 1, annot)
        self.pos = ep
        if checkbox then
          if checkbox == " " then
            self:add_match(sp + 2, sp + 4, "checkbox_unchecked")
          else
            self:add_match(sp + 2, sp + 4, "checkbox_checked")
          end
          self.pos = sp + 5
        end
        return true
      end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-list_item")
        self.containers[#self.containers] = nil
      end
    },

    { name = "reference_definition",
      content = nil,
      continue = function(container)
        if container.indent >= self.indent then
          return false
        end
        local _, ep, rest = self:find("^(%S+)")
        if ep then
          self:add_match(ep - #rest + 1, ep, "reference_value")
          self.pos = ep + 1
        end
        return true
      end,
      open = function(spec)
        local sp, ep, label, rest = self:find("^%[([^]\r\n]*)%]:[ \t]*(%S*)")
        if sp then
          self:add_container(Container:new(spec,
             { key = label,
               indent = self.indent }))
          self:add_match(sp, sp, "+reference_definition")
          self:add_match(sp, sp + #label + 1, "reference_key")
          if #rest > 0 then
            self:add_match(ep - #rest + 1, ep, "reference_value")
          end
          self.pos = ep + 1
          return true
        end
      end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-reference_definition")
        self.containers[#self.containers] = nil
      end
    },

    { name = "heading",
      content = "inline",
      continue = function(container)
        local sp, ep = self:find("^%#+%s")
        if sp and ep and container.level == ep - sp then
          self.pos = ep
          return true
        else
          return false
        end
      end,
      open = function(spec)
        local sp, ep = self:find("^#+")
        if ep and find(self.subject, "^%s", ep + 1) then
          local level = ep - sp + 1
          self:add_container(Container:new(spec, {level = level,
               inline_parser = InlineParser:new(self.subject, self.warn) }))
          self:add_match(sp, ep, "+heading")
          self.pos = ep + 1
          return true
        end
      end,
      close = function(_container)
        self:get_inline_matches()
        local last = self.matches[#self.matches] or self.pos - 1
        local sp, ep, annot = unpack(last)
        self:add_match(ep, ep, "-heading")
        self.containers[#self.containers] = nil
      end
    },

    { name = "code_block",
      content = "text",
      continue = function(container)
        local char = sub(container.border, 1, 1)
        local sp, ep, border = self:find("^(" .. container.border ..
                                 char .. "*)[ \t]*[\r\n]")
        if ep then
          container.end_fence_sp = sp
          container.end_fence_ep = sp + #border - 1
          self.pos = ep -- before newline
          self.finished_line = true
          return false
        else
          return true
        end
      end,
      open = function(spec)
        local sp, ep, border, ws, lang =
          self:find("^(~~~~*)([ \t]*)(%S*)[ \t]*[\r\n]")
        if not ep then
          sp, ep, border, ws, lang =
            self:find("^(````*)([ \t]*)([^%s`]*)[ \t]*[\r\n]")
        end
        if border then
          local is_raw = find(lang, "^=") and true or false
          self:add_container(Container:new(spec, {border = border,
                                                  indent = self.indent }))
          self:add_match(sp, sp + #border - 1, "+code_block")
          if #lang > 0 then
            local langstart = sp + #border + #ws
            if is_raw then
              self:add_match(langstart, langstart + #lang - 1, "raw_format")
            else
              self:add_match(langstart, langstart + #lang - 1, "code_language")
            end
          end
          self.pos = ep  -- before newline
          self.finished_line = true
          return true
        end
      end,
      close = function(container)
        local sp = container.end_fence_sp or self.pos
        local ep = container.end_fence_ep or self.pos
        self:add_match(sp, ep, "-code_block")
        if sp == ep then
          self.warn({ pos = self.pos, message = "Unclosed code block" })
        end
        self.containers[#self.containers] = nil
      end
    },

    { name = "fenced_div",
      content = "block",
      continue = function(container)
        if self.containers[#self.containers].name == "code_block" then
          return true -- see #109
        end
        local sp, ep, equals = self:find("^(::::*)[ \t]*[r\n]")
        if ep and #equals >= container.equals then
          container.end_fence_sp = sp
          container.end_fence_ep = sp + #equals - 1
          self.pos = ep -- before newline
          return false
        else
          return true
        end
      end,
      open = function(spec)
        local sp, ep1, equals = self:find("^(::::*)[ \t]*")
        if not ep1 then
          return false
        end
        local clsp, ep = find(self.subject, "^[%w_-]*", ep1 + 1)
        local _, eol = find(self.subject, "^[ \t]*[\r\n]", ep + 1)
        if eol then
          self:add_container(Container:new(spec, {equals = #equals}))
          self:add_match(sp, ep, "+div")
          if ep >= clsp then
            self:add_match(clsp, ep, "class")
          end
          self.pos = eol + 1
          self.finished_line = true
          return true
        end
      end,
      close = function(container)
        local sp = container.end_fence_sp or self.pos
        local ep = container.end_fence_ep or self.pos
        -- check to make sure the match is in order
        self:add_match(sp, ep, "-div")
        if sp == ep then
          self.warn({pos = self.pos, message = "Unclosed div"})
        end
        self.containers[#self.containers] = nil
      end
    },

    { name = "table",
      content = "cells",
      continue = function(_container)
        local sp, ep = self:find("^|[^\r\n]*|")
        local eolsp = " *[\r\n]" -- make sure at end of line
        if sp and eolsp then
          return self:parse_table_row(sp, ep)
        end
      end,
      open = function(spec)
        local sp, ep = self:find("^|[^\r\n]*|")
        local eolsp = " *[\r\n]" -- make sure at end of line
        if sp and eolsp then
          self:add_container(Container:new(spec, { columns = 0 }))
          self:add_match(sp, sp, "+table")
          if self:parse_table_row(sp, ep) then
            return true
          else
            self.containers[#self.containers] = nil
            return false
          end
        end
     end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-table")
        self.containers[#self.containers] = nil
      end
    },

    { name = "attributes",
      content = "attributes",
      open = function(spec)
        if self:find("^%{") then
          local attribute_parser =
                  attributes.AttributeParser:new(self.subject)
          local status, ep =
                 attribute_parser:feed(self.pos, self.endeol)
          if status == 'fail' or ep + 1 < self.endeol then
            return false
          else
            self:add_container(Container:new(spec,
                               { status = status,
                                 indent = self.indent,
                                 startpos = self.pos,
                                 slices = {},
                                 attribute_parser = attribute_parser }))
            local container = self.containers[#self.containers]
            container.slices = { {self.pos, self.endeol } }
            self.pos = self.starteol
            return true
          end

        end
      end,
      continue = function(container)
        if self.indent > container.indent then
          table.insert(container.slices, { self.pos, self.endeol })
          local status, ep =
            container.attribute_parser:feed(self.pos, self.endeol)
          container.status = status
          if status ~= 'fail' or ep + 1 < self.endeol then
            self.pos = self.starteol
            return true
          end
        end
        -- if we get to here, we don't continue; either we
        -- reached the end of indentation or we failed in
        -- parsing attributes
        if container.status == 'done' then
          return false
        else -- attribute parsing failed; convert to para and continue
             -- with that
          local para_spec = self:specs()[1]
          local para = Container:new(para_spec,
                        { inline_parser =
                           InlineParser:new(self.subject, self.warn) })
          self:add_match(container.startpos, container.startpos, "+para")
          self.containers[#self.containers] = para
          -- reparse the text we couldn't parse as a block attribute:
          para.inline_parser.attribute_slices = container.slices
          para.inline_parser:reparse_attributes()
          self.pos = para.inline_parser.lastpos + 1
          return true
        end
      end,
      close = function(container)
        local attr_matches = container.attribute_parser:get_matches()
        self:add_match(container.startpos, container.startpos, "+block_attributes")
        for i=1,#attr_matches do
          self:add_match(unpack(attr_matches[i]))
        end
        self:add_match(self.pos, self.pos, "-block_attributes")
        self.containers[#self.containers] = nil
      end
    }
  }
end

function Parser:get_inline_matches()
  local matches =
    self.containers[#self.containers].inline_parser:get_matches()
  for i=1,#matches do
    self.matches[#self.matches + 1] = matches[i]
  end
end

function Parser:find(patt)
  return find(self.subject, patt, self.pos)
end

function Parser:add_match(startpos, endpos, annotation)
  self.matches[#self.matches + 1] = {startpos, endpos, annotation}
end

function Parser:add_container(container)
  local last_matched = self.last_matched_container
  while #self.containers > last_matched or
         (#self.containers > 0 and
          self.containers[#self.containers].content ~= "block") do
    self.containers[#self.containers]:close()
  end
  self.containers[#self.containers + 1] = container
end

function Parser:skip_space()
  local newpos, _ = find(self.subject, "[^ \t]", self.pos)
  if newpos then
    self.indent = newpos - self.startline
    self.pos = newpos
  end
end

function Parser:get_eol()
  local starteol, endeol = find(self.subject, "[\r]?[\n]", self.pos)
  if not endeol then
    starteol, endeol = #self.subject, #self.subject
  end
  self.starteol = starteol
  self.endeol = endeol
end

-- Returns an iterator over events.  At each iteration, the iterator
-- returns three values: start byte position, end byte position,
-- and annotation.
function Parser:events()
  local specs = self:specs()
  local para_spec = specs[1]
  local subjectlen = #self.subject

  return function()  -- iterator

    while self.pos <= subjectlen do

      -- return any accumulated matches
      if self.returned < #self.matches then
        self.returned = self.returned + 1
        return unpack(self.matches[self.returned])
      end

      self.indent = 0
      self.startline = self.pos
      self.finished_line = false
      self:get_eol()

      -- check open containers for continuation
      self.last_matched_container = 0
      local idx = 0
      while idx < #self.containers do
        idx = idx + 1
        local container = self.containers[idx]
        -- skip any indentation
        self:skip_space()
        if container:continue() then
          self.last_matched_container = idx
        else
          break
        end
      end

      -- if we hit a close fence, we can move to next line
      if self.finished_line then
        while #self.containers > self.last_matched_container do
          self.containers[#self.containers]:close()
        end
      end

      if not self.finished_line then
        -- check for new containers
        self:skip_space()
        local is_blank = (self.pos == self.starteol)

        local new_starts = false
        local last_match = self.containers[self.last_matched_container]
        local check_starts = not is_blank and
                            (not last_match or last_match.content == "block") and
                              not self:find("^%a+%s") -- optimization
        while check_starts do
          check_starts = false
          for i=1,#specs do
            local spec = specs[i]
            if not spec.is_para then
              if spec:open() then
                self.last_matched_container = #self.containers
                if self.finished_line then
                  check_starts = false
                else
                  self:skip_space()
                  new_starts = true
                  check_starts = spec.content == "block"
                end
                break
              end
            end
          end
        end

        if not self.finished_line then
          -- handle remaining content
          self:skip_space()

          is_blank = (self.pos == self.starteol)

          local is_lazy = not is_blank and
                          not new_starts and
                          self.last_matched_container < #self.containers and
                          self.containers[#self.containers].content == 'inline'

          local last_matched = self.last_matched_container
          if not is_lazy then
            while #self.containers > 0 and #self.containers > last_matched do
              self.containers[#self.containers]:close()
            end
          end

          local tip = self.containers[#self.containers]

          -- add para by default if there's text
          if not tip or tip.content == 'block' then
            if is_blank then
              if not new_starts then
                -- need to track these for tight/loose lists
                self:add_match(self.pos, self.endeol, "blankline")
              end
            else
              para_spec:open()
            end
            tip = self.containers[#self.containers]
          end

          if tip then
            if tip.content == "text" then
              local startpos = self.pos
              if tip.indent and self.indent > tip.indent then
                -- get back the leading spaces we gobbled
                startpos = startpos - (self.indent - tip.indent)
              end
              self:add_match(startpos, self.endeol, "str")
            elseif tip.content == "inline" then
              if not is_blank then
                tip.inline_parser:feed(self.pos, self.endeol)
              end
            end
          end
        end
      end

      self.pos = self.endeol + 1

    end

    -- close unmatched containers
    while #self.containers > 0 do
      self.containers[#self.containers]:close()
    end
    -- return any accumulated matches
    if self.returned < #self.matches then
      self.returned = self.returned + 1
      return unpack(self.matches[self.returned])
    end

  end

end

return { Parser = Parser,
         Container = Container }

end

package.preload["djot.ast"] = function()
--- @module djot.ast
--- Construct an AST for a djot document.

if not utf8 then -- if not lua 5.3 or higher...
  -- this is needed for the __pairs metamethod, used below
  -- The following code is derived from the compat53 rock:
  -- override pairs
  local oldpairs = pairs
  pairs = function(t)
    local mt = getmetatable(t)
    if type(mt) == "table" and type(mt.__pairs) == "function" then
      return mt.__pairs(t)
    else
      return oldpairs(t)
    end
  end
end
local unpack = unpack or table.unpack

local find, lower, sub, rep, format =
  string.find, string.lower, string.sub, string.rep, string.format

-- Creates a sparse array whose indices are byte positions.
-- sourcepos_map[bytepos] = "line:column:charpos"
local function make_sourcepos_map(input)
  local sourcepos_map = {line = {}, col = {}, charpos = {}}
  local line = 1
  local col = 0
  local charpos = 0
  local bytepos = 1

  local byte = string.byte(input, bytepos)
  while byte do
    col = col + 1
    charpos = charpos + 1
    -- get next code point:
    local newbytepos
    if byte < 0xC0 then
      newbytepos = bytepos + 1
    elseif byte < 0xE0 then
      newbytepos = bytepos + 2
    elseif byte < 0xF0 then
      newbytepos = bytepos + 3
    else
      newbytepos = bytepos + 4
    end
    while bytepos < newbytepos do
      sourcepos_map.line[bytepos] = line
      sourcepos_map.col[bytepos] = col
      sourcepos_map.charpos[bytepos] = charpos
      bytepos = bytepos + 1
    end
    if byte == 10 then -- newline
      line = line + 1
      col = 0
    end
    byte = string.byte(input, bytepos)
  end

  sourcepos_map.line[bytepos] = line + 1
  sourcepos_map.col[bytepos] = 1
  sourcepos_map.charpos[bytepos] = charpos + 1

  return sourcepos_map
end

local function get_string_content(node)
  local buffer = {}
  if node.s then
    buffer[#buffer + 1] = node.s
  elseif node.t == "softbreak" then
    buffer[#buffer + 1] = "\n"
  elseif node.c then
    for i=1, #node.c do
      buffer[#buffer + 1] = get_string_content(node.c[i])
    end
  end
  return table.concat(buffer)
end

local roman_digits = {
  i = 1,
  v = 5,
  x = 10,
  l = 50,
  c = 100,
  d = 500,
  m = 1000 }

local function roman_to_number(s)
  -- go backwards through the digits
  local total = 0
  local prevdigit = 0
  local i=#s
  while i > 0 do
    local c = lower(sub(s,i,i))
    local n = roman_digits[c]
    if n < prevdigit then -- e.g. ix
      total = total - n
    else
      total = total + n
    end
    assert(n ~= nil, "Encountered bad character in roman numeral " .. s)
    prevdigit = n
    i = i - 1
  end
  return total
end

local function get_list_start(marker, style)
  local numtype = string.gsub(style, "%p", "")
  local s = string.gsub(marker, "%p", "")
  if numtype == "1" then
    return tonumber(s)
  elseif numtype == "A" then
    return (string.byte(s) - string.byte("A") + 1)
  elseif numtype == "a" then
    return (string.byte(s) - string.byte("a") + 1)
  elseif numtype == "I" then
    return roman_to_number(s)
  elseif numtype == "i" then
    return roman_to_number(s)
  elseif numtype == "" then
    return nil
  end
end

local ignorable = {
  image_marker = true,
  escape = true,
  blankline = true
}

local function sortedpairs(compare_function, to_displaykey)
  return function(tbl)
    local keys = {}
    local k = nil
    k = next(tbl, k)
    while k do
      keys[#keys + 1] = k
      k = next(tbl, k)
    end
    table.sort(keys, compare_function)
    local keyindex = 0
    local function ordered_next(tabl,_)
      keyindex = keyindex + 1
      local key = keys[keyindex]
      -- use canonical names
      local displaykey = to_displaykey(key)
      if key then
        return displaykey, tabl[key]
      else
        return nil
      end
    end
    -- Return an iterator function, the table, starting point
    return ordered_next, tbl, nil
  end
end

-- provide children, tag, and text as aliases of c, t, s,
-- which we use above for better performance:
local mt = {}
local special = {
    children = 'c',
    text = 's',
    tag = 't' }
local displaykeys = {
    c = 'children',
    s = 'text',
    t = 'tag' }
mt.__index = function(table, key)
  local k = special[key]
  if k then
    return rawget(table, k)
  else
    return rawget(table, key)
  end
end
mt.__newindex = function(table, key, val)
  local k = special[key]
  if k then
    rawset(table, k, val)
  else
    rawset(table, key, val)
  end
end
mt.__pairs = sortedpairs(function(a,b)
    if a == "t" then -- t is always first
      return true
    elseif a == "s" then -- s is always second
      return (b ~= "t")
    elseif a == "c" then -- c only before references, footnotes
      return (b == "references" or b == "footnotes")
    elseif a == "references" then
      return (b == "footnotes")
    elseif a == "footnotes" then
      return false
    elseif b == "t" or b == "s" then
      return false
    elseif b == "c" or b == "references" or b == "footnotes" then
      return true
    else
      return (a < b)
    end
  end, function(k) return displaykeys[k] or k end)


--- Create a new AST node.
--- @param tag (string) tag for the node
--- @return node (table)
local function new_node(tag)
  local node = { t = tag, c = nil }
  setmetatable(node, mt)
  return node
end

--- Add `child` as a child of `node`.
--- @param node parent node
--- @param child child node
local function add_child(node, child)
  if (not node.c) then
    node.c = {child}
  else
    node.c[#node.c + 1] = child
  end
end

--- Returns true if `node` has children.
--- @param node node to check
--- @return true if node has children
local function has_children(node)
  return (node.c and #node.c > 0)
end

--- Returns an attributes object.
--- @param tbl table of attributes and values
--- @return attributes object (table including special metatable for
--- deterministic order of iteration)
local function new_attributes(tbl)
  local attr = tbl or {}
  -- ensure deterministic order of iteration
  setmetatable(attr, {__pairs = sortedpairs(function(a,b) return a < b end,
                                            function(k) return k end)})
  return attr
end

--- Insert an attribute into an attributes object.
--- @param attr attributes object
--- @param key (string) key of new attribute
--- @param val (string) value of new attribute
local function insert_attribute(attr, key, val)
  val = val:gsub("%s+", " ") -- normalize spaces
  if key == "class" then
    if attr.class then
      attr.class = attr.class .. " " .. val
    else
      attr.class = val
    end
  else
    attr[key] = val
  end
end

--- Copy attributes from `source` to `target`.
--- @param target attributes object
--- @param source table associating keys and values
local function copy_attributes(target, source)
  if source then
    for k,v in pairs(source) do
      insert_attribute(target, k, v)
    end
  end
end

local function insert_attributes_from_nodes(targetnode, cs)
  targetnode.attr = targetnode.attr or new_attributes()
  local i=1
  while i <= #cs do
    local x, y = cs[i].t, cs[i].s
    if x == "id" or x == "class" then
      insert_attribute(targetnode.attr, x, y)
    elseif x == "key" then
      local valnode = cs[i + 1]
      if valnode.t == "value" then
        -- resolve backslash escapes
        insert_attribute(targetnode.attr, y, valnode.s:gsub("\\(%p)", "%1"))
      end
      i = i + 1
    end
    i = i + 1
  end
end

local function make_definition_list_item(node)
  node.t = "definition_list_item"
  if not has_children(node) then
    node.c = {}
  end
  if node.c[1] and node.c[1].t == "para" then
    node.c[1].t = "term"
  else
    table.insert(node.c, 1, new_node("term"))
  end
  if node.c[2] then
    local defn = new_node("definition")
    defn.c = {}
    for i=2,#node.c do
      defn.c[#defn.c + 1] = node.c[i]
      node.c[i] = nil
    end
    node.c[2] = defn
  end
end

local function resolve_style(list)
  local style = nil
  for k,i in pairs(list.styles) do
    if not style or i < style.priority then
      style = {name = k, priority = i}
    end
  end
  list.list_style = style.name
  list.styles = nil
  list.start = get_list_start(list.startmarker, list.list_style)
  list.startmarker = nil
end

local function add_sections(ast)
  if not has_children(ast) then
    return ast
  end
  local newast = new_node("doc")
  local secs = { {sec = newast, level = 0 } }
  for _,node in ipairs(ast.c) do
    if node.t == "heading" then
      local level = node.level
      local curlevel = (#secs > 0 and secs[#secs].level) or 0
      if curlevel >= level then
        while secs[#secs].level >= level do
          local sec = table.remove(secs).sec
          add_child(secs[#secs].sec, sec)
        end
      end
      -- now we know: curlevel < level
      local newsec = new_node("section")
      newsec.attr = new_attributes{id = node.attr.id}
      node.attr.id = nil
      add_child(newsec, node)
      secs[#secs + 1] = {sec = newsec, level = level}
    else
      add_child(secs[#secs].sec, node)
    end
  end
  while #secs > 1 do
    local sec = table.remove(secs).sec
    add_child(secs[#secs].sec, sec)
  end
  assert(secs[1].sec == newast)
  return newast
end


--- Create an abstract syntax tree based on an event
--- stream and references.
--- @param parser djot streaming parser
--- @param sourcepos if true, include source positions
--- @return table representing the AST
local function to_ast(parser, sourcepos)
  local subject = parser.subject
  local warn = parser.warn
  if not warn then
    warn = function() end
  end
  local sourceposmap
  if sourcepos then
    sourceposmap = make_sourcepos_map(subject)
  end
  local references = {}
  local footnotes = {}
  local identifiers = {} -- identifiers used (to ensure uniqueness)

  -- generate auto identifier for heading
  local function get_identifier(s)
    local base = s:gsub("[][~!@#$%^&*(){}`,.<>\\|=+/?]","")
                  :gsub("^%s+",""):gsub("%s+$","")
                  :gsub("%s+","-")
    local i = 0
    local ident = base
    -- generate unique id
    while identifiers[ident] do
      i = i + 1
      ident = base .. tostring(i)
    end
    identifiers[ident] = true
    return ident
  end

  local function format_sourcepos(bytepos)
    if bytepos then
      return string.format("%d:%d:%d", sourceposmap.line[bytepos],
              sourceposmap.col[bytepos], sourceposmap.charpos[bytepos])
    end
  end

  local function set_startpos(node, pos)
    if sourceposmap then
      local sp = format_sourcepos(pos)
      if node.pos then
        node.pos[1] = sp
      else
        node.pos = {sp, nil}
      end
    end
  end

  local function set_endpos(node, pos)
    if sourceposmap and node.pos then
      local ep = format_sourcepos(pos)
      if node.pos then
        node.pos[2] = ep
      else
        node.pos = {nil, ep}
      end
    end
  end

  local blocktag = {
    heading = true,
    div = true,
    list = true,
    list_item = true,
    code_block = true,
    para = true,
    blockquote = true,
    table = true,
    thematic_break = true,
    raw_block = true,
    reference_definition = true,
    footnote = true
  }

  local block_attributes = nil
  local function add_block_attributes(node)
    if block_attributes and blocktag[node.t:gsub("%[.*%]","")] then
      for i=1,#block_attributes do
        insert_attributes_from_nodes(node, block_attributes[i])
      end
      -- add to identifiers table so we don't get duplicate auto-generated ids
      if node.attr and node.attr.id then
        identifiers[node.attr.id] = true
      end
      block_attributes = nil
    end
  end

  -- two variables used for tight/loose list determination:
  local tags = {} -- used to keep track of blank lines
  local matchidx = 0 -- keep track of the index of the match

  local function is_tight(startidx, endidx, is_last_item)
    -- see if there are any blank lines between blocks in a list item.
    local blanklines = 0
    -- we don't care about blank lines at very end of list
    if is_last_item then
      while tags[endidx] == "blankline" or tags[endidx] == "-list_item" do
        endidx = endidx - 1
      end
    end
    for i=startidx, endidx do
      local tag = tags[i]
      if tag == "blankline" then
        if not ((string.find(tags[i+1], "%+list_item") or
                (string.find(tags[i+1], "%-list_item") and
                 (is_last_item or
                   string.find(tags[i+2], "%-list_item"))))) then
          -- don't count blank lines before list starts
          -- don't count blank lines at end of nested lists or end of last item
          blanklines = blanklines + 1
        end
      end
    end
    return (blanklines == 0)
  end

  local function add_child_to_tip(containers, child)
    if containers[#containers].t == "list" and
        not (child.t == "list_item" or child.t == "definition_list_item") then
      -- close list
      local oldlist = table.remove(containers)
      add_child_to_tip(containers, oldlist)
    end
    if child.t == "list" then
      if child.pos then
        child.pos[2] = child.c[#child.c].pos[2]
      end
      -- calculate tightness (TODO not quite right)
      local tight = true
      for i=1,#child.c do
        tight = tight and is_tight(child.c[i].startidx,
                                     child.c[i].endidx, i == #child.c)
        child.c[i].startidx = nil
        child.c[i].endidx = nil
      end
      child.tight = tight

      -- resolve style if still ambiguous
      resolve_style(child)
    end
    add_child(containers[#containers], child)
  end


  -- process a match:
  -- containers is the stack of containers, with #container
  -- being the one that would receive a new node
  local function handle_match(containers, startpos, endpos, annot)
    matchidx = matchidx + 1
    local mod, tag = string.match(annot, "^([-+]?)(.+)")
    tags[matchidx] = annot
    if ignorable[tag] then
      return
    end
    if mod == "+" then
      -- process open match:
      -- * open a new node and put it at end of containers stack
      -- * depending on the tag name, do other things
      local node = new_node(tag)
      set_startpos(node, startpos)

      -- add block attributes if any have accumulated:
      add_block_attributes(node)

      if tag == "heading" then
         node.level = (endpos - startpos) + 1

      elseif find(tag, "^list_item") then
        node.t = "list_item"
        node.startidx = matchidx -- for tight/loose determination
        local _, _, style_marker = string.find(tag, "(%[.*)")
        local styles = {}
        if style_marker then
          local i=1
          for sty in string.gmatch(style_marker, "%[([^]]*)%]") do
            styles[sty] = i
            i = i + 1
          end
        end
        node.style_marker = style_marker

        local marker = string.match(subject, "^%S+", startpos)

        -- adjust container stack so that the tip can accept this
        -- kind of list item, adding a list if needed and possibly
        -- closing an existing list

        local tip = containers[#containers]
        if tip.t ~= "list" then
          -- container is not a list ; add one
          local list = new_node("list")
          set_startpos(list, startpos)
          list.styles = styles
          list.attr = node.attr
          list.startmarker = marker
          node.attr = nil
          containers[#containers + 1] = list
        else
          -- it's a list, but is it the right kind?
          local matched_styles = {}
          local has_match = false
          for k,_ in pairs(styles) do
            if tip.styles[k] then
              has_match = true
              matched_styles[k] = styles[k]
            end
          end
          if has_match then
            -- yes, list can accept this item
            tip.styles = matched_styles
          else
            -- no, list can't accept this item ; close it
            local oldlist = table.remove(containers)
            add_child_to_tip(containers, oldlist)
            -- add a new sibling list node with the right style
            local list = new_node("list")
            set_startpos(list, startpos)
            list.styles = styles
            list.attr = node.attr
            list.startmarker = marker
            node.attr = nil
            containers[#containers + 1] = list
          end
        end


      end

      -- add to container stack
      containers[#containers + 1] = node

    elseif mod == "-" then
      -- process close match:
      -- * check end of containers stack; if tag matches, add
      --   end position, pop the item off the stack, and add
      --   it as a child of the next container on the stack
      -- * if it doesn't match, issue a warning and ignore this tag

      if containers[#containers].t == "list" then
        local listnode = table.remove(containers)
        add_child_to_tip(containers, listnode)
      end

      if tag == containers[#containers].t then
        local node = table.remove(containers)
        set_endpos(node, endpos)

        if node.t == "block_attributes" then
          if not block_attributes then
            block_attributes = {}
          end
          block_attributes[#block_attributes + 1] = node.c
          return -- we don't add this to parent; instead we store
          -- the block attributes and add them to the next block

        elseif node.t == "attributes" then
          -- parse attributes, add to last node
          local tip = containers[#containers]
          local prevnode = has_children(tip) and tip.c[#tip.c]
          if prevnode then
            local endswithspace = false
            if prevnode.t == "str" then
              -- split off last consecutive word of string
              -- to which to attach attributes
              local lastwordpos = string.find(prevnode.s, "[^%s]+$")
              if not lastwordpos then
                endswithspace = true
              elseif lastwordpos > 1 then
                local newnode = new_node("str")
                newnode.s = sub(prevnode.s, lastwordpos, -1)
                prevnode.s = sub(prevnode.s, 1, lastwordpos - 1)
                add_child_to_tip(containers, newnode)
                prevnode = newnode
              end
            end
            if has_children(node) and not endswithspace then
              insert_attributes_from_nodes(prevnode, node.c)
            else
              warn({message = "Ignoring unattached attribute", pos = startpos})
            end
          else
            warn({message = "Ignoring unattached attribute", pos = startpos})
          end
          return -- don't add the attribute node to the tree

        elseif tag == "reference_definition" then
          local dest = ""
          local key
          for i=1,#node.c do
            if node.c[i].t == "reference_key" then
              key = node.c[i].s
            end
            if node.c[i].t == "reference_value" then
              dest = dest .. node.c[i].s
            end
          end
          references[key] = new_node("reference")
          references[key].destination = dest
          if node.attr then
            references[key].attr = node.attr
          end
          return -- don't include in tree

        elseif tag == "footnote" then
          local label
          if has_children(node) and node.c[1].t == "note_label" then
            label = node.c[1].s
            table.remove(node.c, 1)
          end
          if label then
            footnotes[label] = node
          end
          return -- don't include in tree


        elseif tag == "table" then

          -- Children are the rows. Look for a separator line:
          -- if found, make the preceding rows headings
          -- and set attributes for column alignments on the table.

          local i=1
          local aligns = {}
          while i <= #node.c do
            local found, align, _
            if node.c[i].t == "row" then
              local row = node.c[i].c
              for j=1,#row do
                found, _, align = find(row[j].t, "^separator_(.*)")
                if not found then
                  break
                end
                aligns[j] = align
              end
              if found and #aligns > 0 then
                -- set previous row to head and adjust aligns
                local prevrow = node.c[i - 1]
                if prevrow and prevrow.t == "row" then
                  prevrow.head = true
                  for k=1,#prevrow.c do
                    -- set head on cells too
                    prevrow.c[k].head = true
                    if aligns[k] ~= "default" then
                      prevrow.c[k].align = aligns[k]
                    end
                  end
                end
                table.remove(node.c, i) -- remove sep line
                -- we don't need to increment i because we removed ith elt
              else
                if #aligns > 0 then
                  for l=1,#node.c[i].c do
                    if aligns[l] ~= "default" then
                      node.c[i].c[l].align = aligns[l]
                    end
                  end
                end
                i = i + 1
              end
            end
          end

        elseif tag == "code_block" then
          if has_children(node) then
            if node.c[1].t == "code_language" then
              node.lang = node.c[1].s
              table.remove(node.c, 1)
            elseif node.c[1].t == "raw_format" then
              local fmt = node.c[1].s:sub(2)
              table.remove(node.c, 1)
              node.t = "raw_block"
              node.format = fmt
            end
          end
          node.s = get_string_content(node)
          node.c = nil

        elseif find(tag, "^list_item") then
          node.t = "list_item"
          node.endidx = matchidx -- for tight/loose determination

          if node.style_marker == "[:]" then
            make_definition_list_item(node)
          end

          if node.style_marker == "[X]" and has_children(node) then
            if node.c[1].t == "checkbox_checked" then
              node.checkbox = "checked"
              table.remove(node.c, 1)
            elseif node.c[1].t == "checkbox_unchecked" then
              node.checkbox = "unchecked"
              table.remove(node.c, 1)
            end
          end

          node.style_marker = nil

        elseif tag == "inline_math" then
          node.t = "math"
          node.attr = new_attributes{class = "math inline"}

        elseif tag == "display_math" then
          node.t = "math"
          node.attr = new_attributes{class = "math display"}

        elseif tag == "imagetext" then
          node.t = "image"

        elseif tag == "linktext" then
          node.t = "link"

        elseif tag == "div" then
          node.c = node.c or {}
          if node.c[1] and node.c[1].t == "class" then
            node.attr = new_attributes(node.attr)
            insert_attribute(node.attr, "class", get_string_content(node.c[1]))
            table.remove(node.c, 1)
          end

        elseif tag == "verbatim" then
          local s = get_string_content(node)
          -- trim space next to ` at beginning or end
          if find(s, "^ +`") then
            s = s:sub(2)
          end
          if find(s, "` +$") then
            s = s:sub(1, #s - 1)
          end
          node.s = s
          node.c = nil

        elseif tag == "url" then
          node.destination = get_string_content(node)

        elseif tag == "email" then
          node.destination = "mailto:" .. get_string_content(node)

        elseif tag == "caption" then
          local tip = containers[#containers]
          local prevnode = has_children(tip) and tip.c[#tip.c]
          if prevnode and prevnode.t == "table" then
            -- move caption in table node
            table.insert(prevnode.c, 1, node)
          else
            warn({ message = "Ignoring caption without preceding table",
                   pos = startpos })
          end
          return

        elseif tag == "heading" then
          local heading_str =
                 get_string_content(node):gsub("^%s+",""):gsub("%s+$","")
          if not node.attr then
            node.attr = new_attributes{}
          end
          if not node.attr.id then  -- generate id attribute from heading
            insert_attribute(node.attr, "id", get_identifier(heading_str))
          end
          -- insert into references unless there's a same-named one already:
          if not references[heading_str] then
            references[heading_str] =
              new_node("reference")
            references[heading_str].destination = "#" .. node.attr.id
          end

        elseif tag == "destination" then
           local tip = containers[#containers]
           local prevnode = has_children(tip) and tip.c[#tip.c]
           assert(prevnode and (prevnode.t == "image" or prevnode.t == "link"),
                  "destination with no preceding link or image")
           prevnode.destination = get_string_content(node):gsub("\r?\n", "")
           return  -- do not put on container stack

        elseif tag == "reference" then
           local tip = containers[#containers]
           local prevnode = has_children(tip) and tip.c[#tip.c]
           assert(prevnode and (prevnode.t == "image" or prevnode.t == "link"),
                 "reference with no preceding link or image")
           if has_children(node) then
             prevnode.reference = get_string_content(node):gsub("\r?\n", " ")
           else
             prevnode.reference = get_string_content(prevnode):gsub("\r?\n", " ")
           end
           return  -- do not put on container stack
        end

        add_child_to_tip(containers, node)
      else
        assert(false, "unmatched " .. annot .. " encountered at byte " ..
                  startpos)
        return
      end
    else
      -- process leaf node:
      -- * add position info
      -- * special handling depending on tag type
      -- * add node as child of container at end of containers stack
      local node = new_node(tag)
      add_block_attributes(node)
      set_startpos(node, startpos)
      set_endpos(node, endpos)

      -- special handling:
      if tag == "softbreak" then
        node.s = nil
      elseif tag == "reference_key" then
        node.s = sub(subject, startpos + 1, endpos - 1)
      elseif tag == "footnote_reference" then
        node.s = sub(subject, startpos + 2, endpos - 1)
      elseif tag == "emoji" then
        node.alias = sub(subject, startpos + 1, endpos - 1)
      elseif tag == "raw_format" then
        local tip = containers[#containers]
        local prevnode = has_children(tip) and tip.c[#tip.c]
        if prevnode and prevnode.t == "verbatim" then
          local s = get_string_content(prevnode)
          prevnode.t = "raw_inline"
          prevnode.s = s
          prevnode.c = nil
          prevnode.format = sub(subject, startpos + 2, endpos - 1)
          return  -- don't add this node to containers
        else
          node.s = sub(subject, startpos, endpos)
        end
      else
        node.s = sub(subject, startpos, endpos)
      end

      add_child_to_tip(containers, node)

    end
  end

  local doc = new_node("doc")
  local containers = {doc}
  for sp, ep, annot in parser:events() do
    handle_match(containers, sp, ep, annot)
  end
  -- close any open containers
  while #containers > 1 do
    local node = table.remove(containers)
    add_child_to_tip(containers, node)
    -- note: doc container doesn't have pos, so we check:
    if sourceposmap and containers[#containers].pos then
      containers[#containers].pos[2] = node.pos[2]
    end
  end
  doc = add_sections(doc)

  doc.references = references
  doc.footnotes = footnotes

  return doc
end

local function render_node(node, handle, indent)
  indent = indent or 0
  handle:write(rep(" ", indent))
  if indent > 128 then
    handle:write("(((DEEPLY NESTED CONTENT OMITTED)))\n")
    return
  end

  if node.t then
    handle:write(node.t)
    if node.pos then
      handle:write(format(" (%s-%s)", node.pos[1], node.pos[2]))
    end
    for k,v in pairs(node) do
      if type(k) == "string" and k ~= "children" and
          k ~= "tag" and k ~= "pos" and k ~= "attr"  and
          k ~= "references" and k ~= "footnotes" then
        handle:write(format(" %s=%q", k, tostring(v)))
      end
    end
    if node.attr then
      for k,v in pairs(node.attr) do
        handle:write(format(" %s=%q", k, v))
      end
    end
  else
    io.stderr:write("Encountered node without tag:\n" ..
                      require'inspect'(node))
    os.exit(1)
  end
  handle:write("\n")
  if node.c then
    for _,v in ipairs(node.c) do
      render_node(v, handle, indent + 2)
    end
  end
end

--- Render an AST in human-readable form, with indentation
--- showing the hierarchy.
--- @param doc (table) djot AST
--- @param handle handle to which to write content
--- @return result of flushing handle
local function render(doc, handle)
  render_node(doc, handle, 0)
  if next(doc.references) ~= nil then
    handle:write("references\n")
    for k,v in pairs(doc.references) do
      handle:write(format("  [%q] =\n", k))
      render_node(v, handle, 4)
    end
  end
  if next(doc.footnotes) ~= nil then
    handle:write("footnotes\n")
    for k,v in pairs(doc.footnotes) do
      handle:write(format("  [%q] =\n", k))
      render_node(v, handle, 4)
    end
  end
end

--- @export
return { to_ast = to_ast,
         render = render,
         insert_attribute = insert_attribute,
         copy_attributes = copy_attributes,
         new_attributes = new_attributes,
         new_node = new_node,
         add_child = add_child,
         has_children = has_children }

end

package.preload["djot.emoji"] = function()
return {grinning="😀",
smiley="😃",
smile="😄",
grin="😁",
laughing="😆",
satisfied="😆",
sweat_smile="😅",
rofl="🤣",
joy="😂",
slightly_smiling_face="🙂",
upside_down_face="🙃",
wink="😉",
blush="😊",
innocent="😇",
smiling_face_with_three_hearts="🥰",
heart_eyes="😍",
star_struck="🤩",
kissing_heart="😘",
kissing="😗",
relaxed="☺️",
kissing_closed_eyes="😚",
kissing_smiling_eyes="😙",
smiling_face_with_tear="🥲",
yum="😋",
stuck_out_tongue="😛",
stuck_out_tongue_winking_eye="😜",
zany_face="🤪",
stuck_out_tongue_closed_eyes="😝",
money_mouth_face="🤑",
hugs="🤗",
hand_over_mouth="🤭",
shushing_face="🤫",
thinking="🤔",
zipper_mouth_face="🤐",
raised_eyebrow="🤨",
neutral_face="😐",
expressionless="😑",
no_mouth="😶",
face_in_clouds="😶‍🌫️",
smirk="😏",
unamused="😒",
roll_eyes="🙄",
grimacing="😬",
face_exhaling="😮‍💨",
lying_face="🤥",
relieved="😌",
pensive="😔",
sleepy="😪",
drooling_face="🤤",
sleeping="😴",
mask="😷",
face_with_thermometer="🤒",
face_with_head_bandage="🤕",
nauseated_face="🤢",
vomiting_face="🤮",
sneezing_face="🤧",
hot_face="🥵",
cold_face="🥶",
woozy_face="🥴",
dizzy_face="😵",
face_with_spiral_eyes="😵‍💫",
exploding_head="🤯",
cowboy_hat_face="🤠",
partying_face="🥳",
disguised_face="🥸",
sunglasses="😎",
nerd_face="🤓",
monocle_face="🧐",
confused="😕",
worried="😟",
slightly_frowning_face="🙁",
frowning_face="☹️",
open_mouth="😮",
hushed="😯",
astonished="😲",
flushed="😳",
pleading_face="🥺",
frowning="😦",
anguished="😧",
fearful="😨",
cold_sweat="😰",
disappointed_relieved="😥",
cry="😢",
sob="😭",
scream="😱",
confounded="😖",
persevere="😣",
disappointed="😞",
sweat="😓",
weary="😩",
tired_face="😫",
yawning_face="🥱",
triumph="😤",
rage="😡",
pout="😡",
angry="😠",
cursing_face="🤬",
smiling_imp="😈",
imp="👿",
skull="💀",
skull_and_crossbones="☠️",
hankey="💩",
poop="💩",
shit="💩",
clown_face="🤡",
japanese_ogre="👹",
japanese_goblin="👺",
ghost="👻",
alien="👽",
space_invader="👾",
robot="🤖",
smiley_cat="😺",
smile_cat="😸",
joy_cat="😹",
heart_eyes_cat="😻",
smirk_cat="😼",
kissing_cat="😽",
scream_cat="🙀",
crying_cat_face="😿",
pouting_cat="😾",
see_no_evil="🙈",
hear_no_evil="🙉",
speak_no_evil="🙊",
kiss="💋",
love_letter="💌",
cupid="💘",
gift_heart="💝",
sparkling_heart="💖",
heartpulse="💗",
heartbeat="💓",
revolving_hearts="💞",
two_hearts="💕",
heart_decoration="💟",
heavy_heart_exclamation="❣️",
broken_heart="💔",
heart_on_fire="❤️‍🔥",
mending_heart="❤️‍🩹",
heart="❤️",
orange_heart="🧡",
yellow_heart="💛",
green_heart="💚",
blue_heart="💙",
purple_heart="💜",
brown_heart="🤎",
black_heart="🖤",
white_heart="🤍",
["100"]="💯",
anger="💢",
boom="💥",
collision="💥",
dizzy="💫",
sweat_drops="💦",
dash="💨",
hole="🕳️",
bomb="💣",
speech_balloon="💬",
eye_speech_bubble="👁️‍🗨️",
left_speech_bubble="🗨️",
right_anger_bubble="🗯️",
thought_balloon="💭",
zzz="💤",
wave="👋",
raised_back_of_hand="🤚",
raised_hand_with_fingers_splayed="🖐️",
hand="✋",
raised_hand="✋",
vulcan_salute="🖖",
ok_hand="👌",
pinched_fingers="🤌",
pinching_hand="🤏",
v="✌️",
crossed_fingers="🤞",
love_you_gesture="🤟",
metal="🤘",
call_me_hand="🤙",
point_left="👈",
point_right="👉",
["point_up_2"]="👆",
middle_finger="🖕",
fu="🖕",
point_down="👇",
point_up="☝️",
["+1"]="👍",
thumbsup="👍",
["-1"]="👎",
thumbsdown="👎",
fist_raised="✊",
fist="✊",
fist_oncoming="👊",
facepunch="👊",
punch="👊",
fist_left="🤛",
fist_right="🤜",
clap="👏",
raised_hands="🙌",
open_hands="👐",
palms_up_together="🤲",
handshake="🤝",
pray="🙏",
writing_hand="✍️",
nail_care="💅",
selfie="🤳",
muscle="💪",
mechanical_arm="🦾",
mechanical_leg="🦿",
leg="🦵",
foot="🦶",
ear="👂",
ear_with_hearing_aid="🦻",
nose="👃",
brain="🧠",
anatomical_heart="🫀",
lungs="🫁",
tooth="🦷",
bone="🦴",
eyes="👀",
eye="👁️",
tongue="👅",
lips="👄",
baby="👶",
child="🧒",
boy="👦",
girl="👧",
adult="🧑",
blond_haired_person="👱",
man="👨",
bearded_person="🧔",
man_beard="🧔‍♂️",
woman_beard="🧔‍♀️",
red_haired_man="👨‍🦰",
curly_haired_man="👨‍🦱",
white_haired_man="👨‍🦳",
bald_man="👨‍🦲",
woman="👩",
red_haired_woman="👩‍🦰",
person_red_hair="🧑‍🦰",
curly_haired_woman="👩‍🦱",
person_curly_hair="🧑‍🦱",
white_haired_woman="👩‍🦳",
person_white_hair="🧑‍🦳",
bald_woman="👩‍🦲",
person_bald="🧑‍🦲",
blond_haired_woman="👱‍♀️",
blonde_woman="👱‍♀️",
blond_haired_man="👱‍♂️",
older_adult="🧓",
older_man="👴",
older_woman="👵",
frowning_person="🙍",
frowning_man="🙍‍♂️",
frowning_woman="🙍‍♀️",
pouting_face="🙎",
pouting_man="🙎‍♂️",
pouting_woman="🙎‍♀️",
no_good="🙅",
no_good_man="🙅‍♂️",
ng_man="🙅‍♂️",
no_good_woman="🙅‍♀️",
ng_woman="🙅‍♀️",
ok_person="🙆",
ok_man="🙆‍♂️",
ok_woman="🙆‍♀️",
tipping_hand_person="💁",
information_desk_person="💁",
tipping_hand_man="💁‍♂️",
sassy_man="💁‍♂️",
tipping_hand_woman="💁‍♀️",
sassy_woman="💁‍♀️",
raising_hand="🙋",
raising_hand_man="🙋‍♂️",
raising_hand_woman="🙋‍♀️",
deaf_person="🧏",
deaf_man="🧏‍♂️",
deaf_woman="🧏‍♀️",
bow="🙇",
bowing_man="🙇‍♂️",
bowing_woman="🙇‍♀️",
facepalm="🤦",
man_facepalming="🤦‍♂️",
woman_facepalming="🤦‍♀️",
shrug="🤷",
man_shrugging="🤷‍♂️",
woman_shrugging="🤷‍♀️",
health_worker="🧑‍⚕️",
man_health_worker="👨‍⚕️",
woman_health_worker="👩‍⚕️",
student="🧑‍🎓",
man_student="👨‍🎓",
woman_student="👩‍🎓",
teacher="🧑‍🏫",
man_teacher="👨‍🏫",
woman_teacher="👩‍🏫",
judge="🧑‍⚖️",
man_judge="👨‍⚖️",
woman_judge="👩‍⚖️",
farmer="🧑‍🌾",
man_farmer="👨‍🌾",
woman_farmer="👩‍🌾",
cook="🧑‍🍳",
man_cook="👨‍🍳",
woman_cook="👩‍🍳",
mechanic="🧑‍🔧",
man_mechanic="👨‍🔧",
woman_mechanic="👩‍🔧",
factory_worker="🧑‍🏭",
man_factory_worker="👨‍🏭",
woman_factory_worker="👩‍🏭",
office_worker="🧑‍💼",
man_office_worker="👨‍💼",
woman_office_worker="👩‍💼",
scientist="🧑‍🔬",
man_scientist="👨‍🔬",
woman_scientist="👩‍🔬",
technologist="🧑‍💻",
man_technologist="👨‍💻",
woman_technologist="👩‍💻",
singer="🧑‍🎤",
man_singer="👨‍🎤",
woman_singer="👩‍🎤",
artist="🧑‍🎨",
man_artist="👨‍🎨",
woman_artist="👩‍🎨",
pilot="🧑‍✈️",
man_pilot="👨‍✈️",
woman_pilot="👩‍✈️",
astronaut="🧑‍🚀",
man_astronaut="👨‍🚀",
woman_astronaut="👩‍🚀",
firefighter="🧑‍🚒",
man_firefighter="👨‍🚒",
woman_firefighter="👩‍🚒",
police_officer="👮",
cop="👮",
policeman="👮‍♂️",
policewoman="👮‍♀️",
detective="🕵️",
male_detective="🕵️‍♂️",
female_detective="🕵️‍♀️",
guard="💂",
guardsman="💂‍♂️",
guardswoman="💂‍♀️",
ninja="🥷",
construction_worker="👷",
construction_worker_man="👷‍♂️",
construction_worker_woman="👷‍♀️",
prince="🤴",
princess="👸",
person_with_turban="👳",
man_with_turban="👳‍♂️",
woman_with_turban="👳‍♀️",
man_with_gua_pi_mao="👲",
woman_with_headscarf="🧕",
person_in_tuxedo="🤵",
man_in_tuxedo="🤵‍♂️",
woman_in_tuxedo="🤵‍♀️",
person_with_veil="👰",
man_with_veil="👰‍♂️",
woman_with_veil="👰‍♀️",
bride_with_veil="👰‍♀️",
pregnant_woman="🤰",
breast_feeding="🤱",
woman_feeding_baby="👩‍🍼",
man_feeding_baby="👨‍🍼",
person_feeding_baby="🧑‍🍼",
angel="👼",
santa="🎅",
mrs_claus="🤶",
mx_claus="🧑‍🎄",
superhero="🦸",
superhero_man="🦸‍♂️",
superhero_woman="🦸‍♀️",
supervillain="🦹",
supervillain_man="🦹‍♂️",
supervillain_woman="🦹‍♀️",
mage="🧙",
mage_man="🧙‍♂️",
mage_woman="🧙‍♀️",
fairy="🧚",
fairy_man="🧚‍♂️",
fairy_woman="🧚‍♀️",
vampire="🧛",
vampire_man="🧛‍♂️",
vampire_woman="🧛‍♀️",
merperson="🧜",
merman="🧜‍♂️",
mermaid="🧜‍♀️",
elf="🧝",
elf_man="🧝‍♂️",
elf_woman="🧝‍♀️",
genie="🧞",
genie_man="🧞‍♂️",
genie_woman="🧞‍♀️",
zombie="🧟",
zombie_man="🧟‍♂️",
zombie_woman="🧟‍♀️",
massage="💆",
massage_man="💆‍♂️",
massage_woman="💆‍♀️",
haircut="💇",
haircut_man="💇‍♂️",
haircut_woman="💇‍♀️",
walking="🚶",
walking_man="🚶‍♂️",
walking_woman="🚶‍♀️",
standing_person="🧍",
standing_man="🧍‍♂️",
standing_woman="🧍‍♀️",
kneeling_person="🧎",
kneeling_man="🧎‍♂️",
kneeling_woman="🧎‍♀️",
person_with_probing_cane="🧑‍🦯",
man_with_probing_cane="👨‍🦯",
woman_with_probing_cane="👩‍🦯",
person_in_motorized_wheelchair="🧑‍🦼",
man_in_motorized_wheelchair="👨‍🦼",
woman_in_motorized_wheelchair="👩‍🦼",
person_in_manual_wheelchair="🧑‍🦽",
man_in_manual_wheelchair="👨‍🦽",
woman_in_manual_wheelchair="👩‍🦽",
runner="🏃",
running="🏃",
running_man="🏃‍♂️",
running_woman="🏃‍♀️",
woman_dancing="💃",
dancer="💃",
man_dancing="🕺",
business_suit_levitating="🕴️",
dancers="👯",
dancing_men="👯‍♂️",
dancing_women="👯‍♀️",
sauna_person="🧖",
sauna_man="🧖‍♂️",
sauna_woman="🧖‍♀️",
climbing="🧗",
climbing_man="🧗‍♂️",
climbing_woman="🧗‍♀️",
person_fencing="🤺",
horse_racing="🏇",
skier="⛷️",
snowboarder="🏂",
golfing="🏌️",
golfing_man="🏌️‍♂️",
golfing_woman="🏌️‍♀️",
surfer="🏄",
surfing_man="🏄‍♂️",
surfing_woman="🏄‍♀️",
rowboat="🚣",
rowing_man="🚣‍♂️",
rowing_woman="🚣‍♀️",
swimmer="🏊",
swimming_man="🏊‍♂️",
swimming_woman="🏊‍♀️",
bouncing_ball_person="⛹️",
bouncing_ball_man="⛹️‍♂️",
basketball_man="⛹️‍♂️",
bouncing_ball_woman="⛹️‍♀️",
basketball_woman="⛹️‍♀️",
weight_lifting="🏋️",
weight_lifting_man="🏋️‍♂️",
weight_lifting_woman="🏋️‍♀️",
bicyclist="🚴",
biking_man="🚴‍♂️",
biking_woman="🚴‍♀️",
mountain_bicyclist="🚵",
mountain_biking_man="🚵‍♂️",
mountain_biking_woman="🚵‍♀️",
cartwheeling="🤸",
man_cartwheeling="🤸‍♂️",
woman_cartwheeling="🤸‍♀️",
wrestling="🤼",
men_wrestling="🤼‍♂️",
women_wrestling="🤼‍♀️",
water_polo="🤽",
man_playing_water_polo="🤽‍♂️",
woman_playing_water_polo="🤽‍♀️",
handball_person="🤾",
man_playing_handball="🤾‍♂️",
woman_playing_handball="🤾‍♀️",
juggling_person="🤹",
man_juggling="🤹‍♂️",
woman_juggling="🤹‍♀️",
lotus_position="🧘",
lotus_position_man="🧘‍♂️",
lotus_position_woman="🧘‍♀️",
bath="🛀",
sleeping_bed="🛌",
people_holding_hands="🧑‍🤝‍🧑",
two_women_holding_hands="👭",
couple="👫",
two_men_holding_hands="👬",
couplekiss="💏",
couplekiss_man_woman="👩‍❤️‍💋‍👨",
couplekiss_man_man="👨‍❤️‍💋‍👨",
couplekiss_woman_woman="👩‍❤️‍💋‍👩",
couple_with_heart="💑",
couple_with_heart_woman_man="👩‍❤️‍👨",
couple_with_heart_man_man="👨‍❤️‍👨",
couple_with_heart_woman_woman="👩‍❤️‍👩",
family="👪",
family_man_woman_boy="👨‍👩‍👦",
family_man_woman_girl="👨‍👩‍👧",
family_man_woman_girl_boy="👨‍👩‍👧‍👦",
family_man_woman_boy_boy="👨‍👩‍👦‍👦",
family_man_woman_girl_girl="👨‍👩‍👧‍👧",
family_man_man_boy="👨‍👨‍👦",
family_man_man_girl="👨‍👨‍👧",
family_man_man_girl_boy="👨‍👨‍👧‍👦",
family_man_man_boy_boy="👨‍👨‍👦‍👦",
family_man_man_girl_girl="👨‍👨‍👧‍👧",
family_woman_woman_boy="👩‍👩‍👦",
family_woman_woman_girl="👩‍👩‍👧",
family_woman_woman_girl_boy="👩‍👩‍👧‍👦",
family_woman_woman_boy_boy="👩‍👩‍👦‍👦",
family_woman_woman_girl_girl="👩‍👩‍👧‍👧",
family_man_boy="👨‍👦",
family_man_boy_boy="👨‍👦‍👦",
family_man_girl="👨‍👧",
family_man_girl_boy="👨‍👧‍👦",
family_man_girl_girl="👨‍👧‍👧",
family_woman_boy="👩‍👦",
family_woman_boy_boy="👩‍👦‍👦",
family_woman_girl="👩‍👧",
family_woman_girl_boy="👩‍👧‍👦",
family_woman_girl_girl="👩‍👧‍👧",
speaking_head="🗣️",
bust_in_silhouette="👤",
busts_in_silhouette="👥",
people_hugging="🫂",
footprints="👣",
monkey_face="🐵",
monkey="🐒",
gorilla="🦍",
orangutan="🦧",
dog="🐶",
["dog2"]="🐕",
guide_dog="🦮",
service_dog="🐕‍🦺",
poodle="🐩",
wolf="🐺",
fox_face="🦊",
raccoon="🦝",
cat="🐱",
["cat2"]="🐈",
black_cat="🐈‍⬛",
lion="🦁",
tiger="🐯",
["tiger2"]="🐅",
leopard="🐆",
horse="🐴",
racehorse="🐎",
unicorn="🦄",
zebra="🦓",
deer="🦌",
bison="🦬",
cow="🐮",
ox="🐂",
water_buffalo="🐃",
["cow2"]="🐄",
pig="🐷",
["pig2"]="🐖",
boar="🐗",
pig_nose="🐽",
ram="🐏",
sheep="🐑",
goat="🐐",
dromedary_camel="🐪",
camel="🐫",
llama="🦙",
giraffe="🦒",
elephant="🐘",
mammoth="🦣",
rhinoceros="🦏",
hippopotamus="🦛",
mouse="🐭",
["mouse2"]="🐁",
rat="🐀",
hamster="🐹",
rabbit="🐰",
["rabbit2"]="🐇",
chipmunk="🐿️",
beaver="🦫",
hedgehog="🦔",
bat="🦇",
bear="🐻",
polar_bear="🐻‍❄️",
koala="🐨",
panda_face="🐼",
sloth="🦥",
otter="🦦",
skunk="🦨",
kangaroo="🦘",
badger="🦡",
feet="🐾",
paw_prints="🐾",
turkey="🦃",
chicken="🐔",
rooster="🐓",
hatching_chick="🐣",
baby_chick="🐤",
hatched_chick="🐥",
bird="🐦",
penguin="🐧",
dove="🕊️",
eagle="🦅",
duck="🦆",
swan="🦢",
owl="🦉",
dodo="🦤",
feather="🪶",
flamingo="🦩",
peacock="🦚",
parrot="🦜",
frog="🐸",
crocodile="🐊",
turtle="🐢",
lizard="🦎",
snake="🐍",
dragon_face="🐲",
dragon="🐉",
sauropod="🦕",
["t-rex"]="🦖",
whale="🐳",
["whale2"]="🐋",
dolphin="🐬",
flipper="🐬",
seal="🦭",
fish="🐟",
tropical_fish="🐠",
blowfish="🐡",
shark="🦈",
octopus="🐙",
shell="🐚",
snail="🐌",
butterfly="🦋",
bug="🐛",
ant="🐜",
bee="🐝",
honeybee="🐝",
beetle="🪲",
lady_beetle="🐞",
cricket="🦗",
cockroach="🪳",
spider="🕷️",
spider_web="🕸️",
scorpion="🦂",
mosquito="🦟",
fly="🪰",
worm="🪱",
microbe="🦠",
bouquet="💐",
cherry_blossom="🌸",
white_flower="💮",
rosette="🏵️",
rose="🌹",
wilted_flower="🥀",
hibiscus="🌺",
sunflower="🌻",
blossom="🌼",
tulip="🌷",
seedling="🌱",
potted_plant="🪴",
evergreen_tree="🌲",
deciduous_tree="🌳",
palm_tree="🌴",
cactus="🌵",
ear_of_rice="🌾",
herb="🌿",
shamrock="☘️",
four_leaf_clover="🍀",
maple_leaf="🍁",
fallen_leaf="🍂",
leaves="🍃",
grapes="🍇",
melon="🍈",
watermelon="🍉",
tangerine="🍊",
orange="🍊",
mandarin="🍊",
lemon="🍋",
banana="🍌",
pineapple="🍍",
mango="🥭",
apple="🍎",
green_apple="🍏",
pear="🍐",
peach="🍑",
cherries="🍒",
strawberry="🍓",
blueberries="🫐",
kiwi_fruit="🥝",
tomato="🍅",
olive="🫒",
coconut="🥥",
avocado="🥑",
eggplant="🍆",
potato="🥔",
carrot="🥕",
corn="🌽",
hot_pepper="🌶️",
bell_pepper="🫑",
cucumber="🥒",
leafy_green="🥬",
broccoli="🥦",
garlic="🧄",
onion="🧅",
mushroom="🍄",
peanuts="🥜",
chestnut="🌰",
bread="🍞",
croissant="🥐",
baguette_bread="🥖",
flatbread="🫓",
pretzel="🥨",
bagel="🥯",
pancakes="🥞",
waffle="🧇",
cheese="🧀",
meat_on_bone="🍖",
poultry_leg="🍗",
cut_of_meat="🥩",
bacon="🥓",
hamburger="🍔",
fries="🍟",
pizza="🍕",
hotdog="🌭",
sandwich="🥪",
taco="🌮",
burrito="🌯",
tamale="🫔",
stuffed_flatbread="🥙",
falafel="🧆",
egg="🥚",
fried_egg="🍳",
shallow_pan_of_food="🥘",
stew="🍲",
fondue="🫕",
bowl_with_spoon="🥣",
green_salad="🥗",
popcorn="🍿",
butter="🧈",
salt="🧂",
canned_food="🥫",
bento="🍱",
rice_cracker="🍘",
rice_ball="🍙",
rice="🍚",
curry="🍛",
ramen="🍜",
spaghetti="🍝",
sweet_potato="🍠",
oden="🍢",
sushi="🍣",
fried_shrimp="🍤",
fish_cake="🍥",
moon_cake="🥮",
dango="🍡",
dumpling="🥟",
fortune_cookie="🥠",
takeout_box="🥡",
crab="🦀",
lobster="🦞",
shrimp="🦐",
squid="🦑",
oyster="🦪",
icecream="🍦",
shaved_ice="🍧",
ice_cream="🍨",
doughnut="🍩",
cookie="🍪",
birthday="🎂",
cake="🍰",
cupcake="🧁",
pie="🥧",
chocolate_bar="🍫",
candy="🍬",
lollipop="🍭",
custard="🍮",
honey_pot="🍯",
baby_bottle="🍼",
milk_glass="🥛",
coffee="☕",
teapot="🫖",
tea="🍵",
sake="🍶",
champagne="🍾",
wine_glass="🍷",
cocktail="🍸",
tropical_drink="🍹",
beer="🍺",
beers="🍻",
clinking_glasses="🥂",
tumbler_glass="🥃",
cup_with_straw="🥤",
bubble_tea="🧋",
beverage_box="🧃",
mate="🧉",
ice_cube="🧊",
chopsticks="🥢",
plate_with_cutlery="🍽️",
fork_and_knife="🍴",
spoon="🥄",
hocho="🔪",
knife="🔪",
amphora="🏺",
earth_africa="🌍",
earth_americas="🌎",
earth_asia="🌏",
globe_with_meridians="🌐",
world_map="🗺️",
japan="🗾",
compass="🧭",
mountain_snow="🏔️",
mountain="⛰️",
volcano="🌋",
mount_fuji="🗻",
camping="🏕️",
beach_umbrella="🏖️",
desert="🏜️",
desert_island="🏝️",
national_park="🏞️",
stadium="🏟️",
classical_building="🏛️",
building_construction="🏗️",
bricks="🧱",
rock="🪨",
wood="🪵",
hut="🛖",
houses="🏘️",
derelict_house="🏚️",
house="🏠",
house_with_garden="🏡",
office="🏢",
post_office="🏣",
european_post_office="🏤",
hospital="🏥",
bank="🏦",
hotel="🏨",
love_hotel="🏩",
convenience_store="🏪",
school="🏫",
department_store="🏬",
factory="🏭",
japanese_castle="🏯",
european_castle="🏰",
wedding="💒",
tokyo_tower="🗼",
statue_of_liberty="🗽",
church="⛪",
mosque="🕌",
hindu_temple="🛕",
synagogue="🕍",
shinto_shrine="⛩️",
kaaba="🕋",
fountain="⛲",
tent="⛺",
foggy="🌁",
night_with_stars="🌃",
cityscape="🏙️",
sunrise_over_mountains="🌄",
sunrise="🌅",
city_sunset="🌆",
city_sunrise="🌇",
bridge_at_night="🌉",
hotsprings="♨️",
carousel_horse="🎠",
ferris_wheel="🎡",
roller_coaster="🎢",
barber="💈",
circus_tent="🎪",
steam_locomotive="🚂",
railway_car="🚃",
bullettrain_side="🚄",
bullettrain_front="🚅",
["train2"]="🚆",
metro="🚇",
light_rail="🚈",
station="🚉",
tram="🚊",
monorail="🚝",
mountain_railway="🚞",
train="🚋",
bus="🚌",
oncoming_bus="🚍",
trolleybus="🚎",
minibus="🚐",
ambulance="🚑",
fire_engine="🚒",
police_car="🚓",
oncoming_police_car="🚔",
taxi="🚕",
oncoming_taxi="🚖",
car="🚗",
red_car="🚗",
oncoming_automobile="🚘",
blue_car="🚙",
pickup_truck="🛻",
truck="🚚",
articulated_lorry="🚛",
tractor="🚜",
racing_car="🏎️",
motorcycle="🏍️",
motor_scooter="🛵",
manual_wheelchair="🦽",
motorized_wheelchair="🦼",
auto_rickshaw="🛺",
bike="🚲",
kick_scooter="🛴",
skateboard="🛹",
roller_skate="🛼",
busstop="🚏",
motorway="🛣️",
railway_track="🛤️",
oil_drum="🛢️",
fuelpump="⛽",
rotating_light="🚨",
traffic_light="🚥",
vertical_traffic_light="🚦",
stop_sign="🛑",
construction="🚧",
anchor="⚓",
boat="⛵",
sailboat="⛵",
canoe="🛶",
speedboat="🚤",
passenger_ship="🛳️",
ferry="⛴️",
motor_boat="🛥️",
ship="🚢",
airplane="✈️",
small_airplane="🛩️",
flight_departure="🛫",
flight_arrival="🛬",
parachute="🪂",
seat="💺",
helicopter="🚁",
suspension_railway="🚟",
mountain_cableway="🚠",
aerial_tramway="🚡",
artificial_satellite="🛰️",
rocket="🚀",
flying_saucer="🛸",
bellhop_bell="🛎️",
luggage="🧳",
hourglass="⌛",
hourglass_flowing_sand="⏳",
watch="⌚",
alarm_clock="⏰",
stopwatch="⏱️",
timer_clock="⏲️",
mantelpiece_clock="🕰️",
["clock12"]="🕛",
["clock1230"]="🕧",
["clock1"]="🕐",
["clock130"]="🕜",
["clock2"]="🕑",
["clock230"]="🕝",
["clock3"]="🕒",
["clock330"]="🕞",
["clock4"]="🕓",
["clock430"]="🕟",
["clock5"]="🕔",
["clock530"]="🕠",
["clock6"]="🕕",
["clock630"]="🕡",
["clock7"]="🕖",
["clock730"]="🕢",
["clock8"]="🕗",
["clock830"]="🕣",
["clock9"]="🕘",
["clock930"]="🕤",
["clock10"]="🕙",
["clock1030"]="🕥",
["clock11"]="🕚",
["clock1130"]="🕦",
new_moon="🌑",
waxing_crescent_moon="🌒",
first_quarter_moon="🌓",
moon="🌔",
waxing_gibbous_moon="🌔",
full_moon="🌕",
waning_gibbous_moon="🌖",
last_quarter_moon="🌗",
waning_crescent_moon="🌘",
crescent_moon="🌙",
new_moon_with_face="🌚",
first_quarter_moon_with_face="🌛",
last_quarter_moon_with_face="🌜",
thermometer="🌡️",
sunny="☀️",
full_moon_with_face="🌝",
sun_with_face="🌞",
ringed_planet="🪐",
star="⭐",
["star2"]="🌟",
stars="🌠",
milky_way="🌌",
cloud="☁️",
partly_sunny="⛅",
cloud_with_lightning_and_rain="⛈️",
sun_behind_small_cloud="🌤️",
sun_behind_large_cloud="🌥️",
sun_behind_rain_cloud="🌦️",
cloud_with_rain="🌧️",
cloud_with_snow="🌨️",
cloud_with_lightning="🌩️",
tornado="🌪️",
fog="🌫️",
wind_face="🌬️",
cyclone="🌀",
rainbow="🌈",
closed_umbrella="🌂",
open_umbrella="☂️",
umbrella="☔",
parasol_on_ground="⛱️",
zap="⚡",
snowflake="❄️",
snowman_with_snow="☃️",
snowman="⛄",
comet="☄️",
fire="🔥",
droplet="💧",
ocean="🌊",
jack_o_lantern="🎃",
christmas_tree="🎄",
fireworks="🎆",
sparkler="🎇",
firecracker="🧨",
sparkles="✨",
balloon="🎈",
tada="🎉",
confetti_ball="🎊",
tanabata_tree="🎋",
bamboo="🎍",
dolls="🎎",
flags="🎏",
wind_chime="🎐",
rice_scene="🎑",
red_envelope="🧧",
ribbon="🎀",
gift="🎁",
reminder_ribbon="🎗️",
tickets="🎟️",
ticket="🎫",
medal_military="🎖️",
trophy="🏆",
medal_sports="🏅",
["1st_place_medal"]="🥇",
["2nd_place_medal"]="🥈",
["3rd_place_medal"]="🥉",
soccer="⚽",
baseball="⚾",
softball="🥎",
basketball="🏀",
volleyball="🏐",
football="🏈",
rugby_football="🏉",
tennis="🎾",
flying_disc="🥏",
bowling="🎳",
cricket_game="🏏",
field_hockey="🏑",
ice_hockey="🏒",
lacrosse="🥍",
ping_pong="🏓",
badminton="🏸",
boxing_glove="🥊",
martial_arts_uniform="🥋",
goal_net="🥅",
golf="⛳",
ice_skate="⛸️",
fishing_pole_and_fish="🎣",
diving_mask="🤿",
running_shirt_with_sash="🎽",
ski="🎿",
sled="🛷",
curling_stone="🥌",
dart="🎯",
yo_yo="🪀",
kite="🪁",
["8ball"]="🎱",
crystal_ball="🔮",
magic_wand="🪄",
nazar_amulet="🧿",
video_game="🎮",
joystick="🕹️",
slot_machine="🎰",
game_die="🎲",
jigsaw="🧩",
teddy_bear="🧸",
pinata="🪅",
nesting_dolls="🪆",
spades="♠️",
hearts="♥️",
diamonds="♦️",
clubs="♣️",
chess_pawn="♟️",
black_joker="🃏",
mahjong="🀄",
flower_playing_cards="🎴",
performing_arts="🎭",
framed_picture="🖼️",
art="🎨",
thread="🧵",
sewing_needle="🪡",
yarn="🧶",
knot="🪢",
eyeglasses="👓",
dark_sunglasses="🕶️",
goggles="🥽",
lab_coat="🥼",
safety_vest="🦺",
necktie="👔",
shirt="👕",
tshirt="👕",
jeans="👖",
scarf="🧣",
gloves="🧤",
coat="🧥",
socks="🧦",
dress="👗",
kimono="👘",
sari="🥻",
one_piece_swimsuit="🩱",
swim_brief="🩲",
shorts="🩳",
bikini="👙",
womans_clothes="👚",
purse="👛",
handbag="👜",
pouch="👝",
shopping="🛍️",
school_satchel="🎒",
thong_sandal="🩴",
mans_shoe="👞",
shoe="👞",
athletic_shoe="👟",
hiking_boot="🥾",
flat_shoe="🥿",
high_heel="👠",
sandal="👡",
ballet_shoes="🩰",
boot="👢",
crown="👑",
womans_hat="👒",
tophat="🎩",
mortar_board="🎓",
billed_cap="🧢",
military_helmet="🪖",
rescue_worker_helmet="⛑️",
prayer_beads="📿",
lipstick="💄",
ring="💍",
gem="💎",
mute="🔇",
speaker="🔈",
sound="🔉",
loud_sound="🔊",
loudspeaker="📢",
mega="📣",
postal_horn="📯",
bell="🔔",
no_bell="🔕",
musical_score="🎼",
musical_note="🎵",
notes="🎶",
studio_microphone="🎙️",
level_slider="🎚️",
control_knobs="🎛️",
microphone="🎤",
headphones="🎧",
radio="📻",
saxophone="🎷",
accordion="🪗",
guitar="🎸",
musical_keyboard="🎹",
trumpet="🎺",
violin="🎻",
banjo="🪕",
drum="🥁",
long_drum="🪘",
iphone="📱",
calling="📲",
phone="☎️",
telephone="☎️",
telephone_receiver="📞",
pager="📟",
fax="📠",
battery="🔋",
electric_plug="🔌",
computer="💻",
desktop_computer="🖥️",
printer="🖨️",
keyboard="⌨️",
computer_mouse="🖱️",
trackball="🖲️",
minidisc="💽",
floppy_disk="💾",
cd="💿",
dvd="📀",
abacus="🧮",
movie_camera="🎥",
film_strip="🎞️",
film_projector="📽️",
clapper="🎬",
tv="📺",
camera="📷",
camera_flash="📸",
video_camera="📹",
vhs="📼",
mag="🔍",
mag_right="🔎",
candle="🕯️",
bulb="💡",
flashlight="🔦",
izakaya_lantern="🏮",
lantern="🏮",
diya_lamp="🪔",
notebook_with_decorative_cover="📔",
closed_book="📕",
book="📖",
open_book="📖",
green_book="📗",
blue_book="📘",
orange_book="📙",
books="📚",
notebook="📓",
ledger="📒",
page_with_curl="📃",
scroll="📜",
page_facing_up="📄",
newspaper="📰",
newspaper_roll="🗞️",
bookmark_tabs="📑",
bookmark="🔖",
label="🏷️",
moneybag="💰",
coin="🪙",
yen="💴",
dollar="💵",
euro="💶",
pound="💷",
money_with_wings="💸",
credit_card="💳",
receipt="🧾",
chart="💹",
envelope="✉️",
email="📧",
["e-mail"]="📧",
incoming_envelope="📨",
envelope_with_arrow="📩",
outbox_tray="📤",
inbox_tray="📥",
package="📦",
mailbox="📫",
mailbox_closed="📪",
mailbox_with_mail="📬",
mailbox_with_no_mail="📭",
postbox="📮",
ballot_box="🗳️",
["pencil2"]="✏️",
black_nib="✒️",
fountain_pen="🖋️",
pen="🖊️",
paintbrush="🖌️",
crayon="🖍️",
memo="📝",
pencil="📝",
briefcase="💼",
file_folder="📁",
open_file_folder="📂",
card_index_dividers="🗂️",
date="📅",
calendar="📆",
spiral_notepad="🗒️",
spiral_calendar="🗓️",
card_index="📇",
chart_with_upwards_trend="📈",
chart_with_downwards_trend="📉",
bar_chart="📊",
clipboard="📋",
pushpin="📌",
round_pushpin="📍",
paperclip="📎",
paperclips="🖇️",
straight_ruler="📏",
triangular_ruler="📐",
scissors="✂️",
card_file_box="🗃️",
file_cabinet="🗄️",
wastebasket="🗑️",
lock="🔒",
unlock="🔓",
lock_with_ink_pen="🔏",
closed_lock_with_key="🔐",
key="🔑",
old_key="🗝️",
hammer="🔨",
axe="🪓",
pick="⛏️",
hammer_and_pick="⚒️",
hammer_and_wrench="🛠️",
dagger="🗡️",
crossed_swords="⚔️",
gun="🔫",
boomerang="🪃",
bow_and_arrow="🏹",
shield="🛡️",
carpentry_saw="🪚",
wrench="🔧",
screwdriver="🪛",
nut_and_bolt="🔩",
gear="⚙️",
clamp="🗜️",
balance_scale="⚖️",
probing_cane="🦯",
link="🔗",
chains="⛓️",
hook="🪝",
toolbox="🧰",
magnet="🧲",
ladder="🪜",
alembic="⚗️",
test_tube="🧪",
petri_dish="🧫",
dna="🧬",
microscope="🔬",
telescope="🔭",
satellite="📡",
syringe="💉",
drop_of_blood="🩸",
pill="💊",
adhesive_bandage="🩹",
stethoscope="🩺",
door="🚪",
elevator="🛗",
mirror="🪞",
window="🪟",
bed="🛏️",
couch_and_lamp="🛋️",
chair="🪑",
toilet="🚽",
plunger="🪠",
shower="🚿",
bathtub="🛁",
mouse_trap="🪤",
razor="🪒",
lotion_bottle="🧴",
safety_pin="🧷",
broom="🧹",
basket="🧺",
roll_of_paper="🧻",
bucket="🪣",
soap="🧼",
toothbrush="🪥",
sponge="🧽",
fire_extinguisher="🧯",
shopping_cart="🛒",
smoking="🚬",
coffin="⚰️",
headstone="🪦",
funeral_urn="⚱️",
moyai="🗿",
placard="🪧",
atm="🏧",
put_litter_in_its_place="🚮",
potable_water="🚰",
wheelchair="♿",
mens="🚹",
womens="🚺",
restroom="🚻",
baby_symbol="🚼",
wc="🚾",
passport_control="🛂",
customs="🛃",
baggage_claim="🛄",
left_luggage="🛅",
warning="⚠️",
children_crossing="🚸",
no_entry="⛔",
no_entry_sign="🚫",
no_bicycles="🚳",
no_smoking="🚭",
do_not_litter="🚯",
["non-potable_water"]="🚱",
no_pedestrians="🚷",
no_mobile_phones="📵",
underage="🔞",
radioactive="☢️",
biohazard="☣️",
arrow_up="⬆️",
arrow_upper_right="↗️",
arrow_right="➡️",
arrow_lower_right="↘️",
arrow_down="⬇️",
arrow_lower_left="↙️",
arrow_left="⬅️",
arrow_upper_left="↖️",
arrow_up_down="↕️",
left_right_arrow="↔️",
leftwards_arrow_with_hook="↩️",
arrow_right_hook="↪️",
arrow_heading_up="⤴️",
arrow_heading_down="⤵️",
arrows_clockwise="🔃",
arrows_counterclockwise="🔄",
back="🔙",
["end"]="🔚",
on="🔛",
soon="🔜",
top="🔝",
place_of_worship="🛐",
atom_symbol="⚛️",
om="🕉️",
star_of_david="✡️",
wheel_of_dharma="☸️",
yin_yang="☯️",
latin_cross="✝️",
orthodox_cross="☦️",
star_and_crescent="☪️",
peace_symbol="☮️",
menorah="🕎",
six_pointed_star="🔯",
aries="♈",
taurus="♉",
gemini="♊",
cancer="♋",
leo="♌",
virgo="♍",
libra="♎",
scorpius="♏",
sagittarius="♐",
capricorn="♑",
aquarius="♒",
pisces="♓",
ophiuchus="⛎",
twisted_rightwards_arrows="🔀",
["repeat"]="🔁",
repeat_one="🔂",
arrow_forward="▶️",
fast_forward="⏩",
next_track_button="⏭️",
play_or_pause_button="⏯️",
arrow_backward="◀️",
rewind="⏪",
previous_track_button="⏮️",
arrow_up_small="🔼",
arrow_double_up="⏫",
arrow_down_small="🔽",
arrow_double_down="⏬",
pause_button="⏸️",
stop_button="⏹️",
record_button="⏺️",
eject_button="⏏️",
cinema="🎦",
low_brightness="🔅",
high_brightness="🔆",
signal_strength="📶",
vibration_mode="📳",
mobile_phone_off="📴",
female_sign="♀️",
male_sign="♂️",
transgender_symbol="⚧️",
heavy_multiplication_x="✖️",
heavy_plus_sign="➕",
heavy_minus_sign="➖",
heavy_division_sign="➗",
infinity="♾️",
bangbang="‼️",
interrobang="⁉️",
question="❓",
grey_question="❔",
grey_exclamation="❕",
exclamation="❗",
heavy_exclamation_mark="❗",
wavy_dash="〰️",
currency_exchange="💱",
heavy_dollar_sign="💲",
medical_symbol="⚕️",
recycle="♻️",
fleur_de_lis="⚜️",
trident="🔱",
name_badge="📛",
beginner="🔰",
o="⭕",
white_check_mark="✅",
ballot_box_with_check="☑️",
heavy_check_mark="✔️",
x="❌",
negative_squared_cross_mark="❎",
curly_loop="➰",
loop="➿",
part_alternation_mark="〽️",
eight_spoked_asterisk="✳️",
eight_pointed_black_star="✴️",
sparkle="❇️",
copyright="©️",
registered="®️",
tm="™️",
hash="#️⃣",
asterisk="*️⃣",
zero="0️⃣",
one="1️⃣",
two="2️⃣",
three="3️⃣",
four="4️⃣",
five="5️⃣",
six="6️⃣",
seven="7️⃣",
eight="8️⃣",
nine="9️⃣",
keycap_ten="🔟",
capital_abcd="🔠",
abcd="🔡",
["1234"]="🔢",
symbols="🔣",
abc="🔤",
a="🅰️",
ab="🆎",
b="🅱️",
cl="🆑",
cool="🆒",
free="🆓",
information_source="ℹ️",
id="🆔",
m="Ⓜ️",
new="🆕",
ng="🆖",
["o2"]="🅾️",
ok="🆗",
parking="🅿️",
sos="🆘",
up="🆙",
vs="🆚",
koko="🈁",
sa="🈂️",
["u6708"]="🈷️",
["u6709"]="🈶",
["u6307"]="🈯",
ideograph_advantage="🉐",
["u5272"]="🈹",
["u7121"]="🈚",
["u7981"]="🈲",
accept="🉑",
["u7533"]="🈸",
["u5408"]="🈴",
["u7a7a"]="🈳",
congratulations="㊗️",
secret="㊙️",
["u55b6"]="🈺",
["u6e80"]="🈵",
red_circle="🔴",
orange_circle="🟠",
yellow_circle="🟡",
green_circle="🟢",
large_blue_circle="🔵",
purple_circle="🟣",
brown_circle="🟤",
black_circle="⚫",
white_circle="⚪",
red_square="🟥",
orange_square="🟧",
yellow_square="🟨",
green_square="🟩",
blue_square="🟦",
purple_square="🟪",
brown_square="🟫",
black_large_square="⬛",
white_large_square="⬜",
black_medium_square="◼️",
white_medium_square="◻️",
black_medium_small_square="◾",
white_medium_small_square="◽",
black_small_square="▪️",
white_small_square="▫️",
large_orange_diamond="🔶",
large_blue_diamond="🔷",
small_orange_diamond="🔸",
small_blue_diamond="🔹",
small_red_triangle="🔺",
small_red_triangle_down="🔻",
diamond_shape_with_a_dot_inside="💠",
radio_button="🔘",
white_square_button="🔳",
black_square_button="🔲",
checkered_flag="🏁",
triangular_flag_on_post="🚩",
crossed_flags="🎌",
black_flag="🏴",
white_flag="🏳️",
rainbow_flag="🏳️‍🌈",
transgender_flag="🏳️‍⚧️",
pirate_flag="🏴‍☠️",
ascension_island="🇦🇨",
andorra="🇦🇩",
united_arab_emirates="🇦🇪",
afghanistan="🇦🇫",
antigua_barbuda="🇦🇬",
anguilla="🇦🇮",
albania="🇦🇱",
armenia="🇦🇲",
angola="🇦🇴",
antarctica="🇦🇶",
argentina="🇦🇷",
american_samoa="🇦🇸",
austria="🇦🇹",
australia="🇦🇺",
aruba="🇦🇼",
aland_islands="🇦🇽",
azerbaijan="🇦🇿",
bosnia_herzegovina="🇧🇦",
barbados="🇧🇧",
bangladesh="🇧🇩",
belgium="🇧🇪",
burkina_faso="🇧🇫",
bulgaria="🇧🇬",
bahrain="🇧🇭",
burundi="🇧🇮",
benin="🇧🇯",
st_barthelemy="🇧🇱",
bermuda="🇧🇲",
brunei="🇧🇳",
bolivia="🇧🇴",
caribbean_netherlands="🇧🇶",
brazil="🇧🇷",
bahamas="🇧🇸",
bhutan="🇧🇹",
bouvet_island="🇧🇻",
botswana="🇧🇼",
belarus="🇧🇾",
belize="🇧🇿",
canada="🇨🇦",
cocos_islands="🇨🇨",
congo_kinshasa="🇨🇩",
central_african_republic="🇨🇫",
congo_brazzaville="🇨🇬",
switzerland="🇨🇭",
cote_divoire="🇨🇮",
cook_islands="🇨🇰",
chile="🇨🇱",
cameroon="🇨🇲",
cn="🇨🇳",
colombia="🇨🇴",
clipperton_island="🇨🇵",
costa_rica="🇨🇷",
cuba="🇨🇺",
cape_verde="🇨🇻",
curacao="🇨🇼",
christmas_island="🇨🇽",
cyprus="🇨🇾",
czech_republic="🇨🇿",
de="🇩🇪",
diego_garcia="🇩🇬",
djibouti="🇩🇯",
denmark="🇩🇰",
dominica="🇩🇲",
dominican_republic="🇩🇴",
algeria="🇩🇿",
ceuta_melilla="🇪🇦",
ecuador="🇪🇨",
estonia="🇪🇪",
egypt="🇪🇬",
western_sahara="🇪🇭",
eritrea="🇪🇷",
es="🇪🇸",
ethiopia="🇪🇹",
eu="🇪🇺",
european_union="🇪🇺",
finland="🇫🇮",
fiji="🇫🇯",
falkland_islands="🇫🇰",
micronesia="🇫🇲",
faroe_islands="🇫🇴",
fr="🇫🇷",
gabon="🇬🇦",
gb="🇬🇧",
uk="🇬🇧",
grenada="🇬🇩",
georgia="🇬🇪",
french_guiana="🇬🇫",
guernsey="🇬🇬",
ghana="🇬🇭",
gibraltar="🇬🇮",
greenland="🇬🇱",
gambia="🇬🇲",
guinea="🇬🇳",
guadeloupe="🇬🇵",
equatorial_guinea="🇬🇶",
greece="🇬🇷",
south_georgia_south_sandwich_islands="🇬🇸",
guatemala="🇬🇹",
guam="🇬🇺",
guinea_bissau="🇬🇼",
guyana="🇬🇾",
hong_kong="🇭🇰",
heard_mcdonald_islands="🇭🇲",
honduras="🇭🇳",
croatia="🇭🇷",
haiti="🇭🇹",
hungary="🇭🇺",
canary_islands="🇮🇨",
indonesia="🇮🇩",
ireland="🇮🇪",
israel="🇮🇱",
isle_of_man="🇮🇲",
india="🇮🇳",
british_indian_ocean_territory="🇮🇴",
iraq="🇮🇶",
iran="🇮🇷",
iceland="🇮🇸",
it="🇮🇹",
jersey="🇯🇪",
jamaica="🇯🇲",
jordan="🇯🇴",
jp="🇯🇵",
kenya="🇰🇪",
kyrgyzstan="🇰🇬",
cambodia="🇰🇭",
kiribati="🇰🇮",
comoros="🇰🇲",
st_kitts_nevis="🇰🇳",
north_korea="🇰🇵",
kr="🇰🇷",
kuwait="🇰🇼",
cayman_islands="🇰🇾",
kazakhstan="🇰🇿",
laos="🇱🇦",
lebanon="🇱🇧",
st_lucia="🇱🇨",
liechtenstein="🇱🇮",
sri_lanka="🇱🇰",
liberia="🇱🇷",
lesotho="🇱🇸",
lithuania="🇱🇹",
luxembourg="🇱🇺",
latvia="🇱🇻",
libya="🇱🇾",
morocco="🇲🇦",
monaco="🇲🇨",
moldova="🇲🇩",
montenegro="🇲🇪",
st_martin="🇲🇫",
madagascar="🇲🇬",
marshall_islands="🇲🇭",
macedonia="🇲🇰",
mali="🇲🇱",
myanmar="🇲🇲",
mongolia="🇲🇳",
macau="🇲🇴",
northern_mariana_islands="🇲🇵",
martinique="🇲🇶",
mauritania="🇲🇷",
montserrat="🇲🇸",
malta="🇲🇹",
mauritius="🇲🇺",
maldives="🇲🇻",
malawi="🇲🇼",
mexico="🇲🇽",
malaysia="🇲🇾",
mozambique="🇲🇿",
namibia="🇳🇦",
new_caledonia="🇳🇨",
niger="🇳🇪",
norfolk_island="🇳🇫",
nigeria="🇳🇬",
nicaragua="🇳🇮",
netherlands="🇳🇱",
norway="🇳🇴",
nepal="🇳🇵",
nauru="🇳🇷",
niue="🇳🇺",
new_zealand="🇳🇿",
oman="🇴🇲",
panama="🇵🇦",
peru="🇵🇪",
french_polynesia="🇵🇫",
papua_new_guinea="🇵🇬",
philippines="🇵🇭",
pakistan="🇵🇰",
poland="🇵🇱",
st_pierre_miquelon="🇵🇲",
pitcairn_islands="🇵🇳",
puerto_rico="🇵🇷",
palestinian_territories="🇵🇸",
portugal="🇵🇹",
palau="🇵🇼",
paraguay="🇵🇾",
qatar="🇶🇦",
reunion="🇷🇪",
romania="🇷🇴",
serbia="🇷🇸",
ru="🇷🇺",
rwanda="🇷🇼",
saudi_arabia="🇸🇦",
solomon_islands="🇸🇧",
seychelles="🇸🇨",
sudan="🇸🇩",
sweden="🇸🇪",
singapore="🇸🇬",
st_helena="🇸🇭",
slovenia="🇸🇮",
svalbard_jan_mayen="🇸🇯",
slovakia="🇸🇰",
sierra_leone="🇸🇱",
san_marino="🇸🇲",
senegal="🇸🇳",
somalia="🇸🇴",
suriname="🇸🇷",
south_sudan="🇸🇸",
sao_tome_principe="🇸🇹",
el_salvador="🇸🇻",
sint_maarten="🇸🇽",
syria="🇸🇾",
swaziland="🇸🇿",
tristan_da_cunha="🇹🇦",
turks_caicos_islands="🇹🇨",
chad="🇹🇩",
french_southern_territories="🇹🇫",
togo="🇹🇬",
thailand="🇹🇭",
tajikistan="🇹🇯",
tokelau="🇹🇰",
timor_leste="🇹🇱",
turkmenistan="🇹🇲",
tunisia="🇹🇳",
tonga="🇹🇴",
tr="🇹🇷",
trinidad_tobago="🇹🇹",
tuvalu="🇹🇻",
taiwan="🇹🇼",
tanzania="🇹🇿",
ukraine="🇺🇦",
uganda="🇺🇬",
us_outlying_islands="🇺🇲",
united_nations="🇺🇳",
us="🇺🇸",
uruguay="🇺🇾",
uzbekistan="🇺🇿",
vatican_city="🇻🇦",
st_vincent_grenadines="🇻🇨",
venezuela="🇻🇪",
british_virgin_islands="🇻🇬",
us_virgin_islands="🇻🇮",
vietnam="🇻🇳",
vanuatu="🇻🇺",
wallis_futuna="🇼🇫",
samoa="🇼🇸",
kosovo="🇽🇰",
yemen="🇾🇪",
mayotte="🇾🇹",
south_africa="🇿🇦",
zambia="🇿🇲",
zimbabwe="🇿🇼",
england="🏴󠁧󠁢󠁥󠁮󠁧󠁿",
scotland="🏴󠁧󠁢󠁳󠁣󠁴󠁿",
wales="🏴󠁧󠁢󠁷󠁬󠁳󠁿"}

end

package.preload["djot.html"] = function()
local ast = require("djot.ast")
local new_node = ast.new_node
local new_attributes = ast.new_attributes
local add_child = ast.add_child
local unpack = unpack or table.unpack
local insert_attribute, copy_attributes =
  ast.insert_attribute, ast.copy_attributes
local format = string.format
local find, gsub = string.find, string.gsub
local emoji -- only use if there are emojis

-- Produce a copy of a table.
local function copy(tbl)
  local result = {}
  if tbl then
    for k,v in pairs(tbl) do
      local newv = v
      if type(v) == "table" then
        newv = copy(v)
      end
      result[k] = newv
    end
  end
  return result
end

local function to_text(node)
  local buffer = {}
  if node.t == "str" then
    buffer[#buffer + 1] = node.s
  elseif node.t == "nbsp" then
    buffer[#buffer + 1] = "\160"
  elseif node.t == "softbreak" then
    buffer[#buffer + 1] = " "
  elseif node.c and #node.c > 0 then
    for i=1,#node.c do
      buffer[#buffer + 1] = to_text(node.c[i])
    end
  end
  return table.concat(buffer)
end

local Renderer = {}

function Renderer:new()
  local state = {
    out = function(s)
      io.stdout:write(s)
    end,
    tight = false,
    footnote_index = {},
    next_footnote_index = 1,
    references = nil,
    footnotes = nil }
  setmetatable(state, self)
  self.__index = self
  return state
end

Renderer.html_escapes =
   { ["<"] = "&lt;",
     [">"] = "&gt;",
     ["&"] = "&amp;",
     ['"'] = "&quot;" }

function Renderer:escape_html(s)
  if find(s, '[<>&]') then
    return (gsub(s, '[<>&]', self.html_escapes))
  else
    return s
  end
end

function Renderer:escape_html_attribute(s)
  if find(s, '[<>&"]') then
    return (gsub(s, '[<>&"]', self.html_escapes))
  else
    return s
  end
end

function Renderer:render(doc, handle)
  self.references = doc.references
  self.footnotes = doc.footnotes
  if handle then
    self.out = function(s)
      handle:write(s)
    end
  end
  self[doc.t](self, doc)
end


function Renderer:render_children(node)
  -- trap stack overflow
  local ok, err = pcall(function ()
    if node.c and #node.c > 0 then
      local oldtight
      if node.tight ~= nil then
        oldtight = self.tight
        self.tight = node.tight
      end
      for i=1,#node.c do
        self[node.c[i].t](self, node.c[i])
      end
      if node.tight ~= nil then
        self.tight = oldtight
      end
    end
  end)
  if not ok and err:find("stack overflow") then
    self.out("(((DEEPLY NESTED CONTENT OMITTED)))\n")
  end
end

function Renderer:render_attrs(node)
  if node.attr then
    for k,v in pairs(node.attr) do
      self.out(" " .. k .. "=" .. '"' ..
            self:escape_html_attribute(v) .. '"')
    end
  end
  if node.pos then
    local sp, ep = unpack(node.pos)
    self.out(' data-startpos="' .. tostring(sp) ..
      '" data-endpos="' .. tostring(ep) .. '"')
  end
end

function Renderer:render_tag(tag, node)
  self.out("<" .. tag)
  self:render_attrs(node)
  self.out(">")
end

function Renderer:add_backlink(nodes, i)
  local backlink = new_node("link")
  backlink.destination = "#fnref" .. tostring(i)
  backlink.attr = ast.new_attributes({role = "doc-backlink"})
  local arrow = new_node("str")
  arrow.s = "↩︎︎"
  add_child(backlink, arrow)
  if nodes.c[#nodes.c].t == "para" then
    add_child(nodes.c[#nodes.c], backlink)
  else
    local para = new_node("para")
    add_child(para, backlink)
    add_child(nodes, para)
  end
end

function Renderer:doc(node)
  self:render_children(node)
  -- render notes
  if self.next_footnote_index > 1 then
    local ordered_footnotes = {}
    for k,v in pairs(self.footnotes) do
      if self.footnote_index[k] then
        ordered_footnotes[self.footnote_index[k]] = v
      end
    end
    self.out('<section role="doc-endnotes">\n<hr>\n<ol>\n')
    for i=1,#ordered_footnotes do
      local note = ordered_footnotes[i]
      if note then
        self.out(format('<li id="fn%d">\n', i))
        self:add_backlink(note,i)
        self:render_children(note)
        self.out('</li>\n')
      end
    end
    self.out('</ol>\n</section>\n')
  end
end

function Renderer:raw_block(node)
  if node.format == "html" then
    self.out(node.s)  -- no escaping
  end
end

function Renderer:para(node)
  if not self.tight then
    self:render_tag("p", node)
  end
  self:render_children(node)
  if not self.tight then
    self.out("</p>")
  end
  self.out("\n")
end

function Renderer:blockquote(node)
  self:render_tag("blockquote", node)
  self.out("\n")
  self:render_children(node)
  self.out("</blockquote>\n")
end

function Renderer:div(node)
  self:render_tag("div", node)
  self.out("\n")
  self:render_children(node)
  self.out("</div>\n")
end

function Renderer:section(node)
  self:render_tag("section", node)
  self.out("\n")
  self:render_children(node)
  self.out("</section>\n")
end

function Renderer:heading(node)
  self:render_tag("h" .. node.level , node)
  self:render_children(node)
  self.out("</h" .. node.level .. ">\n")
end

function Renderer:thematic_break(node)
  self:render_tag("hr", node)
  self.out("\n")
end

function Renderer:code_block(node)
  self:render_tag("pre", node)
  self.out("<code")
  if node.lang and #node.lang > 0 then
    self.out(" class=\"language-" .. node.lang .. "\"")
  end
  self.out(">")
  self.out(self:escape_html(node.s))
  self.out("</code></pre>\n")
end

function Renderer:table(node)
  self:render_tag("table", node)
  self.out("\n")
  self:render_children(node)
  self.out("</table>\n")
end

function Renderer:row(node)
  self:render_tag("tr", node)
  self.out("\n")
  self:render_children(node)
  self.out("</tr>\n")
end

function Renderer:cell(node)
  local tag
  if node.head then
    tag = "th"
  else
    tag = "td"
  end
  local attr = copy(node.attr)
  if node.align then
    insert_attribute(attr, "style", "text-align: " .. node.align .. ";")
  end
  self:render_tag(tag, {attr = attr})
  self:render_children(node)
  self.out("</" .. tag .. ">\n")
end

function Renderer:caption(node)
  self:render_tag("caption", node)
  self:render_children(node)
  self.out("</caption>\n")
end

function Renderer:list(node)
  local sty = node.list_style
  if sty == "*" or sty == "+" or sty == "-" then
    self:render_tag("ul", node)
    self.out("\n")
    self:render_children(node)
    self.out("</ul>\n")
  elseif sty == "X" then
    local attr = copy(node.attr)
    if attr.class then
      attr.class = "task-list " .. attr.class
    else
      insert_attribute(attr, "class", "task-list")
    end
    self:render_tag("ul", {attr = attr})
    self.out("\n")
    self:render_children(node)
    self.out("</ul>\n")
  elseif sty == ":" then
    self:render_tag("dl", node)
    self.out("\n")
    self:render_children(node)
    self.out("</dl>\n")
  else
    self.out("<ol")
    if node.start and node.start > 1 then
      self.out(" start=\"" .. node.start .. "\"")
    end
    local list_type = gsub(node.list_style, "%p", "")
    if list_type ~= "1" then
      self.out(" type=\"" .. list_type .. "\"")
    end
    self:render_attrs(node)
    self.out(">\n")
    self:render_children(node)
    self.out("</ol>\n")
  end
end

function Renderer:list_item(node)
  if node.checkbox then
     if node.checkbox == "checked" then
       self.out('<li class="checked">')
     elseif node.checkbox == "unchecked" then
       self.out('<li class="unchecked">')
     end
  else
    self:render_tag("li", node)
  end
  self.out("\n")
  self:render_children(node)
  self.out("</li>\n")
end

function Renderer:term(node)
  self:render_tag("dt", node)
  self:render_children(node)
  self.out("</dt>\n")
end

function Renderer:definition(node)
  self:render_tag("dd", node)
  self.out("\n")
  self:render_children(node)
  self.out("</dd>\n")
end

function Renderer:definition_list_item(node)
  self:render_children(node)
end

function Renderer:reference_definition()
end

function Renderer:footnote_reference(node)
  local label = node.s
  local index = self.footnote_index[label]
  if not index then
    index = self.next_footnote_index
    self.footnote_index[label] = index
    self.next_footnote_index = self.next_footnote_index + 1
  end
  self.out(format('<a id="fnref%d" href="#fn%d" role="doc-noteref"><sup>%d</sup></a>', index, index, index))
end

function Renderer:raw_inline(node)
  if node.format == "html" then
    self.out(node.s)  -- no escaping
  end
end

function Renderer:str(node)
  -- add a span, if needed, to contain attribute on a bare string:
  if node.attr then
    self:render_tag("span", node)
    self.out(self:escape_html(node.s))
    self.out("</span>")
  else
    self.out(self:escape_html(node.s))
  end
end

function Renderer:softbreak()
  self.out("\n")
end

function Renderer:hardbreak()
  self.out("<br>\n")
end

function Renderer:nbsp()
  self.out("&nbsp;")
end

function Renderer:verbatim(node)
  self:render_tag("code", node)
  self.out(self:escape_html(node.s))
  self.out("</code>")
end

function Renderer:link(node)
  local attrs = new_attributes{}
  if node.reference then
    local ref = self.references[node.reference]
    if ref then
      if ref.attr then
        copy_attributes(attrs, ref.attr)
      end
      insert_attribute(attrs, "href", ref.destination)
    end
  elseif node.destination then
    insert_attribute(attrs, "href", node.destination)
  end
  -- link's attributes override reference's:
  copy_attributes(attrs, node.attr)
  self:render_tag("a", {attr = attrs})
  self:render_children(node)
  self.out("</a>")
end

Renderer.url = Renderer.link

Renderer.email = Renderer.link

function Renderer:image(node)
  local attrs = new_attributes{}
  local alt_text = to_text(node)
  if #alt_text > 0 then
    insert_attribute(attrs, "alt", to_text(node))
  end
  if node.reference then
    local ref = self.references[node.reference]
    if ref then
      if ref.attr then
        copy_attributes(attrs, ref.attr)
      end
      insert_attribute(attrs, "src", ref.destination)
    end
  elseif node.destination then
    insert_attribute(attrs, "src", node.destination)
  end
  -- image's attributes override reference's:
  copy_attributes(attrs, node.attr)
  self:render_tag("img", {attr = attrs})
end

function Renderer:span(node)
  self:render_tag("span", node)
  self:render_children(node)
  self.out("</span>")
end

function Renderer:mark(node)
  self:render_tag("mark", node)
  self:render_children(node)
  self.out("</mark>")
end

function Renderer:insert(node)
  self:render_tag("ins", node)
  self:render_children(node)
  self.out("</ins>")
end

function Renderer:delete(node)
  self:render_tag("del", node)
  self:render_children(node)
  self.out("</del>")
end

function Renderer:subscript(node)
  self:render_tag("sub", node)
  self:render_children(node)
  self.out("</sub>")
end

function Renderer:superscript(node)
  self:render_tag("sup", node)
  self:render_children(node)
  self.out("</sup>")
end

function Renderer:emph(node)
  self:render_tag("em", node)
  self:render_children(node)
  self.out("</em>")
end

function Renderer:strong(node)
  self:render_tag("strong", node)
  self:render_children(node)
  self.out("</strong>")
end

function Renderer:double_quoted(node)
  self.out("&ldquo;")
  self:render_children(node)
  self.out("&rdquo;")
end

function Renderer:single_quoted(node)
  self.out("&lsquo;")
  self:render_children(node)
  self.out("&rsquo;")
end

function Renderer:left_double_quote()
  self.out("&ldquo;")
end

function Renderer:right_double_quote()
  self.out("&rdquo;")
end

function Renderer:left_single_quote()
  self.out("&lsquo;")
end

function Renderer:right_single_quote()
  self.out("&rsquo;")
end

function Renderer:ellipses()
  self.out("&hellip;")
end

function Renderer:em_dash()
  self.out("&mdash;")
end

function Renderer:en_dash()
  self.out("&ndash;")
end

function Renderer:emoji(node)
  if not emoji then
    emoji = require("djot.emoji")
  end
  local s = emoji[node.alias]
  self.out(s or (":" .. node.alias .. ":"))
end

function Renderer:math(node)
  local math_t = "inline"
  if find(node.attr.class, "display") then
    math_t = "display"
  end
  self:render_tag("span", node)
  if math_t == "inline" then
    self.out("\\(")
  else
    self.out("\\[")
  end
  self:render_children(node)
  if math_t == "inline" then
    self.out("\\)")
  else
    self.out("\\]")
  end
  self.out("</span>")
end

return { Renderer = Renderer }

end

package.preload["djot.filter"] = function()
--- @module djot.filter
--- Support filters that walk the AST and transform a
--- document between parsing and rendering, like pandoc Lua filters.
---
--- This filter uppercases all str elements.
---
---     return {
---       str = function(e)
---         e.text = e.text:upper()
---        end
---     }
---
--- A filter may define functions for as many different tag types
--- as it likes.  traverse will walk the AST and apply matching
--- functions to each node.
---
--- To load a filter:
---
---     local filter = require_filter(path)
---
--- or
---
---     local filter = load_filter(string)
---
--- By default filters do a bottom-up traversal; that is, the
--- filter for a node is run after its children have been processed.
--- It is possible to do a top-down travel, though, and even
--- to run separate actions on entering a node (before processing the
--- children) and on exiting (after processing the children). To do
--- this, associate the node's tag with a table containing `enter` and/or
--- `exit` functions.  The following filter will capitalize text
--- that is nested inside emphasis, but not other text:
---
---     local capitalize = 0
---     return {
---        emph = {
---          enter = function(e)
---            capitalize = capitalize + 1
---          end,
---          exit = function(e)
---            capitalize = capitalize - 1
---          end,
---        },
---        str = function(e)
---          if capitalize > 0 then
---            e.text = e.text:upper()
---           end
---        end
---     }
---
--- For a top-down traversal, you'd just use the `enter` functions.
--- If the tag is associated directly with a function, as in the
--- first example above, it is treated as an `exit` function.
---
--- It is possible to inhibit traversal into the children of a node,
--- by having the `enter` function return the value true (or any truish
--- value, say `'stop'`).  This can be used, for example, to prevent
--- the contents of a footnote from being processed:
---
---     return {
---       footnote = {
---         enter = function(e)
---           return true
---         end
---        }
---     }
---
--- A single filter may return a table with multiple tables, which will be
--- applied sequentially.

local function handle_node(node, filterpart)
  local action = filterpart[node.t]
  local action_in, action_out
  if type(action) == "table" then
    action_in = action.enter
    action_out = action.exit
  elseif type(action) == "function" then
    action_out = action
  end
  if action_in then
    local stop_traversal = action_in(node)
    if stop_traversal then
      return
    end
  end
  if node.c then
    for _,child in ipairs(node.c) do
      handle_node(child, filterpart)
    end
  end
  if node.footnotes then
    for _, note in pairs(node.footnotes) do
      handle_node(note, filterpart)
    end
  end
  if action_out then
    action_out(node)
  end
end

local function traverse(node, filterpart)
  handle_node(node, filterpart)
  return node
end

--- Apply a filter to a document.
--- @param node document (AST)
--- @param filter the filter to apply
local function apply_filter(node, filter)
  for _,filterpart in ipairs(filter) do
    traverse(node, filterpart)
  end
end

--- Returns a table containing the filter defined in `fp`.
--- `fp` will be sought using `require`, so it may occur anywhere
--- on the `LUA_PATH`, or in the working directory. On error,
--- returns nil and an error message.
--- @param fp path of file containing filter
--- @return the compiled filter, or nil and and error message
local function require_filter(fp)
  local oldpackagepath = package.path
  -- allow omitting or providing the .lua extension:
  local ok, filter = pcall(function()
                         package.path = "./?.lua;" .. package.path
                         local f = require(fp:gsub("%.lua$",""))
                         package.path = oldpackagepath
                         return f
                      end)
  if not ok then
    return nil, filter
  elseif type(filter) ~= "table" then
    return nil,  "filter must be a table"
  end
  if #filter == 0 then -- just a single filter part given
    return {filter}
  else
    return filter
  end
end

--- Load filter from a string, which should have the
--- form `return { ... }`.  On error, return nil and an
--- error message.
--- @param s string containing the filter
--- @return the compiled filter, or nil and and error message
local function load_filter(s)
  local fn, err
  if _VERSION:match("5.1") then
    fn, err = loadstring(s)
  else
    fn, err = load(s)
  end
  if fn then
    local filter = fn()
    if type(filter) ~= "table" then
      return nil,  "filter must be a table"
    end
    if #filter == 0 then -- just a single filter given
      return {filter}
    else
      return filter
    end
  else
    return nil, err
  end
end

--- @export
return {
  apply_filter = apply_filter,
  require_filter = require_filter,
  load_filter = load_filter
}

end

package.preload["djot.json"] = function()
-- Modified from
-- json.lua
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--
-- Modifications to the original code:
--
-- * Removed JSON decoding code

local json = { _version = "0.1.2" }

-- Encode

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end

local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end

return json

end

package.preload["djot"] = function()
--- @module djot
--- Parse and render djot light markup format. See https://djot.net.
---
--- @usage
--- local djot = require("djot")
--- local input = "This is *djot*"
--- local doc = djot.parse(input)
--- -- render as HTML:
--- print(djot.render_html(doc))
---
--- -- render as AST:
--- print(djot.render_ast_pretty(doc))
---
--- -- or in JSON:
--- print(djot.render_ast_json(doc))
---
--- -- alter the AST with a filter:
--- local src = "return { str = function(e) e.text = e.text:upper() end }"
--- -- subordinate modules like filter can be accessed as fields
--- -- and are lazily loaded.
--- local filter = djot.filter.load_filter(src)
--- djot.filter.apply_filter(doc, filter)
---
--- -- streaming parser:
--- for startpos, endpos, annotation in djot.parse_events("*hello there*") do
---   print(startpos, endpos, annotation)
--- end

local unpack = unpack or table.unpack
local Parser = require("djot.block").Parser
local ast = require("djot.ast")
local html = require("djot.html")
local json = require("djot.json")
local filter = require("djot.filter")

local StringHandle = {}

function StringHandle:new()
  local buffer = {}
  setmetatable(buffer, StringHandle)
  StringHandle.__index = StringHandle
  return buffer
end

function StringHandle:write(s)
  self[#self + 1] = s
end

function StringHandle:flush()
  return table.concat(self)
end

--- Parse a djot text and construct an abstract syntax tree (AST)
--- representing the document.
--- @param input input string
--- @param sourcepos if true, source positions are included in the AST
--- @param warn function that processes a warning, accepting a warning
--- object with `pos` and `message` fields.
--- @return AST
local function parse(input, sourcepos, warn)
  local parser = Parser:new(input, warn)
  return ast.to_ast(parser, sourcepos)
end

--- Parses a djot text and returns an iterator over events, consisting
--- of a start position (bytes), and an position (bytes), and an
--- annotation.
--- @param input input string
--- @param warn function that processes a warning, accepting a warning
--- object with `pos` and `message` fields.
--- @return an iterator over events.
---
---     for startpos, endpos, annotation in djot.parse_events("hello *world") do
---     ...
---     end
local function parse_events(input, warn)
  return Parser:new(input):events()
end

--- Render a document's AST in human-readable form.
--- @param doc the AST
--- @return rendered AST (string)
local function render_ast_pretty(doc)
  local handle = StringHandle:new()
  ast.render(doc, handle)
  return handle:flush()
end

--- Render a document's AST in JSON.
--- @param doc the AST
--- @return rendered AST (JSON string)
local function render_ast_json(doc)
  return json.encode(doc) .. "\n"
end

--- Render a document as HTML.
--- @param doc the AST
--- @return rendered document (HTML string)
local function render_html(doc)
  local handle = StringHandle:new()
  local renderer = html.Renderer:new()
  renderer:render(doc, handle)
  return handle:flush()
end

--- Render an event as a JSON array.
--- @param startpos starting byte position
--- @param endpos ending byte position
--- @param annotation annotation of event
--- @return rendered event (JSON string)
local function render_event(startpos, endpos, annotation)
  return string.format("[%q,%d,%d]", annotation, startpos, endpos)
end

--- Parse a document and render as a JSON array of events.
--- @param input the djot document (string)
--- @param warn function that emits warnings, taking as argumnet
--- an object with fields 'message' and 'pos'
--- @return rendered events (JSON string)
local function parse_and_render_events(input, warn)
  local handle = StringHandle:new()
  local idx = 0
  for startpos, endpos, annotation in parse_events(input, warn) do
    idx = idx + 1
    if idx == 1 then
      handle:write("[")
    else
      handle:write(",")
    end
    handle:write(render_event(startpos, endpos, annotation) .. "\n")
  end
  handle:write("]\n")
  return handle:flush()
end

--- djot version (string)
local version = "0.2.0"

--- @export
local G = {
  parse = parse,
  parse_events = parse_events,
  parse_and_render_events = parse_and_render_events,
  render_html = render_html,
  render_ast_pretty = render_ast_pretty,
  render_ast_json = render_ast_json,
  render_event = render_event,
  version = version
}

-- Lazily load submodules, e.g. djot.filter
setmetatable(G,{ __index = function(t,name)
                             local mod = require("djot." .. name)
                             rawset(t,name,mod)
                             return t[name]
                            end })

return G

end

local djot = require("djot")

local help = [[
djot [opts] [file*]

Options:
--matches        -m          Show matches.
--ast            -a          Show AST.
--json           -j          Use JSON for -m or -a.
--sourcepos      -p          Include source positions in AST.
--filter FILE    -f FILE     Filter AST using filter in FILE.
--verbose        -v          Verbose (show warnings).
--version                    Show version information.
--help           -h          Help.
]]

local function err(msg, code)
  io.stderr:write(msg .. "\n")
  os.exit(code)
end

local opts = {}
local files = {}

local shortcuts =
  { m = "--matches",
    a = "--ast",
    j = "--json",
    p = "--sourcepos",
    v = "--verbose",
    f = "--filter",
    h = "--help" }

local argi = 1
while arg[argi] do
  local thisarg = arg[argi]
  local longopts = {}
  if string.find(thisarg, "^%-%-%a") then
    longopts[#longopts + 1] = thisarg
  elseif string.find(thisarg, "^%-%a") then
    string.gsub(thisarg, "(%a)",
      function(x)
        longopts[#longopts + 1] = shortcuts[x] or ("-"..x)
      end)
  else
    files[#files + 1] = thisarg
  end
  for _,x in ipairs(longopts) do
    if x == "--matches" then
      opts.matches = true
    elseif x == "--ast" then
      opts.ast = true
    elseif x == "--json" then
      opts.json = true
    elseif x == "--sourcepos" then
      opts.sourcepos = true
    elseif x == "--verbose" then
      opts.verbose = true
    elseif x == "--filter" then
      if arg[argi + 1] then
        opts.filters = opts.filters or {}
        table.insert(opts.filters, arg[argi + 1])
        argi = argi + 1
      end
    elseif x == "--version" then
      io.stdout:write("djot " .. djot.version .. "\n")
      os.exit(0)
    elseif x == "--help" then
      io.stdout:write(help)
      os.exit(0)
    else
      err("Unknown option " .. x, 1)
    end
  end
  argi = argi + 1
end

local inp
if #files == 0 then
  inp = io.read("*all")
else
  local buff = {}
  for _,f in ipairs(files) do
    local ok, msg = pcall(function() io.input(f) end)
    if ok then
      table.insert(buff, io.read("*all"))
    else
      err(msg, 7)
    end
  end
  inp = table.concat(buff, "\n")
end

local warn = function(warning)
  if opts.verbose then
    io.stderr:write(string.format("%s at byte position %d\n",
      warning.message, warning.pos))
  end
end

if opts.matches then

  io.stdout:write(djot.parse_and_render_events(inp, warn))

else

  local ast = djot.parse(inp, opts.sourcepos, warn)

  if opts.filters then
    for _,fp in ipairs(opts.filters) do
      local filt, err = djot.filter.require_filter(fp)
      if filt then
         djot.filter.apply_filter(ast, filt)
      else
        io.stderr:write("Error loading filter " .. fp .. ":\n" .. err .. "\n")
      end
    end
  end

  if opts.ast then
    if opts.json then
      io.stdout:write(djot.render_ast_json(ast))
    else
      io.stdout:write(djot.render_ast_pretty(ast))
    end
  else
    io.stdout:write(djot.render_html(ast))
  end

end

os.exit(0)
