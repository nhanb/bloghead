-- Autogenerated with "go run ./cmd/vendordjot". Do not edit.
-- https://github.com/jgm/djot/blob/main/LICENSE
-- Copyright (C) 2022 John MacFarlane
--
-- Permission is hereby granted, free of charge, to any person obtaining
-- a copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to
-- permit persons to whom the Software is furnished to do so, subject to
-- the following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-- IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-- CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-- TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-- SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
package.preload["djot"] = function()
local block = require("djot.block")
local ast = require("djot.ast")
local html = require("djot.html")
local match = require("djot.match")
local json = require("djot.json")

local unpack_match = match.unpack_match
local format_match = match.format_match

local StringHandle = {}

function StringHandle:new()
  local buffer = {}
  setmetatable(buffer, StringHandle)
  StringHandle.__index = StringHandle
  return buffer
end

function StringHandle:write(s)
  self[#self + 1] = s
end

function StringHandle:flush()
  local result = table.concat(self)
  return result
end

local Parser = block.Parser

function Parser:render_matches(handle, use_json)
  if not handle then
    handle = StringHandle:new()
  end
  local matches = self:get_matches()
  if use_json then
    local formatted_matches = {}
    for i=1,#matches do
      local startpos, endpos, annotation = unpack_match(matches[i])
      formatted_matches[#formatted_matches + 1] =
        { annotation, {startpos, endpos} }
    end
    handle:write(json.encode(formatted_matches) .. "\n")
  else
    for i=1,#matches do
      handle:write(format_match(matches[i]))
    end
  end
  return handle:flush()
end

function Parser:build_ast()
  self.ast = ast.to_ast(self.subject, self.matches, self.opts, self.warn)
end

function Parser:render_ast(handle, use_json)
  if not handle then
    handle = StringHandle:new()
  end
  if not self.ast then
    self:build_ast()
  end
  if use_json then
    handle:write(json.encode(self.ast) .. "\n")
  else
    ast.render(self.ast, handle)
  end
  return handle:flush()
end

function Parser:render_html(handle)
  if not handle then
    handle = StringHandle:new()
  end
  if not self.ast then
    self:build_ast()
  end
  local renderer = html.Renderer:new()
  renderer:render(self.ast, handle)
  return handle:flush()
end

return {
  Parser = Parser
}

end

package.preload["djot.ast"] = function()
local match = require("djot.match")
local emoji -- require this later, only if emoji encountered

local find, lower, sub, gsub, rep, format =
  string.find, string.lower, string.sub, string.gsub, string.rep, string.format

local unpack_match, get_length, matches_pattern =
  match.unpack_match, match.get_length, match.matches_pattern

local function get_string_content(node)
  local buffer = {}
  if node.s then
    buffer[#buffer + 1] = node.s
  elseif node.t == "softbreak" then
    buffer[#buffer + 1] = "\n"
  elseif node.c then
    for i=1, #node.c do
      buffer[#buffer + 1] = get_string_content(node.c[i])
    end
  end
  return table.concat(buffer)
end

local roman_digits = {
  i = 1,
  v = 5,
  x = 10,
  l = 50,
  c = 100,
  d = 500,
  m = 1000 }

local function roman_to_number(s)
  -- go backwards through the digits
  local total = 0
  local prevdigit = 0
  local i=#s
  while i > 0 do
    local c = lower(sub(s,i,i))
    local n = roman_digits[c]
    if n < prevdigit then -- e.g. ix
      total = total - n
    else
      total = total + n
    end
    assert(n ~= nil, "Encountered bad character in roman numeral " .. s)
    prevdigit = n
    i = i - 1
  end
  return total
end

local function get_list_start(marker, style)
  local numtype = string.gsub(style, "%p", "")
  local s = string.gsub(marker, "%p", "")
  if numtype == "1" then
    return tonumber(s)
  elseif numtype == "A" then
    return (string.byte(s) - string.byte("A") + 1)
  elseif numtype == "a" then
    return (string.byte(s) - string.byte("a") + 1)
  elseif numtype == "I" then
    return roman_to_number(s)
  elseif numtype == "i" then
    return roman_to_number(s)
  elseif numtype == "" then
    return nil
  end
end

local ignorable = {
  image_marker = true,
  escape = true,
  blankline = true,
  checkbox_checked = true,
  checkbox_unchecked = true
}

local function is_tight(matches, startidx, endidx, is_last_item)
  -- see if there are any blank lines between blocks in a list item.
  local blanklines = 0
  -- we don't care about blank lines at very end of list
  for i=startidx, endidx do
    local _, _, x = unpack_match(matches[i])
    if x == "blankline" then
      if not ((matches_pattern(matches[i+1], "%+list_item") or
              (matches_pattern(matches[i+1], "%-list_item") and
               (is_last_item or
                 matches_pattern(matches[i+2], "%-list_item"))))) then
        -- don't count blank lines before list starts
        -- don't count blank lines at end of nested lists or end of last item
        blanklines = blanklines + 1
      end
    end
  end
  return (blanklines == 0)
end

local function insert_attribute(attr, key, val)
  if not attr._keys then
    attr._keys = {}
  end
  local function add_key(k)
    local keys = attr._keys
    for i=1,#keys do
      if keys[i] == k then
        return
      end
    end
    keys[#keys + 1] = k
  end
  -- _keys records order of key insertion for deterministic output
  if key == "id" then
    attr.id = val
    add_key("id")
  elseif key == "class" then
    if attr.class then
      attr.class =
        attr.class .. " " .. val
    else
      attr.class = val
      add_key("class")
    end
  else
    attr[key] = val
    add_key(key)
  end
end

local function copy_attributes(target, source)
  if source then
    for k,v in pairs(source) do
      if k ~= "_keys" then
        insert_attribute(target, k, v)
      end
    end
  end
end

local function insert_attributes(targetnode, cs)
  targetnode.attr = targetnode.attr or {_keys = {}}
  local i=1
  while i <= #cs do
    local x, y = cs[i].t, cs[i].s
    if x == "id" or x == "class" then
      insert_attribute(targetnode.attr, x, y)
    elseif x == "key" then
      local valnode = cs[i + 1]
      if valnode.t == "value" then
        -- resolve backslash escapes
        insert_attribute(targetnode.attr, y, valnode.s:gsub("\\(%p)", "%1"))
      end
      i = i + 1
    end
    i = i + 1
  end
end

local function make_definition_list_item(result)
  result.t = "definition_list_item"
  if result.c and #result.c > 0 and
     result.c[1].t == "para" then
    result.c[1].t = "term"
  else
    table.insert(result.c, 1, {t = "term", c = {}})
  end
  if result.c[2] then
    local defn = {t = "definition", c = {}}
    for i=2,#result.c do
      defn.c[#defn.c + 1] = result.c[i]
      result.c[i] = nil
    end
    result.c[2] = defn
  end
end

-- create an abstract syntax tree based on an event
-- stream and references
local function to_ast(subject, matches, options, warn)
  if not options then
    options = {}
  end
  if not warn then
    warn = function() end
  end
  local idx = 1
  local matcheslen = #matches
  local sourcepos = options.sourcepos
  local references = {}
  local footnotes = {}
  local identifiers = {} -- identifiers used (to ensure uniqueness)

  -- generate auto identifier for heading
  local function get_identifier(s)
    local base = s:gsub("[][~!@#$%^&*(){}`,.<>\\|=+/?]","")
                  :gsub("^%s+",""):gsub("%s+$","")
                  :gsub("%s+","-")
    local i = 0
    local ident = base
    -- generate unique id
    while identifiers[ident] do
      i = i + 1
      ident = base .. tostring(i)
    end
    identifiers[ident] = true
    return ident
  end

  local function set_checkbox(node, startidx)
    -- determine if checked or unchecked
    local _,_,ann = unpack_match(matches[startidx + 1])
    if ann == "checkbox_checked" then
      node.checkbox = "checked"
    elseif ann == "checkbox_unchecked" then
      node.checkbox = "unchecked"
    end
  end

  local function get_node(maintag)
    local node = { t = maintag, c = {} }
    local stopper
    local block_attributes = nil
    if maintag then
      -- strip off data (e.g. for list_items)
      stopper = "^%-" .. gsub(maintag, "%[.*$", "")
    end
    while idx <= matcheslen do
      local matched = matches[idx]
      local startpos, endpos, annot = unpack_match(matched)
      if stopper and find(annot, stopper) then
        idx = idx + 1
        return node
      else
        local mod, tag = string.match(annot, "^([-+]?)(.*)")
        if ignorable[tag] then
          idx = idx + 1 -- skip
        elseif mod == "+" then -- open
          local startidx = idx
          idx = idx + 1
          local result = get_node(tag)
          if tag == "list_item[X]" then
            set_checkbox(result, startidx)
          end
          local _, finalpos = unpack_match(matches[idx - 1])
          if sourcepos then
            result.pos = {startpos, finalpos}
          end
          if block_attributes and tag ~= "block_attributes" then
            for i=1,#block_attributes do
              insert_attributes(result, block_attributes[i])
            end
            if result.attr and result.attr.id then
              identifiers[result.attr.id] = true
            end
            block_attributes = nil
            -- TODO where do we ever set this to true??
          end
          if tag == "verbatim" then
            local s = get_string_content(result)
            -- trim space next to ` at beginning or end
            if find(s, "^ +`") then
              s = s:sub(2)
            end
            if find(s, "` +$") then
              s = s:sub(1, #s - 1)
            end
            result = {t = "verbatim", s = s}
            -- check for raw_format, which makes this a raw node
            local sp,ep,ann = unpack_match(matches[idx])
            if ann == "raw_format" then
              local str = get_string_content(result)
              result.t = "raw_inline"
              result.s = str
              result.format = sub(subject, sp + 2, ep - 1)
              idx = idx + 1 -- skip the raw_format
            end
          elseif tag == "caption" then
            local prevnode = node.c[#node.c]
            if prevnode.t == "table" then
              -- move caption in table node
              table.insert(prevnode.c, 1, result)
              result = nil
            end
          elseif tag == "reference_definition" then
            local dest = ""
            local key
            for i=1,#result.c do
              if result.c[i].t == "reference_key" then
                key = result.c[i].s
              end
              if result.c[i].t == "reference_value" then
                dest = dest .. result.c[i].s
              end
            end
            references[key] = { destination = dest }
             if result.attr then
               references[key].attributes = result.attr
             end
          elseif tag == "footnote" then
            local label
            if result.c[1].t == "note_label" then
              label = result.c[1].s
              table.remove(result.c, 1)
            end
            if label then
              footnotes[label] = result
            end
            result = nil
          elseif tag == "inline_math" then
            result.t = "math"
            result.attr = {class = "math inline", _keys={"class"}}
          elseif tag == "display_math" then
            result.t = "math"
            result.attr = {class = "math display", _keys={"class"}}
          elseif tag == "url" then
            result.t = "url"
            result.destination = get_string_content(result)
          elseif tag == "email" then
            result.t = "email"
            result.destination = "mailto:" .. get_string_content(result)
          elseif tag == "imagetext" or tag == "linktext" then
            -- gobble destination or reference
            local nextmatch = matches[idx]
            local _, _, nextannot = unpack_match(nextmatch)
            if nextannot == "+destination" then
              idx = idx + 1
              local dest = get_node("destination")
              result.destination = get_string_content(dest):gsub("\r?\n", "")
            elseif nextannot == "+reference" then
              idx = idx + 1
              local ref = get_node("reference")
              if ref.t == "reference" and #ref.c > 0 then
                result.reference = get_string_content(ref):gsub("\r?\n", " ")
              else
                result.reference = get_string_content(result):gsub("\r?\n", " ")
              end
            end
            result.t = result.t:gsub("text","")
          elseif tag == "heading" then
            result.level = get_length(matched)
            local heading_str = get_string_content(result)
                                 :gsub("^%s+",""):gsub("%s+$","")
            if not (result.attr and result.attr.id) then
              local ident = get_identifier(heading_str)
              insert_attributes(result, {{t = "id", s = ident}})
            end
            -- insert into references unless there's a same-named one already:
            if not references[heading_str] then
              references[heading_str] = {destination = "#" .. result.attr.id}
            end
          elseif tag == "table" then
            -- look for a separator line
            -- if found, make the preceding rows headings
            -- and set attributes for column alignments on the table
            local i=1
            local aligns = {}
            while i <= #result.c do
              local found, align
              if result.c[i].t == "row" then
                local row = result.c[i].c
                for j=1,#row do
                  found, _, align = find(row[j].t, "^separator_(.*)")
                  if not found then
                    break
                  end
                  aligns[j] = align
                end
                if found and #aligns > 0 then
                  -- set previous row to head and adjust aligns
                  local prevrow = result.c[i - 1]
                  if prevrow and prevrow.t == "row" then
                    prevrow.head = true
                    for k=1,#prevrow.c do
                      -- set head on cells too
                      prevrow.c[k].head = true
                      if aligns[k] ~= "default" then
                        prevrow.c[k].align = aligns[k]
                      end
                    end
                  end
                  table.remove(result.c, i) -- remove sep line
                  -- we don't need to increment i because we removed ith elt
                else
                  if #aligns > 0 then
                    for l=1,#result.c[i].c do
                      if aligns[l] ~= "default" then
                        result.c[i].c[l].align = aligns[l]
                      end
                    end
                  end
                  i = i + 1
                end
              end
            end
            result.level = get_length(matched)
          elseif tag == "div" then
            if result.c[1] and result.c[1].t == "class" then
              result.attr = result.attr or {_keys = {}}
              insert_attribute(result.attr, "class", get_string_content(result.c[1]))
              table.remove(result.c, 1)
            end
          elseif tag == "code_block" then
            if result.c[1] then
              if result.c[1].t == "code_language" then
                result.lang = result.c[1].s
                table.remove(result.c, 1)
              elseif result.c[1].t == "raw_format" then
                local fmt = result.c[1].s:sub(2)
                table.remove(result.c, 1)
                result.t = "raw_block"
                result.format = fmt
              end
              result.s = get_string_content(result)
              result.c = nil
            end
          elseif tag == "block_attributes" then
            if block_attributes then
              block_attributes[#block_attributes + 1] = result.c
            else
              block_attributes = {result.c}
            end
            result = nil
          elseif tag == "attributes" then
            -- parse attributes, add to last node
            local prevnode = node.c[#node.c]
            local endswithspace = false
            if type(prevnode) == "table" then
              if prevnode.t == "str" then
                -- split off last consecutive word of string
                -- to which to attach attributes
                local lastwordpos = string.find(prevnode.s, "[^%s]+$")
                if not lastwordpos then
                  endswithspace = true
                elseif lastwordpos > 1 then
                  local newnode = {t = "str",
                                   s = sub(prevnode.s, lastwordpos, -1)}
                  prevnode.s = sub(prevnode.s, 1, lastwordpos - 1)
                  node.c[#node.c + 1] = newnode
                  prevnode = newnode
                end
              end
              if not endswithspace then
                insert_attributes(prevnode, result.c)
              else
                warn({message = "Ignoring unattached attribute", pos = startpos})
              end
            end
            result = nil
          elseif find(tag, "^list_item") then
            local marker = string.match(subject, "^%S+", startpos)
            local styles = {}
            gsub(tag, "%[([^]]*)%]", function(x) styles[#styles + 1] = x end)
            -- create a list node with the consecutive list items
            -- of the same kind
            local list = {t = "list", c = {result}}
            -- put the attributes from the first item on the list itself:
            list.attr = result.attr
            result.attr = nil
            result.t = "list_item"
            if marker == ":" then
              make_definition_list_item(result)
            end
            if sourcepos then
              list.pos = {result.pos[1], result.pos[2]}
            end
            -- now get remaining items
            local nextitem = matches[idx]
            while nextitem do
              local sp, _, ann = unpack_match(nextitem)
              if not find(ann, "^%+list_item") then
                break
              end
              -- check which of the styles this item matches
              local newstyles = {}
              gsub(ann, "%[([^]]*)%]",
                          function(x) newstyles[x] = true end)
              local matched_styles = {}
              for _,x in ipairs(styles) do
                if newstyles[x] then
                  matched_styles[#matched_styles + 1] = x
                end
              end
              if #styles > 0 and #matched_styles == 0 then
                break  -- does not match any styles
              end
              styles = matched_styles
              -- at this point styles contains the styles that match all items
              -- in the list so far...

              if #list.c > 0 then
                list.c[#list.c].tight =
                  is_tight(matches, startidx, idx - 1, false)
              end
              startidx = idx
              idx = idx + 1
              local item = get_node(tag)
              if tag == "list_item[X]" then
                set_checkbox(item, startidx)
              end
              item.t = "list_item"
              if sourcepos then
                item.pos = {sp, finalpos}
                list.pos[2] = item.pos[2]
              end
              if marker == ":" then
                make_definition_list_item(item)
              end
              list.c[#list.c + 1] = item
              nextitem = matches[idx]
            end
            if #list.c > 0 then
              list.c[#list.c].tight =
                is_tight(matches, startidx, idx - 1, true)
            end
            local tight = true
            for i=1,#list.c do
              tight = tight and list.c[i].tight
              list.c[i].tight = nil
            end
            list.list_style = styles[1] -- resolve, if still ambiguous
            list.tight = tight
            list.start = get_list_start(marker, list.list_style)
            result = list
          end
          node.c[#node.c + 1] = result
        elseif mod == "-" then -- close
          assert(false, "unmatched " .. annot .. " encountered at byte " ..
                   startpos)
          idx = idx + 1
          return nil
        elseif tag == "reference_key" then
          local key = sub(subject, startpos + 1, endpos - 1)
          local result = {t = "reference_key", s = key}
          idx = idx + 1
          node.c[#node.c + 1] = result
        elseif tag == "reference_value" then
          local val = sub(subject, startpos, endpos)
          local result = {t = "reference_value", s = val}
          idx = idx + 1
          node.c[#node.c + 1] = result
        else -- leaf
          local result
          if tag == "softbreak" then
            result = {t = tag}
          elseif tag == "footnote_reference" then
            result = {t = tag, s = sub(subject, startpos + 2, endpos - 1)}
          elseif tag == "emoji" then
            result = {t = "emoji",
                      alias = sub(subject, startpos + 1, endpos - 1)}
            emoji = require("djot.emoji")
            local found = emoji[result.alias]
            result.s = found
          else
            result = {t = tag, s = sub(subject, startpos, endpos)}
          end
          if sourcepos then
            result.pos = {startpos, endpos}
          end
          if block_attributes then
            for i=1,#block_attributes do
              insert_attributes(result, block_attributes[i])
            end
            block_attributes = nil
          end
          idx = idx + 1
          if result then
            node.c[#node.c + 1] = result
          end
        end
      end
    end
    return node
  end

  local doc = get_node("doc")
  doc.references = references
  doc.footnotes = footnotes
  return doc
end

local function render_node(node, handle, indent)
  indent = indent or 0
  handle:write(rep(" ", indent))
  if node.t then
    handle:write(node.t)
    if node.pos then
      handle:write(format(" (%d-%d)", node.pos[1], node.pos[2]))
    end
    for k,v in pairs(node) do
      if type(k) == "string" and k ~= "c" and
          k ~= "t" and k ~= "pos" and k ~= "attr"  and
          k ~= "references" and k ~= "footnotes" then
        handle:write(format(" %s=%q", k, tostring(v)))
      end
    end
    if node.attr then
      local keys = node.attr._keys
      for j=1,#keys do
        local k = keys[j]
        handle:write(format(" %s=%q", k, node.attr[k]))
      end
    end
  else
    io.stderr:write("Encountered node without tag:\n" ..
                      require'inspect'(node))
    os.exit(1)
  end
  handle:write("\n")
  if node.c then
    for _,v in ipairs(node.c) do
      render_node(v, handle, indent + 2)
    end
  end
end

local function render(doc, handle)
  render_node(doc, handle, 0)
  if doc.references then
    handle:write("references = {\n")
    for k,v in pairs(doc.references) do
      handle:write(format("  [%q] = %q,\n", k, v.destination))
    end
    handle:write("}\n")
  end
  if doc.footnotes then
    handle:write("footnotes = {\n")
    for k,v in pairs(doc.footnotes) do
      handle:write(format("  [%q] =\n", k))
      render_node(v, handle, 4)
    end
    handle:write("}\n")
  end
end

return { to_ast = to_ast,
         render = render,
         insert_attribute = insert_attribute,
         copy_attributes = copy_attributes }

end

package.preload["djot.attributes"] = function()
local find, sub = string.find, string.sub
local match = require("djot.match")
local make_match = match.make_match

-- parser for attributes
-- attributes { id = "foo", class = "bar baz",
--              key1 = "val1", key2 = "val2" }
-- syntax:
--
-- attributes <- '{' whitespace* attribute (whitespace attribute)* whitespace* '}'
-- attribute <- identifier | class | keyval
-- identifier <- '#' name
-- class <- '.' name
-- name <- (nonspace, nonpunctuation other than ':', '_', '-')+
-- keyval <- key '=' val
-- key <- (ASCII_ALPHANUM | ':' | '_' | '-')+
-- val <- bareval | quotedval
-- bareval <- (ASCII_ALPHANUM | ':' | '_' | '-')+
-- quotedval <- '"' ([^"] | '\"') '"'

-- states:
local SCANNING = 0
local SCANNING_ID = 1
local SCANNING_CLASS= 2
local SCANNING_KEY = 3
local SCANNING_VALUE = 4
local SCANNING_BARE_VALUE = 5
local SCANNING_QUOTED_VALUE = 6
local SCANNING_ESCAPED = 7
local SCANNING_COMMENT = 8
local FAIL = 9
local DONE = 10
local START = 11

local AttributeParser = {}

local handlers = {}

handlers[START] = function(self, pos)
  if find(self.subject, "^{", pos) then
    return SCANNING
  else
    return FAIL
  end
end

handlers[FAIL] = function(_self, _pos)
  return FAIL
end

handlers[DONE] = function(_self, _pos)
  return DONE
end

handlers[SCANNING] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == ' ' or c == '\t' or c == '\n' or c == '\r' then
    return SCANNING
  elseif c == '}' then
    return DONE
  elseif c == '#' then
    self.begin = pos
    return SCANNING_ID
  elseif c == '%' then
    self.begin = pos
    return SCANNING_COMMENT
  elseif c == '.' then
    self.begin = pos
    return SCANNING_CLASS
  elseif find(c, "^[%a%d_:-]") then
    self.begin = pos
    return SCANNING_KEY
  else -- TODO
    return FAIL
  end
end

handlers[SCANNING_COMMENT] = function(self, pos)
  if sub(self.subject, pos, pos) == "%" then
    return SCANNING
  else
    return SCANNING_COMMENT
  end
end

handlers[SCANNING_ID] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if find(c, "^[^%s%p]") or c == "_" or c == "-" or c == ":" then
    return SCANNING_ID
  elseif c == '}' then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "id")
    end
    self.begin = nil
    return DONE
  elseif find(c, "^%s") then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "id")
    end
    self.begin = nil
    return SCANNING
  else
    return FAIL
  end
end

handlers[SCANNING_CLASS] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if find(c, "^[^%s%p]") or c == "_" or c == "-" or c == ":" then
    return SCANNING_CLASS
  elseif c == '}' then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "class")
    end
    self.begin = nil
    return DONE
  elseif find(c, "^%s") then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "class")
    end
    self.begin = nil
    return SCANNING
  else
    return FAIL
  end
end

handlers[SCANNING_KEY] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == "=" then
    self:add_match(self.begin, self.lastpos, "key")
    self.begin = nil
    return SCANNING_VALUE
  elseif find(c, "^[%a%d_:-]") then
    return SCANNING_KEY
  else
    return FAIL
  end
end

handlers[SCANNING_VALUE] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == '"' then
    self.begin = pos
    return SCANNING_QUOTED_VALUE
  elseif find(c, "^[%a%d_:-]") then
    self.begin = pos
    return SCANNING_BARE_VALUE
  else
    return FAIL
  end
end

handlers[SCANNING_BARE_VALUE] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if find(c, "^[%a%d_:-]") then
    return SCANNING_BARE_VALUE
  elseif c == '}' then
    self:add_match(self.begin, self.lastpos, "value")
    self.begin = nil
    return DONE
  elseif find(c, "^%s") then
    self:add_match(self.begin, self.lastpos, "value")
    self.begin = nil
    return SCANNING
  else
    return FAIL
  end
end

handlers[SCANNING_ESCAPED] = function(_self, _pos)
  return SCANNING_QUOTED_VALUE
end

handlers[SCANNING_QUOTED_VALUE] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == '"' then
    self:add_match(self.begin + 1, self.lastpos, "value")
    self.begin = nil
    return SCANNING
  elseif c == "\\" then
    return SCANNING_ESCAPED
  elseif c == "{" or c == "}" then
    return FAIL
  elseif c == "\n" then
    self:add_match(self.begin + 1, self.lastpos, "value")
    return SCANNING_QUOTED_VALUE
  else
    return SCANNING_QUOTED_VALUE
  end
end

function AttributeParser:new(subject)
  local state = {
    subject = subject,
    state = START,
    begin = nil,
    failed = nil,
    lastpos = nil,
    matches = {}
    }
  setmetatable(state, self)
  self.__index = self
  return state
end

function AttributeParser:add_match(sp, ep, tag)
  self.matches[#self.matches + 1] = make_match(sp, ep, tag)
end

function AttributeParser:get_matches()
  return self.matches
end

-- Feed parser a slice of text from the subject, between
-- startpos and endpos inclusive.  Return status, position,
-- where status is either "done" (position should point to
-- final '}'), "fail" (position should point to first character
-- that could not be parsed), or "continue" (position should
-- point to last character parsed).
function AttributeParser:feed(startpos, endpos)
  local pos = startpos
  while pos <= endpos do
    self.state = handlers[self.state](self, pos)
    if self.state == DONE then
      return "done", pos
    elseif self.state == FAIL then
      self.lastpos = pos
      return "fail", pos
    else
      self.lastpos = pos
      pos = pos + 1
    end
  end
  return "continue", endpos
end

--[[
local test = function()
  local parser = AttributeParser:new("{a=b #ident\n.class\nkey=val1\n .class key2=\"val two \\\" ok\" x")
  local x,y,z = parser:feed(1,56)
  print(require'inspect'(parser:get_matches{}))
end

test()
--]]

return { AttributeParser = AttributeParser }

end

package.preload["djot.block"] = function()
local inline = require("djot.inline")
local attributes = require("djot.attributes")
local match = require("djot.match")
local make_match, unpack_match = match.make_match, match.unpack_match
local unpack = unpack or table.unpack
local find, sub, byte = string.find, string.sub, string.byte

local Container = {}

function Container:new(spec, data)
  self = spec
  local contents = {}
  setmetatable(contents, self)
  self.__index = self
  if data then
    for k,v in pairs(data) do
      contents[k] = v
    end
  end
  return contents
end

local function get_list_style(marker)
  if marker == "+" or marker == "-" or marker == "*" or marker == ":" then
    return marker
  elseif find(marker, "^[+*-] %[[Xx ]%]") then
    return "X" -- task list
  elseif find(marker, "^%[[Xx ]%]") then
    return "X"
  elseif find(marker, "^[(]?%d+[).]") then
    return (marker:gsub("%d+","1"))
  -- in ambiguous cases we return two values
  elseif find(marker, "^[(]?[ivxlcdm][).]") then
    return (marker:gsub("%a+", "a")), (marker:gsub("%a+", "i"))
  elseif find(marker, "^[(]?[IVXLCDM][).]") then
    return (marker:gsub("%a+", "A")), (marker:gsub("%a+", "I"))
  elseif find(marker, "^[(]?%l[).]") then
    return (marker:gsub("%l", "a"))
  elseif find(marker, "^[(]?%u[).]") then
    return (marker:gsub("%u", "A"))
  elseif find(marker, "^[(]?[ivxlcdm]+[).]") then
    return (marker:gsub("%a+", "i"))
  elseif find(marker, "^[(]?[IVXLCDM]+[).]") then
    return (marker:gsub("%a+", "I"))
  else
    assert(false, "Could not identify list style for " .. marker)
  end
end

local Parser = {}

function Parser:new(subject, opts, warn)
  -- ensure the subject ends with a newline character
  if not subject:find("[\r\n]$") then
    subject = subject .. "\n"
  end
  local state = {
    warn = warn or function() end,
    subject = subject,
    indent = 0,
    startline = nil,
    starteol = nil,
    endeol = nil,
    matches = {},
    containers = {},
    pos = 1,
    last_matched_container = 0,
    timer = {},
    opts = opts or {},
    finished_line = false }
  setmetatable(state, self)
  self.__index = self
  return state
end

-- parameters are start and end position
function Parser:parse_table_row(sp, ep)
  local orig_matches = #self.matches  -- so we can rewind
  local startpos = self.pos
  self:add_match(sp, sp, "+row")
  -- skip | and any initial space in the cell:
  self.pos = find(self.subject, "%S", sp + 1)
  -- check to see if we have a separator line
  local seps = {}
  local p = self.pos
  local sepfound = false
  while not sepfound do
    local sepsp, sepep, left, right, trailing =
      find(self.subject, "^(%:?)%-%-*(%:?)([ \t]*%|[ \t]*)", p)
    if sepep then
      local st = "separator_default"
      if #left > 0 and #right > 0 then
        st = "separator_center"
      elseif #right > 0 then
        st = "separator_right"
      elseif #left > 0 then
        st = "separator_left"
      end
      seps[#seps + 1] = {sepsp, sepep - #trailing, st}
      p = sepep + 1
      if p == self.starteol then
        sepfound = true
        break
      end
    else
      break
    end
  end
  if sepfound then
    for i=1,#seps do
      self:add_match(unpack(seps[i]))
    end
    self:add_match(self.starteol - 1, self.starteol - 1, "-row")
    self.pos = self.starteol
    self.finished_line = true
    return true
  end
  local inline_parser = inline.Parser:new(self.subject, self.opts, self.warn)
  self:add_match(sp, sp, "+cell")
  while self.pos <= ep do
    -- parse a chunk as inline content
    local _,nextbar = self:find("^[^|\r\n]*|")
    inline_parser:feed(self.pos, nextbar - 1)
    if inline_parser:in_verbatim() then
      -- read the next | as part of verbatim
      inline_parser:feed(nextbar, nextbar)
      self.pos = nextbar + 1
    else
      self.pos = nextbar + 1  -- skip past the next |
      -- add a table cell
      local cell_matches = inline_parser:get_matches()
      for i=1,#cell_matches do
        local s,e,ann = unpack_match(cell_matches[i])
        if i == #cell_matches and ann == "str" then
          -- strip trailing space
          while byte(self.subject, e) == 32 and e >= s do
            e = e - 1
          end
        end
        self:add_match(s,e,ann)
      end
      self:add_match(nextbar, nextbar, "-cell")
      if nextbar < ep then
        -- reset inline parser state
        inline_parser = inline.Parser:new(self.subject, self.opts, self.warn)
        self:add_match(nextbar, nextbar, "+cell")
        self.pos = find(self.subject, "%S", self.pos)
      end
    end
  end
  if inline_parser:in_verbatim() then
    -- rewind, this is not a valid table row
    self.pos = startpos
    for i = orig_matches,#self.matches do
      self.matches[i] = nil
    end
    return false
  else
    self:add_match(self.pos, self.pos, "-row")
    self.pos = self.starteol
    self.finished_line = true
    return true
  end
end

function Parser:specs()
  return {
    { name = "para",
      is_para = true,
      content = "inline",
      continue = function()
        return self:find("^%S")
      end,
      open = function(spec)
        self:add_container(Container:new(spec,
            { inline_parser =
                inline.Parser:new(self.subject, self.opts, self.warn) }))
        self:add_match(self.pos, self.pos, "+para")
        return true
      end,
      close = function()
        self:get_inline_matches()
        self:add_match(self.pos - 1, self.pos - 1, "-para")
        self.containers[#self.containers] = nil
      end
    },

    { name = "caption",
      is_para = false,
      content = "inline",
      continue = function()
        return self:find("^%S")
      end,
      open = function(spec)
        local _, ep = self:find("^%^[ \t]+")
        if ep then
          self.pos = ep + 1
          self:add_container(Container:new(spec,
            { inline_parser =
                inline.Parser:new(self.subject, self.opts, self.warn) }))
          self:add_match(self.pos, self.pos, "+caption")
          return true
        end
      end,
      close = function()
        self:get_inline_matches()
        self:add_match(self.pos - 1, self.pos - 1, "-caption")
        self.containers[#self.containers] = nil
      end
    },

    { name = "blockquote",
      content = "block",
      continue = function()
        if self:find("^%>%s") then
          self.pos = self.pos + 1
          return true
        else
          return false
        end
      end,
      open = function(spec)
        if self:find("^%>%s") then
          self:add_container(Container:new(spec))
          self:add_match(self.pos, self.pos, "+blockquote")
          self.pos = self.pos + 1
          return true
        end
      end,
      close = function()
        self:add_match(self.pos, self.pos, "-blockquote")
        self.containers[#self.containers] = nil
      end
    },

    -- should go before reference definitions
    { name = "footnote",
      content = "block",
      continue = function(container)
        if self.indent > container.indent or self:find("^[\r\n]") then
          return true
        else
          return false
        end
      end,
      open = function(spec)
        local sp, ep, label = self:find("^%[%^([^]]+)%]:%s")
        if not sp then
          return nil
        end
        -- adding container will close others
        self:add_container(Container:new(spec, {note_label = label,
                                                indent = self.indent}))
        self:add_match(sp, sp, "+footnote")
        self:add_match(sp + 2, ep - 3, "note_label")
        self.pos = ep
        return true
      end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-footnote")
        self.containers[#self.containers] = nil
      end
    },

    -- should go before list_item_spec
    { name = "thematic_break",
      content = nil,
      continue = function()
        return false
      end,
      open = function(spec)
        local sp, ep = self:find("^[-*][ \t]*[-*][ \t]*[-*][-* \t]*[\r\n]")
        if ep then
          self:add_container(Container:new(spec))
          self:add_match(sp, ep, "thematic_break")
          self.pos = ep
          return true
        end
      end,
      close = function(_container)
        self.containers[#self.containers] = nil
      end
    },

    { name = "list_item",
      content = "block",
      continue = function(container)
        if self.indent > container.indent or self:find("^[\r\n]") then
          return true
        else
          return false
        end
      end,
      open = function(spec)
        local sp, ep = self:find("^[-*+:]%s")
        if not sp then
          sp, ep = self:find("^%d+[.)]%s")
        end
        if not sp then
          sp, ep = self:find("^%(%d+%)%s")
        end
        if not sp then
          sp, ep = self:find("^[ivxlcdmIVXLCDM]+[.)]%s")
        end
        if not sp then
          sp, ep = self:find("^%([ivxlcdmIVXLCDM]+%)%s")
        end
        if not sp then
          sp, ep = self:find("^%a[.)]%s")
        end
        if not sp then
          sp, ep = self:find("^%(%a%)%s")
        end
        if not sp then
          return nil
        end
        local marker = sub(self.subject, sp, ep - 1)
        local checkbox = nil
        if self:find("^[*+-] %[[Xx ]%]%s", sp + 1) then -- task list
          marker = sub(self.subject, sp, sp + 4)
          checkbox = sub(self.subject, sp + 3, sp + 3)
        end
        -- some items have ambiguous style
        local styles = {get_list_style(marker)}
        local data = { styles = styles,
                       indent = self.indent }
        -- adding container will close others
        self:add_container(Container:new(spec, data))
        local annot = "+list_item"
        for i=1,#styles do
          annot = annot .. "[" .. styles[i] .. "]"
        end
        self:add_match(sp, ep - 1, annot)
        self.pos = ep
        if checkbox then
          if checkbox == " " then
            self:add_match(sp + 2, sp + 4, "checkbox_unchecked")
          else
            self:add_match(sp + 2, sp + 4, "checkbox_checked")
          end
          self.pos = sp + 5
        end
        return true
      end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-list_item")
        self.containers[#self.containers] = nil
      end
    },

    { name = "reference_definition",
      content = nil,
      continue = function(container)
        if container.indent >= self.indent then
          return false
        end
        local _, ep, rest = self:find("^(%S+)")
        if ep then
          self:add_match(ep - #rest + 1, ep, "reference_value")
          container.value = rest
          self.pos = ep + 1
        end
        return true
      end,
      open = function(spec)
        local sp, ep, label, rest = self:find("^%[([^]\r\n]*)%]:[ \t]*(%S*)")
        if sp then
          self:add_container(Container:new(spec,
             { key = label,
               value = rest,
               indent = self.indent }))
          self:add_match(sp, sp, "+reference_definition")
          self:add_match(sp, sp + #label + 1, "reference_key")
          if #rest > 0 then
            self:add_match(ep - #rest + 1, ep, "reference_value")
          end
          self.pos = ep + 1
          return true
        end
      end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-reference_definition")
        self.containers[#self.containers] = nil
      end
    },

    { name = "heading",
      content = "inline",
      continue = function(_container)
        return false
      end,
      open = function(spec)
        local sp, ep = self:find("^#+")
        if ep and find(self.subject, "^%s", ep + 1) then
          local level = ep - sp + 1
          self:add_container(Container:new(spec, {level = level,
               inline_parser = inline.Parser:new(self.subject, self.opts,
                 self.warn) }))
          self:add_match(sp, ep, "+heading")
          self.pos = ep + 1
          return true
        end
      end,
      close = function(_container)
        self:get_inline_matches()
        local last = self.matches[#self.matches] or self.pos - 1
        local sp, ep, annot = unpack_match(last)
        -- handle final ###
        local endheadingpos = ep
        local endheadingendpos = ep
        if annot == "str" then
          local endheadingstart, _, hashes =
            find(sub(self.subject, sp, ep), "%s+(#+)$")
          if hashes then
            endheadingpos = endheadingpos - #hashes
            if endheadingstart == 1 then
              -- remove final str match
              self.matches[#self.matches] = nil
            else
              self.matches[#self.matches] =
                make_match(sp, sp + (endheadingstart - 2), "str")
            end
          end
        end
        self:add_match(endheadingpos, endheadingendpos, "-heading")
        self.containers[#self.containers] = nil
      end
    },

    { name = "code_block",
      content = "text",
      continue = function(container)
        local char = sub(container.border, 1, 1)
        local sp, ep, border = self:find("^(" .. container.border ..
                                 char .. "*)[ \t]*[\r\n]")
        if ep then
          container.end_fence_sp = sp
          container.end_fence_ep = sp + #border - 1
          self.pos = ep -- before newline
          self.finished_line = true
          return false
        else
          return true
        end
      end,
      open = function(spec)
        local sp, ep, border, ws, lang =
          self:find("^(~~~~*)([ \t]*)(%S*)[ \t]*[\r\n]")
        if not ep then
          sp, ep, border, ws, lang =
            self:find("^(````*)([ \t]*)([^%s`]*)[ \t]*[\r\n]")
        end
        if border then
          local is_raw = find(lang, "^=") and true or false
          self:add_container(Container:new(spec, {border = border,
                                                  indent = self.indent }))
          self:add_match(sp, sp + #border - 1, "+code_block")
          if #lang > 0 then
            local langstart = sp + #border + #ws
            if is_raw then
              self:add_match(langstart, langstart + #lang - 1, "raw_format")
            else
              self:add_match(langstart, langstart + #lang - 1, "code_language")
            end
          end
          self.pos = ep  -- before newline
          self.finished_line = true
          return true
        end
      end,
      close = function(container)
        local sp = container.end_fence_sp or self.pos
        local ep = container.end_fence_ep or self.pos
        self:add_match(sp, ep, "-code_block")
        if sp == ep then
          self.warn({ pos = self.pos, message = "Unclosed code block" })
        end
        self.containers[#self.containers] = nil
      end
    },

    { name = "fenced_div",
      content = "block",
      continue = function(container)
        local sp, ep, equals = self:find("^(::::*)[ \t]*[r\n]")
        if ep and #equals >= container.equals then
          container.end_fence_sp = sp
          container.end_fence_ep = sp + #equals - 1
          self.pos = ep -- before newline
          return false
        else
          return true
        end
      end,
      open = function(spec)
        local sp, ep1, equals = self:find("^(::::*)[ \t]*")
        if not ep1 then
          return false
        end
        local clsp, ep = find(self.subject, "^%w*", ep1 + 1)
        local _, eol = find(self.subject, "^[ \t]*[\r\n]", ep + 1)
        if eol then
          self:add_container(Container:new(spec, {equals = #equals}))
          self:add_match(sp, ep, "+div")
          if ep > clsp then
            self:add_match(clsp, ep, "class")
          end
          self.pos = eol + 1
          self.finished_line = true
          return true
        end
      end,
      close = function(container)
        local sp = container.end_fence_sp or self.pos
        local ep = container.end_fence_ep or self.pos
        -- check to make sure the match is in order
        self:add_match(sp, ep, "-div")
        if sp == ep then
          self.warn({pos = self.pos, message = "Unclosed div"})
        end
        self.containers[#self.containers] = nil
      end
    },

    { name = "table",
      content = "cells",
      continue = function(_container)
        local sp, ep = self:find("^|[^\r\n]*|")
        local eolsp = " *[\r\n]" -- make sure at end of line
        if sp and eolsp then
          return self:parse_table_row(sp, ep)
        end
      end,
      open = function(spec)
        local sp, ep = self:find("^|[^\r\n]*|")
        local eolsp = " *[\r\n]" -- make sure at end of line
        if sp and eolsp then
          self:add_container(Container:new(spec, { columns = 0 }))
          self:add_match(sp, sp, "+table")
          if self:parse_table_row(sp, ep) then
            return true
          else
            self.containers[#self.containers] = nil
            self.matches[#self.matches] = nil  -- remove +table match
            return false
          end
        end
     end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-table")
        self.containers[#self.containers] = nil
      end
    },

    { name = "attributes",
      content = "attributes",
      continue = function(container)
        if self.indent > container.indent then
          container.slices[#container.slices + 1] =
            {self.pos, self.endeol}
          self.pos = self.starteol
          return true
        else
          return false
        end
      end,
      open = function(spec)
        if self:find("^%{") then
          self:add_container(Container:new(spec,
                             { slices = {{self.pos, self.endeol}},
                               indent = self.indent }))
          self.pos = self.starteol
          return true
        end
      end,
      close = function(container)
        local attribute_parser = attributes.AttributeParser:new(self.subject)
        local slices = container.slices
        local status, finalpos
        for i=1,#slices do
          status, finalpos = attribute_parser:feed(unpack(slices[i]))
          if status ~= 'continue' then
            break
          end
        end
        -- make sure there's no extra content after the }
        if status == 'done' and find(self.subject, "^[ \t]*[\r\n]", finalpos + 1) then
          local attr_matches = attribute_parser:get_matches()
          self:add_match(slices[1][1], slices[1][1], "+block_attributes")
          for i=1,#attr_matches do
            self:add_match(unpack_match(attr_matches[i]))
          end
          self:add_match(slices[#slices][2], slices[#slices][2], "-block_attributes")
        else -- If not, parse it as inlines and add paragraph match
          container.inline_parser = inline.Parser:new(self.subject, self.opts)
          self:add_match(slices[1][1], slices[1][1], "+para")
          for i=1,#slices do
            container.inline_parser:feed(unpack(slices[i]))
          end
          self:get_inline_matches()
          self:add_match(slices[#slices][2], slices[#slices][2], "-para")
        end
        self.containers[#self.containers] = nil
      end
    }
  }
end

function Parser:get_inline_matches()
  local matches =
    self.containers[#self.containers].inline_parser:get_matches()
  for i=1,#matches do
    self.matches[#self.matches + 1] = matches[i]
  end
end

function Parser:find(patt)
  return find(self.subject, patt, self.pos)
end

function Parser:add_match(startpos, endpos, annotation)
  self.matches[#self.matches + 1] = make_match(startpos, endpos, annotation)
end

function Parser:add_container(container)
  local last_matched = self.last_matched_container
  while #self.containers > last_matched or
         (#self.containers > 0 and
          self.containers[#self.containers].content ~= "block") do
    self.containers[#self.containers]:close()
  end
  self.containers[#self.containers + 1] = container
end

function Parser:skip_space()
  local newpos, _ = find(self.subject, "[^ \t]", self.pos)
  if newpos then
    self.indent = newpos - self.startline
    self.pos = newpos
  end
end

function Parser:get_eol()
  local starteol, endeol = find(self.subject, "[\r]?[\n]", self.pos)
  if not endeol then
    starteol, endeol = #self.subject, #self.subject
  end
  self.starteol = starteol
  self.endeol = endeol
end

function Parser:parse()
  local specs = self:specs()
  local para_spec = specs[1]
  local subjectlen = #self.subject
  while self.pos <= subjectlen do

    self.indent = 0
    self.startline = self.pos
    self.finished_line = false
    self:get_eol()

    -- check open containers for continuation
    self.last_matched_container = 0
    local idx = 0
    while idx < #self.containers do
      idx = idx + 1
      local container = self.containers[idx]
      -- skip any indentation
      self:skip_space()
      if container:continue() then
        self.last_matched_container = idx
      else
        break
      end
    end

    -- if we hit a close fence, we can move to next line
    if self.finished_line then
      while #self.containers > self.last_matched_container do
        self.containers[#self.containers]:close()
      end
    end

    if not self.finished_line then
      -- check for new containers
      self:skip_space()
      local is_blank = (self.pos == self.starteol)

      local new_starts = false
      local last_match = self.containers[self.last_matched_container]
      local check_starts = not is_blank and
                          (not last_match or last_match.content == "block") and
                            not self:find("^%a+%s") -- optimization
      while check_starts do
        check_starts = false
        for i=1,#specs do
          local spec = specs[i]
          if not spec.is_para then
            if spec:open() then
              self.last_matched_container = #self.containers
              if self.finished_line then
                check_starts = false
              else
                self:skip_space()
                new_starts = true
                check_starts = spec.content ~= "text"
              end
              break
            end
          end
        end
      end

      if not self.finished_line then
        -- handle remaining content
        self:skip_space()

        is_blank = (self.pos == self.starteol)

        local is_lazy = not is_blank and
                        not new_starts and
                        self.last_matched_container < #self.containers and
                        self.containers[#self.containers].content == 'inline'

        if not is_lazy and
          self.last_matched_container < #self.containers then
          while #self.containers > self.last_matched_container do
            self.containers[#self.containers]:close()
          end
        end

        local tip = self.containers[#self.containers]

        -- add para by default if there's text
        if not tip or tip.content == 'block' then
          if is_blank then
            if not new_starts then
              -- need to track these for tight/loose lists
              self:add_match(self.pos, self.endeol, "blankline")
            end
          else
            para_spec:open()
          end
          tip = self.containers[#self.containers]
        end

        if tip then
          if tip.content == "text" then
            local startpos = self.pos
            if tip.indent and self.indent > tip.indent then
              -- get back the leading spaces we gobbled
              startpos = startpos - (self.indent - tip.indent)
            end
            self:add_match(startpos, self.endeol, "str")
          elseif tip.content == "inline" then
            if not is_blank then
              tip.inline_parser:feed(self.pos, self.endeol)
            end
          end
        end
      end
    end

    self.pos = self.endeol + 1
  end
  self:finish()

end

function Parser:finish()
  -- close unmatched containers
  while #self.containers > 0 do
    self.containers[#self.containers]:close()
  end
end

function Parser:get_matches()
  return self.matches
end

return { Parser = Parser,
         Container = Container }

end

package.preload["djot.emoji"] = function()
return {grinning="",
smiley="",
smile="",
grin="",
laughing="",
satisfied="",
sweat_smile="",
rofl="",
joy="",
slightly_smiling_face="",
upside_down_face="",
wink="",
blush="",
innocent="",
smiling_face_with_three_hearts="",
heart_eyes="",
star_struck="",
kissing_heart="",
kissing="",
relaxed="",
kissing_closed_eyes="",
kissing_smiling_eyes="",
smiling_face_with_tear="",
yum="",
stuck_out_tongue="",
stuck_out_tongue_winking_eye="",
zany_face="",
stuck_out_tongue_closed_eyes="",
money_mouth_face="",
hugs="",
hand_over_mouth="",
shushing_face="",
thinking="",
zipper_mouth_face="",
raised_eyebrow="",
neutral_face="",
expressionless="",
no_mouth="",
face_in_clouds="",
smirk="",
unamused="",
roll_eyes="",
grimacing="",
face_exhaling="",
lying_face="",
relieved="",
pensive="",
sleepy="",
drooling_face="",
sleeping="",
mask="",
face_with_thermometer="",
face_with_head_bandage="",
nauseated_face="",
vomiting_face="",
sneezing_face="",
hot_face="",
cold_face="",
woozy_face="",
dizzy_face="",
face_with_spiral_eyes="",
exploding_head="",
cowboy_hat_face="",
partying_face="",
disguised_face="",
sunglasses="",
nerd_face="",
monocle_face="",
confused="",
worried="",
slightly_frowning_face="",
frowning_face="",
open_mouth="",
hushed="",
astonished="",
flushed="",
pleading_face="",
frowning="",
anguished="",
fearful="",
cold_sweat="",
disappointed_relieved="",
cry="",
sob="",
scream="",
confounded="",
persevere="",
disappointed="",
sweat="",
weary="",
tired_face="",
yawning_face="",
triumph="",
rage="",
pout="",
angry="",
cursing_face="",
smiling_imp="",
imp="",
skull="",
skull_and_crossbones="",
hankey="",
poop="",
shit="",
clown_face="",
japanese_ogre="",
japanese_goblin="",
ghost="",
alien="",
space_invader="",
robot="",
smiley_cat="",
smile_cat="",
joy_cat="",
heart_eyes_cat="",
smirk_cat="",
kissing_cat="",
scream_cat="",
crying_cat_face="",
pouting_cat="",
see_no_evil="",
hear_no_evil="",
speak_no_evil="",
kiss="",
love_letter="",
cupid="",
gift_heart="",
sparkling_heart="",
heartpulse="",
heartbeat="",
revolving_hearts="",
two_hearts="",
heart_decoration="",
heavy_heart_exclamation="",
broken_heart="",
heart_on_fire="",
mending_heart="",
heart="",
orange_heart="",
yellow_heart="",
green_heart="",
blue_heart="",
purple_heart="",
brown_heart="",
black_heart="",
white_heart="",
["100"]="",
anger="",
boom="",
collision="",
dizzy="",
sweat_drops="",
dash="",
hole="",
bomb="",
speech_balloon="",
eye_speech_bubble="",
left_speech_bubble="",
right_anger_bubble="",
thought_balloon="",
zzz="",
wave="",
raised_back_of_hand="",
raised_hand_with_fingers_splayed="",
hand="",
raised_hand="",
vulcan_salute="",
ok_hand="",
pinched_fingers="",
pinching_hand="",
v="",
crossed_fingers="",
love_you_gesture="",
metal="",
call_me_hand="",
point_left="",
point_right="",
["point_up_2"]="",
middle_finger="",
fu="",
point_down="",
point_up="",
["+1"]="",
thumbsup="",
["-1"]="",
thumbsdown="",
fist_raised="",
fist="",
fist_oncoming="",
facepunch="",
punch="",
fist_left="",
fist_right="",
clap="",
raised_hands="",
open_hands="",
palms_up_together="",
handshake="",
pray="",
writing_hand="",
nail_care="",
selfie="",
muscle="",
mechanical_arm="",
mechanical_leg="",
leg="",
foot="",
ear="",
ear_with_hearing_aid="",
nose="",
brain="",
anatomical_heart="",
lungs="",
tooth="",
bone="",
eyes="",
eye="",
tongue="",
lips="",
baby="",
child="",
boy="",
girl="",
adult="",
blond_haired_person="",
man="",
bearded_person="",
man_beard="",
woman_beard="",
red_haired_man="",
curly_haired_man="",
white_haired_man="",
bald_man="",
woman="",
red_haired_woman="",
person_red_hair="",
curly_haired_woman="",
person_curly_hair="",
white_haired_woman="",
person_white_hair="",
bald_woman="",
person_bald="",
blond_haired_woman="",
blonde_woman="",
blond_haired_man="",
older_adult="",
older_man="",
older_woman="",
frowning_person="",
frowning_man="",
frowning_woman="",
pouting_face="",
pouting_man="",
pouting_woman="",
no_good="",
no_good_man="",
ng_man="",
no_good_woman="",
ng_woman="",
ok_person="",
ok_man="",
ok_woman="",
tipping_hand_person="",
information_desk_person="",
tipping_hand_man="",
sassy_man="",
tipping_hand_woman="",
sassy_woman="",
raising_hand="",
raising_hand_man="",
raising_hand_woman="",
deaf_person="",
deaf_man="",
deaf_woman="",
bow="",
bowing_man="",
bowing_woman="",
facepalm="",
man_facepalming="",
woman_facepalming="",
shrug="",
man_shrugging="",
woman_shrugging="",
health_worker="",
man_health_worker="",
woman_health_worker="",
student="",
man_student="",
woman_student="",
teacher="",
man_teacher="",
woman_teacher="",
judge="",
man_judge="",
woman_judge="",
farmer="",
man_farmer="",
woman_farmer="",
cook="",
man_cook="",
woman_cook="",
mechanic="",
man_mechanic="",
woman_mechanic="",
factory_worker="",
man_factory_worker="",
woman_factory_worker="",
office_worker="",
man_office_worker="",
woman_office_worker="",
scientist="",
man_scientist="",
woman_scientist="",
technologist="",
man_technologist="",
woman_technologist="",
singer="",
man_singer="",
woman_singer="",
artist="",
man_artist="",
woman_artist="",
pilot="",
man_pilot="",
woman_pilot="",
astronaut="",
man_astronaut="",
woman_astronaut="",
firefighter="",
man_firefighter="",
woman_firefighter="",
police_officer="",
cop="",
policeman="",
policewoman="",
detective="",
male_detective="",
female_detective="",
guard="",
guardsman="",
guardswoman="",
ninja="",
construction_worker="",
construction_worker_man="",
construction_worker_woman="",
prince="",
princess="",
person_with_turban="",
man_with_turban="",
woman_with_turban="",
man_with_gua_pi_mao="",
woman_with_headscarf="",
person_in_tuxedo="",
man_in_tuxedo="",
woman_in_tuxedo="",
person_with_veil="",
man_with_veil="",
woman_with_veil="",
bride_with_veil="",
pregnant_woman="",
breast_feeding="",
woman_feeding_baby="",
man_feeding_baby="",
person_feeding_baby="",
angel="",
santa="",
mrs_claus="",
mx_claus="",
superhero="",
superhero_man="",
superhero_woman="",
supervillain="",
supervillain_man="",
supervillain_woman="",
mage="",
mage_man="",
mage_woman="",
fairy="",
fairy_man="",
fairy_woman="",
vampire="",
vampire_man="",
vampire_woman="",
merperson="",
merman="",
mermaid="",
elf="",
elf_man="",
elf_woman="",
genie="",
genie_man="",
genie_woman="",
zombie="",
zombie_man="",
zombie_woman="",
massage="",
massage_man="",
massage_woman="",
haircut="",
haircut_man="",
haircut_woman="",
walking="",
walking_man="",
walking_woman="",
standing_person="",
standing_man="",
standing_woman="",
kneeling_person="",
kneeling_man="",
kneeling_woman="",
person_with_probing_cane="",
man_with_probing_cane="",
woman_with_probing_cane="",
person_in_motorized_wheelchair="",
man_in_motorized_wheelchair="",
woman_in_motorized_wheelchair="",
person_in_manual_wheelchair="",
man_in_manual_wheelchair="",
woman_in_manual_wheelchair="",
runner="",
running="",
running_man="",
running_woman="",
woman_dancing="",
dancer="",
man_dancing="",
business_suit_levitating="",
dancers="",
dancing_men="",
dancing_women="",
sauna_person="",
sauna_man="",
sauna_woman="",
climbing="",
climbing_man="",
climbing_woman="",
person_fencing="",
horse_racing="",
skier="",
snowboarder="",
golfing="",
golfing_man="",
golfing_woman="",
surfer="",
surfing_man="",
surfing_woman="",
rowboat="",
rowing_man="",
rowing_woman="",
swimmer="",
swimming_man="",
swimming_woman="",
bouncing_ball_person="",
bouncing_ball_man="",
basketball_man="",
bouncing_ball_woman="",
basketball_woman="",
weight_lifting="",
weight_lifting_man="",
weight_lifting_woman="",
bicyclist="",
biking_man="",
biking_woman="",
mountain_bicyclist="",
mountain_biking_man="",
mountain_biking_woman="",
cartwheeling="",
man_cartwheeling="",
woman_cartwheeling="",
wrestling="",
men_wrestling="",
women_wrestling="",
water_polo="",
man_playing_water_polo="",
woman_playing_water_polo="",
handball_person="",
man_playing_handball="",
woman_playing_handball="",
juggling_person="",
man_juggling="",
woman_juggling="",
lotus_position="",
lotus_position_man="",
lotus_position_woman="",
bath="",
sleeping_bed="",
people_holding_hands="",
two_women_holding_hands="",
couple="",
two_men_holding_hands="",
couplekiss="",
couplekiss_man_woman="",
couplekiss_man_man="",
couplekiss_woman_woman="",
couple_with_heart="",
couple_with_heart_woman_man="",
couple_with_heart_man_man="",
couple_with_heart_woman_woman="",
family="",
family_man_woman_boy="",
family_man_woman_girl="",
family_man_woman_girl_boy="",
family_man_woman_boy_boy="",
family_man_woman_girl_girl="",
family_man_man_boy="",
family_man_man_girl="",
family_man_man_girl_boy="",
family_man_man_boy_boy="",
family_man_man_girl_girl="",
family_woman_woman_boy="",
family_woman_woman_girl="",
family_woman_woman_girl_boy="",
family_woman_woman_boy_boy="",
family_woman_woman_girl_girl="",
family_man_boy="",
family_man_boy_boy="",
family_man_girl="",
family_man_girl_boy="",
family_man_girl_girl="",
family_woman_boy="",
family_woman_boy_boy="",
family_woman_girl="",
family_woman_girl_boy="",
family_woman_girl_girl="",
speaking_head="",
bust_in_silhouette="",
busts_in_silhouette="",
people_hugging="",
footprints="",
monkey_face="",
monkey="",
gorilla="",
orangutan="",
dog="",
["dog2"]="",
guide_dog="",
service_dog="",
poodle="",
wolf="",
fox_face="",
raccoon="",
cat="",
["cat2"]="",
black_cat="",
lion="",
tiger="",
["tiger2"]="",
leopard="",
horse="",
racehorse="",
unicorn="",
zebra="",
deer="",
bison="",
cow="",
ox="",
water_buffalo="",
["cow2"]="",
pig="",
["pig2"]="",
boar="",
pig_nose="",
ram="",
sheep="",
goat="",
dromedary_camel="",
camel="",
llama="",
giraffe="",
elephant="",
mammoth="",
rhinoceros="",
hippopotamus="",
mouse="",
["mouse2"]="",
rat="",
hamster="",
rabbit="",
["rabbit2"]="",
chipmunk="",
beaver="",
hedgehog="",
bat="",
bear="",
polar_bear="",
koala="",
panda_face="",
sloth="",
otter="",
skunk="",
kangaroo="",
badger="",
feet="",
paw_prints="",
turkey="",
chicken="",
rooster="",
hatching_chick="",
baby_chick="",
hatched_chick="",
bird="",
penguin="",
dove="",
eagle="",
duck="",
swan="",
owl="",
dodo="",
feather="",
flamingo="",
peacock="",
parrot="",
frog="",
crocodile="",
turtle="",
lizard="",
snake="",
dragon_face="",
dragon="",
sauropod="",
["t-rex"]="",
whale="",
["whale2"]="",
dolphin="",
flipper="",
seal="",
fish="",
tropical_fish="",
blowfish="",
shark="",
octopus="",
shell="",
snail="",
butterfly="",
bug="",
ant="",
bee="",
honeybee="",
beetle="",
lady_beetle="",
cricket="",
cockroach="",
spider="",
spider_web="",
scorpion="",
mosquito="",
fly="",
worm="",
microbe="",
bouquet="",
cherry_blossom="",
white_flower="",
rosette="",
rose="",
wilted_flower="",
hibiscus="",
sunflower="",
blossom="",
tulip="",
seedling="",
potted_plant="",
evergreen_tree="",
deciduous_tree="",
palm_tree="",
cactus="",
ear_of_rice="",
herb="",
shamrock="",
four_leaf_clover="",
maple_leaf="",
fallen_leaf="",
leaves="",
grapes="",
melon="",
watermelon="",
tangerine="",
orange="",
mandarin="",
lemon="",
banana="",
pineapple="",
mango="",
apple="",
green_apple="",
pear="",
peach="",
cherries="",
strawberry="",
blueberries="",
kiwi_fruit="",
tomato="",
olive="",
coconut="",
avocado="",
eggplant="",
potato="",
carrot="",
corn="",
hot_pepper="",
bell_pepper="",
cucumber="",
leafy_green="",
broccoli="",
garlic="",
onion="",
mushroom="",
peanuts="",
chestnut="",
bread="",
croissant="",
baguette_bread="",
flatbread="",
pretzel="",
bagel="",
pancakes="",
waffle="",
cheese="",
meat_on_bone="",
poultry_leg="",
cut_of_meat="",
bacon="",
hamburger="",
fries="",
pizza="",
hotdog="",
sandwich="",
taco="",
burrito="",
tamale="",
stuffed_flatbread="",
falafel="",
egg="",
fried_egg="",
shallow_pan_of_food="",
stew="",
fondue="",
bowl_with_spoon="",
green_salad="",
popcorn="",
butter="",
salt="",
canned_food="",
bento="",
rice_cracker="",
rice_ball="",
rice="",
curry="",
ramen="",
spaghetti="",
sweet_potato="",
oden="",
sushi="",
fried_shrimp="",
fish_cake="",
moon_cake="",
dango="",
dumpling="",
fortune_cookie="",
takeout_box="",
crab="",
lobster="",
shrimp="",
squid="",
oyster="",
icecream="",
shaved_ice="",
ice_cream="",
doughnut="",
cookie="",
birthday="",
cake="",
cupcake="",
pie="",
chocolate_bar="",
candy="",
lollipop="",
custard="",
honey_pot="",
baby_bottle="",
milk_glass="",
coffee="",
teapot="",
tea="",
sake="",
champagne="",
wine_glass="",
cocktail="",
tropical_drink="",
beer="",
beers="",
clinking_glasses="",
tumbler_glass="",
cup_with_straw="",
bubble_tea="",
beverage_box="",
mate="",
ice_cube="",
chopsticks="",
plate_with_cutlery="",
fork_and_knife="",
spoon="",
hocho="",
knife="",
amphora="",
earth_africa="",
earth_americas="",
earth_asia="",
globe_with_meridians="",
world_map="",
japan="",
compass="",
mountain_snow="",
mountain="",
volcano="",
mount_fuji="",
camping="",
beach_umbrella="",
desert="",
desert_island="",
national_park="",
stadium="",
classical_building="",
building_construction="",
bricks="",
rock="",
wood="",
hut="",
houses="",
derelict_house="",
house="",
house_with_garden="",
office="",
post_office="",
european_post_office="",
hospital="",
bank="",
hotel="",
love_hotel="",
convenience_store="",
school="",
department_store="",
factory="",
japanese_castle="",
european_castle="",
wedding="",
tokyo_tower="",
statue_of_liberty="",
church="",
mosque="",
hindu_temple="",
synagogue="",
shinto_shrine="",
kaaba="",
fountain="",
tent="",
foggy="",
night_with_stars="",
cityscape="",
sunrise_over_mountains="",
sunrise="",
city_sunset="",
city_sunrise="",
bridge_at_night="",
hotsprings="",
carousel_horse="",
ferris_wheel="",
roller_coaster="",
barber="",
circus_tent="",
steam_locomotive="",
railway_car="",
bullettrain_side="",
bullettrain_front="",
["train2"]="",
metro="",
light_rail="",
station="",
tram="",
monorail="",
mountain_railway="",
train="",
bus="",
oncoming_bus="",
trolleybus="",
minibus="",
ambulance="",
fire_engine="",
police_car="",
oncoming_police_car="",
taxi="",
oncoming_taxi="",
car="",
red_car="",
oncoming_automobile="",
blue_car="",
pickup_truck="",
truck="",
articulated_lorry="",
tractor="",
racing_car="",
motorcycle="",
motor_scooter="",
manual_wheelchair="",
motorized_wheelchair="",
auto_rickshaw="",
bike="",
kick_scooter="",
skateboard="",
roller_skate="",
busstop="",
motorway="",
railway_track="",
oil_drum="",
fuelpump="",
rotating_light="",
traffic_light="",
vertical_traffic_light="",
stop_sign="",
construction="",
anchor="",
boat="",
sailboat="",
canoe="",
speedboat="",
passenger_ship="",
ferry="",
motor_boat="",
ship="",
airplane="",
small_airplane="",
flight_departure="",
flight_arrival="",
parachute="",
seat="",
helicopter="",
suspension_railway="",
mountain_cableway="",
aerial_tramway="",
artificial_satellite="",
rocket="",
flying_saucer="",
bellhop_bell="",
luggage="",
hourglass="",
hourglass_flowing_sand="",
watch="",
alarm_clock="",
stopwatch="",
timer_clock="",
mantelpiece_clock="",
["clock12"]="",
["clock1230"]="",
["clock1"]="",
["clock130"]="",
["clock2"]="",
["clock230"]="",
["clock3"]="",
["clock330"]="",
["clock4"]="",
["clock430"]="",
["clock5"]="",
["clock530"]="",
["clock6"]="",
["clock630"]="",
["clock7"]="",
["clock730"]="",
["clock8"]="",
["clock830"]="",
["clock9"]="",
["clock930"]="",
["clock10"]="",
["clock1030"]="",
["clock11"]="",
["clock1130"]="",
new_moon="",
waxing_crescent_moon="",
first_quarter_moon="",
moon="",
waxing_gibbous_moon="",
full_moon="",
waning_gibbous_moon="",
last_quarter_moon="",
waning_crescent_moon="",
crescent_moon="",
new_moon_with_face="",
first_quarter_moon_with_face="",
last_quarter_moon_with_face="",
thermometer="",
sunny="",
full_moon_with_face="",
sun_with_face="",
ringed_planet="",
star="",
["star2"]="",
stars="",
milky_way="",
cloud="",
partly_sunny="",
cloud_with_lightning_and_rain="",
sun_behind_small_cloud="",
sun_behind_large_cloud="",
sun_behind_rain_cloud="",
cloud_with_rain="",
cloud_with_snow="",
cloud_with_lightning="",
tornado="",
fog="",
wind_face="",
cyclone="",
rainbow="",
closed_umbrella="",
open_umbrella="",
umbrella="",
parasol_on_ground="",
zap="",
snowflake="",
snowman_with_snow="",
snowman="",
comet="",
fire="",
droplet="",
ocean="",
jack_o_lantern="",
christmas_tree="",
fireworks="",
sparkler="",
firecracker="",
sparkles="",
balloon="",
tada="",
confetti_ball="",
tanabata_tree="",
bamboo="",
dolls="",
flags="",
wind_chime="",
rice_scene="",
red_envelope="",
ribbon="",
gift="",
reminder_ribbon="",
tickets="",
ticket="",
medal_military="",
trophy="",
medal_sports="",
["1st_place_medal"]="",
["2nd_place_medal"]="",
["3rd_place_medal"]="",
soccer="",
baseball="",
softball="",
basketball="",
volleyball="",
football="",
rugby_football="",
tennis="",
flying_disc="",
bowling="",
cricket_game="",
field_hockey="",
ice_hockey="",
lacrosse="",
ping_pong="",
badminton="",
boxing_glove="",
martial_arts_uniform="",
goal_net="",
golf="",
ice_skate="",
fishing_pole_and_fish="",
diving_mask="",
running_shirt_with_sash="",
ski="",
sled="",
curling_stone="",
dart="",
yo_yo="",
kite="",
["8ball"]="",
crystal_ball="",
magic_wand="",
nazar_amulet="",
video_game="",
joystick="",
slot_machine="",
game_die="",
jigsaw="",
teddy_bear="",
pinata="",
nesting_dolls="",
spades="",
hearts="",
diamonds="",
clubs="",
chess_pawn="",
black_joker="",
mahjong="",
flower_playing_cards="",
performing_arts="",
framed_picture="",
art="",
thread="",
sewing_needle="",
yarn="",
knot="",
eyeglasses="",
dark_sunglasses="",
goggles="",
lab_coat="",
safety_vest="",
necktie="",
shirt="",
tshirt="",
jeans="",
scarf="",
gloves="",
coat="",
socks="",
dress="",
kimono="",
sari="",
one_piece_swimsuit="",
swim_brief="",
shorts="",
bikini="",
womans_clothes="",
purse="",
handbag="",
pouch="",
shopping="",
school_satchel="",
thong_sandal="",
mans_shoe="",
shoe="",
athletic_shoe="",
hiking_boot="",
flat_shoe="",
high_heel="",
sandal="",
ballet_shoes="",
boot="",
crown="",
womans_hat="",
tophat="",
mortar_board="",
billed_cap="",
military_helmet="",
rescue_worker_helmet="",
prayer_beads="",
lipstick="",
ring="",
gem="",
mute="",
speaker="",
sound="",
loud_sound="",
loudspeaker="",
mega="",
postal_horn="",
bell="",
no_bell="",
musical_score="",
musical_note="",
notes="",
studio_microphone="",
level_slider="",
control_knobs="",
microphone="",
headphones="",
radio="",
saxophone="",
accordion="",
guitar="",
musical_keyboard="",
trumpet="",
violin="",
banjo="",
drum="",
long_drum="",
iphone="",
calling="",
phone="",
telephone="",
telephone_receiver="",
pager="",
fax="",
battery="",
electric_plug="",
computer="",
desktop_computer="",
printer="",
keyboard="",
computer_mouse="",
trackball="",
minidisc="",
floppy_disk="",
cd="",
dvd="",
abacus="",
movie_camera="",
film_strip="",
film_projector="",
clapper="",
tv="",
camera="",
camera_flash="",
video_camera="",
vhs="",
mag="",
mag_right="",
candle="",
bulb="",
flashlight="",
izakaya_lantern="",
lantern="",
diya_lamp="",
notebook_with_decorative_cover="",
closed_book="",
book="",
open_book="",
green_book="",
blue_book="",
orange_book="",
books="",
notebook="",
ledger="",
page_with_curl="",
scroll="",
page_facing_up="",
newspaper="",
newspaper_roll="",
bookmark_tabs="",
bookmark="",
label="",
moneybag="",
coin="",
yen="",
dollar="",
euro="",
pound="",
money_with_wings="",
credit_card="",
receipt="",
chart="",
envelope="",
email="",
["e-mail"]="",
incoming_envelope="",
envelope_with_arrow="",
outbox_tray="",
inbox_tray="",
package="",
mailbox="",
mailbox_closed="",
mailbox_with_mail="",
mailbox_with_no_mail="",
postbox="",
ballot_box="",
["pencil2"]="",
black_nib="",
fountain_pen="",
pen="",
paintbrush="",
crayon="",
memo="",
pencil="",
briefcase="",
file_folder="",
open_file_folder="",
card_index_dividers="",
date="",
calendar="",
spiral_notepad="",
spiral_calendar="",
card_index="",
chart_with_upwards_trend="",
chart_with_downwards_trend="",
bar_chart="",
clipboard="",
pushpin="",
round_pushpin="",
paperclip="",
paperclips="",
straight_ruler="",
triangular_ruler="",
scissors="",
card_file_box="",
file_cabinet="",
wastebasket="",
lock="",
unlock="",
lock_with_ink_pen="",
closed_lock_with_key="",
key="",
old_key="",
hammer="",
axe="",
pick="",
hammer_and_pick="",
hammer_and_wrench="",
dagger="",
crossed_swords="",
gun="",
boomerang="",
bow_and_arrow="",
shield="",
carpentry_saw="",
wrench="",
screwdriver="",
nut_and_bolt="",
gear="",
clamp="",
balance_scale="",
probing_cane="",
link="",
chains="",
hook="",
toolbox="",
magnet="",
ladder="",
alembic="",
test_tube="",
petri_dish="",
dna="",
microscope="",
telescope="",
satellite="",
syringe="",
drop_of_blood="",
pill="",
adhesive_bandage="",
stethoscope="",
door="",
elevator="",
mirror="",
window="",
bed="",
couch_and_lamp="",
chair="",
toilet="",
plunger="",
shower="",
bathtub="",
mouse_trap="",
razor="",
lotion_bottle="",
safety_pin="",
broom="",
basket="",
roll_of_paper="",
bucket="",
soap="",
toothbrush="",
sponge="",
fire_extinguisher="",
shopping_cart="",
smoking="",
coffin="",
headstone="",
funeral_urn="",
moyai="",
placard="",
atm="",
put_litter_in_its_place="",
potable_water="",
wheelchair="",
mens="",
womens="",
restroom="",
baby_symbol="",
wc="",
passport_control="",
customs="",
baggage_claim="",
left_luggage="",
warning="",
children_crossing="",
no_entry="",
no_entry_sign="",
no_bicycles="",
no_smoking="",
do_not_litter="",
["non-potable_water"]="",
no_pedestrians="",
no_mobile_phones="",
underage="",
radioactive="",
biohazard="",
arrow_up="",
arrow_upper_right="",
arrow_right="",
arrow_lower_right="",
arrow_down="",
arrow_lower_left="",
arrow_left="",
arrow_upper_left="",
arrow_up_down="",
left_right_arrow="",
leftwards_arrow_with_hook="",
arrow_right_hook="",
arrow_heading_up="",
arrow_heading_down="",
arrows_clockwise="",
arrows_counterclockwise="",
back="",
["end"]="",
on="",
soon="",
top="",
place_of_worship="",
atom_symbol="",
om="",
star_of_david="",
wheel_of_dharma="",
yin_yang="",
latin_cross="",
orthodox_cross="",
star_and_crescent="",
peace_symbol="",
menorah="",
six_pointed_star="",
aries="",
taurus="",
gemini="",
cancer="",
leo="",
virgo="",
libra="",
scorpius="",
sagittarius="",
capricorn="",
aquarius="",
pisces="",
ophiuchus="",
twisted_rightwards_arrows="",
["repeat"]="",
repeat_one="",
arrow_forward="",
fast_forward="",
next_track_button="",
play_or_pause_button="",
arrow_backward="",
rewind="",
previous_track_button="",
arrow_up_small="",
arrow_double_up="",
arrow_down_small="",
arrow_double_down="",
pause_button="",
stop_button="",
record_button="",
eject_button="",
cinema="",
low_brightness="",
high_brightness="",
signal_strength="",
vibration_mode="",
mobile_phone_off="",
female_sign="",
male_sign="",
transgender_symbol="",
heavy_multiplication_x="",
heavy_plus_sign="",
heavy_minus_sign="",
heavy_division_sign="",
infinity="",
bangbang="",
interrobang="",
question="",
grey_question="",
grey_exclamation="",
exclamation="",
heavy_exclamation_mark="",
wavy_dash="",
currency_exchange="",
heavy_dollar_sign="",
medical_symbol="",
recycle="",
fleur_de_lis="",
trident="",
name_badge="",
beginner="",
o="",
white_check_mark="",
ballot_box_with_check="",
heavy_check_mark="",
x="",
negative_squared_cross_mark="",
curly_loop="",
loop="",
part_alternation_mark="",
eight_spoked_asterisk="",
eight_pointed_black_star="",
sparkle="",
copyright="",
registered="",
tm="",
hash="#",
asterisk="*",
zero="0",
one="1",
two="2",
three="3",
four="4",
five="5",
six="6",
seven="7",
eight="8",
nine="9",
keycap_ten="",
capital_abcd="",
abcd="",
["1234"]="",
symbols="",
abc="",
a="",
ab="",
b="",
cl="",
cool="",
free="",
information_source="",
id="",
m="",
new="",
ng="",
["o2"]="",
ok="",
parking="",
sos="",
up="",
vs="",
koko="",
sa="",
["u6708"]="",
["u6709"]="",
["u6307"]="",
ideograph_advantage="",
["u5272"]="",
["u7121"]="",
["u7981"]="",
accept="",
["u7533"]="",
["u5408"]="",
["u7a7a"]="",
congratulations="",
secret="",
["u55b6"]="",
["u6e80"]="",
red_circle="",
orange_circle="",
yellow_circle="",
green_circle="",
large_blue_circle="",
purple_circle="",
brown_circle="",
black_circle="",
white_circle="",
red_square="",
orange_square="",
yellow_square="",
green_square="",
blue_square="",
purple_square="",
brown_square="",
black_large_square="",
white_large_square="",
black_medium_square="",
white_medium_square="",
black_medium_small_square="",
white_medium_small_square="",
black_small_square="",
white_small_square="",
large_orange_diamond="",
large_blue_diamond="",
small_orange_diamond="",
small_blue_diamond="",
small_red_triangle="",
small_red_triangle_down="",
diamond_shape_with_a_dot_inside="",
radio_button="",
white_square_button="",
black_square_button="",
checkered_flag="",
triangular_flag_on_post="",
crossed_flags="",
black_flag="",
white_flag="",
rainbow_flag="",
transgender_flag="",
pirate_flag="",
ascension_island="",
andorra="",
united_arab_emirates="",
afghanistan="",
antigua_barbuda="",
anguilla="",
albania="",
armenia="",
angola="",
antarctica="",
argentina="",
american_samoa="",
austria="",
australia="",
aruba="",
aland_islands="",
azerbaijan="",
bosnia_herzegovina="",
barbados="",
bangladesh="",
belgium="",
burkina_faso="",
bulgaria="",
bahrain="",
burundi="",
benin="",
st_barthelemy="",
bermuda="",
brunei="",
bolivia="",
caribbean_netherlands="",
brazil="",
bahamas="",
bhutan="",
bouvet_island="",
botswana="",
belarus="",
belize="",
canada="",
cocos_islands="",
congo_kinshasa="",
central_african_republic="",
congo_brazzaville="",
switzerland="",
cote_divoire="",
cook_islands="",
chile="",
cameroon="",
cn="",
colombia="",
clipperton_island="",
costa_rica="",
cuba="",
cape_verde="",
curacao="",
christmas_island="",
cyprus="",
czech_republic="",
de="",
diego_garcia="",
djibouti="",
denmark="",
dominica="",
dominican_republic="",
algeria="",
ceuta_melilla="",
ecuador="",
estonia="",
egypt="",
western_sahara="",
eritrea="",
es="",
ethiopia="",
eu="",
european_union="",
finland="",
fiji="",
falkland_islands="",
micronesia="",
faroe_islands="",
fr="",
gabon="",
gb="",
uk="",
grenada="",
georgia="",
french_guiana="",
guernsey="",
ghana="",
gibraltar="",
greenland="",
gambia="",
guinea="",
guadeloupe="",
equatorial_guinea="",
greece="",
south_georgia_south_sandwich_islands="",
guatemala="",
guam="",
guinea_bissau="",
guyana="",
hong_kong="",
heard_mcdonald_islands="",
honduras="",
croatia="",
haiti="",
hungary="",
canary_islands="",
indonesia="",
ireland="",
israel="",
isle_of_man="",
india="",
british_indian_ocean_territory="",
iraq="",
iran="",
iceland="",
it="",
jersey="",
jamaica="",
jordan="",
jp="",
kenya="",
kyrgyzstan="",
cambodia="",
kiribati="",
comoros="",
st_kitts_nevis="",
north_korea="",
kr="",
kuwait="",
cayman_islands="",
kazakhstan="",
laos="",
lebanon="",
st_lucia="",
liechtenstein="",
sri_lanka="",
liberia="",
lesotho="",
lithuania="",
luxembourg="",
latvia="",
libya="",
morocco="",
monaco="",
moldova="",
montenegro="",
st_martin="",
madagascar="",
marshall_islands="",
macedonia="",
mali="",
myanmar="",
mongolia="",
macau="",
northern_mariana_islands="",
martinique="",
mauritania="",
montserrat="",
malta="",
mauritius="",
maldives="",
malawi="",
mexico="",
malaysia="",
mozambique="",
namibia="",
new_caledonia="",
niger="",
norfolk_island="",
nigeria="",
nicaragua="",
netherlands="",
norway="",
nepal="",
nauru="",
niue="",
new_zealand="",
oman="",
panama="",
peru="",
french_polynesia="",
papua_new_guinea="",
philippines="",
pakistan="",
poland="",
st_pierre_miquelon="",
pitcairn_islands="",
puerto_rico="",
palestinian_territories="",
portugal="",
palau="",
paraguay="",
qatar="",
reunion="",
romania="",
serbia="",
ru="",
rwanda="",
saudi_arabia="",
solomon_islands="",
seychelles="",
sudan="",
sweden="",
singapore="",
st_helena="",
slovenia="",
svalbard_jan_mayen="",
slovakia="",
sierra_leone="",
san_marino="",
senegal="",
somalia="",
suriname="",
south_sudan="",
sao_tome_principe="",
el_salvador="",
sint_maarten="",
syria="",
swaziland="",
tristan_da_cunha="",
turks_caicos_islands="",
chad="",
french_southern_territories="",
togo="",
thailand="",
tajikistan="",
tokelau="",
timor_leste="",
turkmenistan="",
tunisia="",
tonga="",
tr="",
trinidad_tobago="",
tuvalu="",
taiwan="",
tanzania="",
ukraine="",
uganda="",
us_outlying_islands="",
united_nations="",
us="",
uruguay="",
uzbekistan="",
vatican_city="",
st_vincent_grenadines="",
venezuela="",
british_virgin_islands="",
us_virgin_islands="",
vietnam="",
vanuatu="",
wallis_futuna="",
samoa="",
kosovo="",
yemen="",
mayotte="",
south_africa="",
zambia="",
zimbabwe="",
england="",
scotland="",
wales=""}

end

package.preload["djot.html"] = function()
local ast = require("djot.ast")
local unpack = unpack or table.unpack
local insert_attribute, copy_attributes =
  ast.insert_attribute, ast.copy_attributes
local format = string.format
local find, gsub = string.find, string.gsub

-- Produce a copy of a table.
local function copy(tbl)
  local result = {}
  if tbl then
    for k,v in pairs(tbl) do
      local newv = v
      if type(v) == "table" then
        newv = copy(v)
      end
      result[k] = newv
    end
  end
  return result
end

local function to_text(node)
  local buffer = {}
  if node.t == "str" then
    buffer[#buffer + 1] = node.s
  elseif node.t == "nbsp" then
    buffer[#buffer + 1] = "\160"
  elseif node.t == "softbreak" then
    buffer[#buffer + 1] = " "
  elseif node.c and #node.c > 0 then
    for i=1,#node.c do
      buffer[#buffer + 1] = to_text(node.c[i])
    end
  end
  return table.concat(buffer)
end

local Renderer = {}

function Renderer:new()
  local state = {
    out = function(s)
      io.stdout:write(s)
    end,
    tight = false,
    footnote_index = {},
    next_footnote_index = 1,
    references = nil,
    footnotes = nil }
  setmetatable(state, self)
  self.__index = self
  return state
end

Renderer.html_escapes =
   { ["<"] = "&lt;",
     [">"] = "&gt;",
     ["&"] = "&amp;",
     ['"'] = "&quot;" }

function Renderer:escape_html(s)
  if find(s, '[<>&]') then
    return (gsub(s, '[<>&]', self.html_escapes))
  else
    return s
  end
end

function Renderer:escape_html_attribute(s)
  if find(s, '[<>&"]') then
    return (gsub(s, '[<>&"]', self.html_escapes))
  else
    return s
  end
end

function Renderer:render(doc, handle)
  self.references = doc.references
  self.footnotes = doc.footnotes
  if handle then
    self.out = function(s)
      handle:write(s)
    end
  end
  self[doc.t](self, doc)
end


function Renderer:render_children(node)
  if node.c and #node.c > 0 then
    local oldtight
    if node.tight ~= nil then
      oldtight = self.tight
      self.tight = node.tight
    end
    for i=1,#node.c do
      self[node.c[i].t](self, node.c[i])
    end
    if node.tight ~= nil then
      self.tight = oldtight
    end
  end
end

function Renderer:render_attrs(node)
  if node.attr then
    local keys = node.attr._keys or {}
    for i=1,#keys do
      local k = keys[i]
      if k == nil then
        break
      end
      self.out(" " .. k .. "=" .. '"' ..
            self:escape_html_attribute(node.attr[k]) .. '"')
    end
  end
  if node.pos then
    local sp, ep = unpack(node.pos)
    self.out(' data-startpos="' .. tostring(sp) ..
      '" data-endpos="' .. tostring(ep) .. '"')
  end
end

function Renderer:render_tag(tag, node)
  self.out("<" .. tag)
  self:render_attrs(node)
  self.out(">")
end

function Renderer:add_backlink(nodes, i)
  local backlink = {t = "link",
                    destination = "#fnref" .. tostring(i),
                    attr = {role = "doc-backlink", _keys = {"role"}},
                    c = {{t = "str", s = ""}}}
  if nodes.c[#nodes.c].t == "para" then
    table.insert(nodes.c[#nodes.c].c, backlink)
  else
    table.insert(nodes.c, {t = "para", c = {backlink}})
  end
end

function Renderer:doc(node)
  self:render_children(node)
  -- render notes
  if self.next_footnote_index > 1 then
    local ordered_footnotes = {}
    for k,v in pairs(self.footnotes) do
      if self.footnote_index[k] then
        ordered_footnotes[self.footnote_index[k]] = v
      end
    end
    self.out('<section role="doc-endnotes">\n<hr>\n<ol>\n')
    for i=1,#ordered_footnotes do
      self.out(format('<li id="fn%d">\n', i))
      self:add_backlink(ordered_footnotes[i],i)
      self:render_children(ordered_footnotes[i])
      self.out('</li>\n')
    end
    self.out('</ol>\n</section>\n')
  end
end

function Renderer:raw_block(node)
  if node.format == "html" then
    self.out(node.s)  -- no escaping
  end
end

function Renderer:para(node)
  if not self.tight then
    self:render_tag("p", node)
  end
  self:render_children(node)
  if not self.tight then
    self.out("</p>")
  end
  self.out("\n")
end

function Renderer:blockquote(node)
  self:render_tag("blockquote", node)
  self.out("\n")
  self:render_children(node)
  self.out("</blockquote>\n")
end

function Renderer:div(node)
  self:render_tag("div", node)
  self.out("\n")
  self:render_children(node)
  self.out("</div>\n")
end

function Renderer:heading(node)
  self:render_tag("h" .. node.level , node)
  self:render_children(node)
  self.out("</h" .. node.level .. ">\n")
end

function Renderer:thematic_break(node)
  self:render_tag("hr", node)
  self.out("\n")
end

function Renderer:code_block(node)
  self:render_tag("pre", node)
  self.out("<code")
  if node.lang and #node.lang > 0 then
    self.out(" class=\"language-" .. node.lang .. "\"")
  end
  self.out(">")
  self.out(self:escape_html(node.s))
  self.out("</code></pre>\n")
end

function Renderer:table(node)
  self:render_tag("table", node)
  self.out("\n")
  self:render_children(node)
  self.out("</table>\n")
end

function Renderer:row(node)
  self:render_tag("tr", node)
  self.out("\n")
  self:render_children(node)
  self.out("</tr>\n")
end

function Renderer:cell(node)
  local tag
  if node.head then
    tag = "th"
  else
    tag = "td"
  end
  local attr = copy(node.attr)
  if node.align then
    insert_attribute(attr, "style", "text-align: " .. node.align .. ";")
  end
  self:render_tag(tag, {attr = attr})
  self:render_children(node)
  self.out("</" .. tag .. ">\n")
end

function Renderer:caption(node)
  self:render_tag("caption", node)
  self:render_children(node)
  self.out("</caption>\n")
end

function Renderer:list(node)
  local sty = node.list_style
  if sty == "*" or sty == "+" or sty == "-" then
    self:render_tag("ul", node)
    self.out("\n")
    self:render_children(node)
    self.out("</ul>\n")
  elseif sty == "X" then
    local attr = copy(node.attr)
    if attr.class then
      attr.class = "task-list " .. attr.class
    else
      insert_attribute(attr, "class", "task-list")
    end
    self:render_tag("ul", {attr = attr})
    self.out("\n")
    self:render_children(node)
    self.out("</ul>\n")
  elseif sty == ":" then
    self:render_tag("dl", node)
    self.out("\n")
    self:render_children(node)
    self.out("</dl>\n")
  else
    self.out("<ol")
    if node.start and node.start > 1 then
      self.out(" start=\"" .. node.start .. "\"")
    end
    local list_type = gsub(node.list_style, "%p", "")
    if list_type ~= "1" then
      self.out(" type=\"" .. list_type .. "\"")
    end
    self:render_attrs(node)
    self.out(">\n")
    self:render_children(node)
    self.out("</ol>\n")
  end
end

function Renderer:list_item(node)
  if node.checkbox then
     if node.checkbox == "checked" then
       self.out('<li class="checked">')
     elseif node.checkbox == "unchecked" then
       self.out('<li class="unchecked">')
     end
  else
    self:render_tag("li", node)
  end
  self.out("\n")
  self:render_children(node)
  self.out("</li>\n")
end

function Renderer:term(node)
  self:render_tag("dt", node)
  self:render_children(node)
  self.out("</dt>\n")
end

function Renderer:definition(node)
  self:render_tag("dd", node)
  self.out("\n")
  self:render_children(node)
  self.out("</dd>\n")
end

function Renderer:definition_list_item(node)
  self:render_children(node)
end

function Renderer:reference_definition()
end

function Renderer:footnote_reference(node)
  local label = node.s
  local index = self.footnote_index[label]
  if not index then
    index = self.next_footnote_index
    self.footnote_index[label] = index
    self.next_footnote_index = self.next_footnote_index + 1
  end
  self.out(format('<a href="#fn%d" role="doc-noteref"><sup>%d</sup></a>',
              index, index))
end

function Renderer:raw_inline(node)
  if node.format == "html" then
    self.out(node.s)  -- no escaping
  end
end

function Renderer:str(node)
  -- add a span, if needed, to contain attribute on a bare string:
  if node.attr then
    self:render_tag("span", node)
    self.out(self:escape_html(node.s))
    self.out("</span>")
  else
    self.out(self:escape_html(node.s))
  end
end

function Renderer:softbreak()
  self.out("\n")
end

function Renderer:hardbreak()
  self.out("<br>\n")
end

function Renderer:nbsp()
  self.out("&nbsp;")
end

function Renderer:verbatim(node)
  self:render_tag("code", node)
  self.out(self:escape_html(node.s))
  self.out("</code>")
end

function Renderer:link(node)
  local attrs = {}
  if node.reference then
    local ref = self.references[node.reference]
    if ref then
      if ref.attributes then
        attrs = copy(ref.attributes)
      end
      insert_attribute(attrs, "href", ref.destination)
    end
  elseif node.destination then
    insert_attribute(attrs, "href", node.destination)
  end
  -- link's attributes override reference's:
  copy_attributes(attrs, node.attr)
  self:render_tag("a", {attr = attrs})
  self:render_children(node)
  self.out("</a>")
end

Renderer.url = Renderer.link

Renderer.email = Renderer.link

function Renderer:image(node)
  local attrs = {}
  local alt_text = to_text(node)
  if #alt_text > 0 then
    insert_attribute(attrs, "alt", to_text(node))
  end
  if node.reference then
    local ref = self.references[node.reference]
    if ref then
      if ref.attributes then
        attrs = copy(ref.attributes)
      end
      insert_attribute(attrs, "src", ref.destination)
    end
  elseif node.destination then
    insert_attribute(attrs, "src", node.destination)
  end
  -- image's attributes override reference's:
  copy_attributes(attrs, node.attr)
  self:render_tag("img", {attr = attrs})
end

function Renderer:span(node)
  self:render_tag("span", node)
  self:render_children(node)
  self.out("</span>")
end

function Renderer:mark(node)
  self:render_tag("mark", node)
  self:render_children(node)
  self.out("</mark>")
end

function Renderer:insert(node)
  self:render_tag("ins", node)
  self:render_children(node)
  self.out("</ins>")
end

function Renderer:delete(node)
  self:render_tag("del", node)
  self:render_children(node)
  self.out("</del>")
end

function Renderer:subscript(node)
  self:render_tag("sub", node)
  self:render_children(node)
  self.out("</sub>")
end

function Renderer:superscript(node)
  self:render_tag("sup", node)
  self:render_children(node)
  self.out("</sup>")
end

function Renderer:emph(node)
  self:render_tag("em", node)
  self:render_children(node)
  self.out("</em>")
end

function Renderer:strong(node)
  self:render_tag("strong", node)
  self:render_children(node)
  self.out("</strong>")
end

function Renderer:double_quoted(node)
  self.out("&ldquo;")
  self:render_children(node)
  self.out("&rdquo;")
end

function Renderer:single_quoted(node)
  self.out("&lsquo;")
  self:render_children(node)
  self.out("&rsquo;")
end

function Renderer:left_double_quote()
  self.out("&ldquo;")
end

function Renderer:right_double_quote()
  self.out("&rdquo;")
end

function Renderer:left_single_quote()
  self.out("&lsquo;")
end

function Renderer:right_single_quote()
  self.out("&rsquo;")
end

function Renderer:ellipses()
  self.out("&hellip;")
end

function Renderer:em_dash()
  self.out("&mdash;")
end

function Renderer:en_dash()
  self.out("&ndash;")
end

function Renderer:emoji(node)
  self.out(node.s or (":" .. node.alias .. ":"))
end

function Renderer:math(node)
  local math_t = "inline"
  if find(node.attr.class, "display") then
    math_t = "display"
  end
  self:render_tag("span", node)
  if math_t == "inline" then
    self.out("\\(")
  else
    self.out("\\[")
  end
  self:render_children(node)
  if math_t == "inline" then
    self.out("\\)")
  else
    self.out("\\]")
  end
  self.out("</span>")
end

return { Renderer = Renderer }

end

package.preload["djot.inline"] = function()
-- this allows the code to work with both lua and luajit:
local unpack = unpack or table.unpack
local match = require("djot.match")
local attributes = require("djot.attributes")
local make_match, unpack_match, matches_pattern =
  match.make_match, match.unpack_match, match.matches_pattern
local find, byte = string.find, string.byte

-- allow up to 3 captures...
local function bounded_find(subj, patt, startpos, endpos)
  local sp,ep,c1,c2,c3 = find(subj, patt, startpos)
  if ep and ep <= endpos then
    return sp,ep,c1,c2,c3
  end
end

local Parser = {}

function Parser:new(subject, opts, warn)
  local state =
    { opts = opts or {}, -- options
      warn = warn or function() end, -- function to issue warnings
      subject = subject, -- text to parse
      matches = {}, -- table pos : (endpos, annotation)
      openers = {}, -- map from closer_type to array of (pos, data) in reverse order
      verbatim = 0, -- parsing verbatim span to be ended by n backticks
      verbatim_type = nil, -- whether verbatim is math or regular
      destination = false, -- parsing link destination in ()
      firstpos = 0, -- position of first slice
      lastpos = 0,  -- position of last slice
      allow_attributes = true, -- allow parsing of attributes
      attribute_parser = nil,  -- attribute parser
      attribute_start = nil,  -- start of potential attribute
      attribute_slices = nil, -- slices we've tried to parse as attributes
    }
  setmetatable(state, self)
  self.__index = self
  return state
end

function Parser:add_match(startpos, endpos, annotation)
  self.matches[startpos] = make_match(startpos, endpos, annotation)
end

function Parser:add_opener(name, ...)
  -- 1 = startpos, 2 = endpos, 3 = annotation, 4 = substartpos, 5 = endpos
  if not self.openers[name] then
    self.openers[name] = {}
  end
  table.insert(self.openers[name], {...})
end

function Parser:clear_openers(startpos, endpos)
  -- remove other openers in between the matches
  for _,v in pairs(self.openers) do
    local i = #v
    while v[i] do
      local sp,ep,_,sp2,ep2 = unpack(v[i])
      if sp >= startpos and ep <= endpos then
        v[i] = nil
      elseif (sp2 and sp2 >= startpos) and (ep2 and ep2 <= endpos) then
        v[i][3] = nil
        v[i][4] = nil
        v[i][5] = nil
      else
        break
      end
      i = i - 1
    end
  end
end

function Parser:str_matches(startpos, endpos)
  for i = startpos, endpos do
    local m = self.matches[i]
    if m then
      local sp, ep, annot = unpack_match(m)
      if annot ~= "str" and annot ~= "escape" then
        self.matches[i] = make_match(sp, ep, "str")
      end
    end
  end
end

function Parser.between_matched(c, annotation, defaultmatch, opentest)
  return function(self, pos)
    local defaultmatch = defaultmatch or "str"
    local subject = self.subject
    local can_open = find(subject, "^%S", pos + 1)
    local can_close = find(subject, "^%S", pos - 1)
    local has_open_marker = matches_pattern(self.matches[pos - 1], "^open%_marker")
    local has_close_marker = byte(subject, pos + 1) == 125 -- }
    local endcloser = pos
    local startopener = pos

    if type(opentest) == "function" then
      can_open = can_open and opentest(self, pos)
    end

    -- allow explicit open/close markers to override:
    if has_open_marker then
      can_open = true
      can_close = false
      startopener = pos - 1
    end
    if not has_open_marker and has_close_marker then
      can_close = true
      can_open = false
      endcloser = pos + 1
    end

    if has_open_marker and defaultmatch:match("^right") then
      defaultmatch = defaultmatch:gsub("^right", "left")
    elseif has_close_marker and defaultmatch:match("^left") then
      defaultmatch = defaultmatch:gsub("^left", "right")
    end

    local openers = self.openers[c]
    if can_close and openers and #openers > 0 then
       -- check openers for a match
      local openpos, openposend = unpack(openers[#openers])
      if openposend ~= pos - 1 then -- exclude empty emph
        self:clear_openers(openpos, pos)
        self:add_match(openpos, openposend, "+" .. annotation)
        self:add_match(pos, endcloser, "-" .. annotation)
        return endcloser + 1
      end
    end
    -- if we get here, we didn't match an opener
    if can_open then
      self:add_opener(c, startopener, pos)
      self:add_match(startopener, pos, defaultmatch)
      return pos + 1
    else
      self:add_match(pos, endcloser, defaultmatch)
      return endcloser + 1
    end
  end
end

Parser.matchers = {
    -- 96 = `
    [96] = function(self, pos, endpos)
      local subject = self.subject
      local _, endchar = bounded_find(subject, "^`*", pos, endpos)
      if not endchar then
        return nil
      end
      if find(subject, "^%$%$", pos - 2) then
        self.matches[pos - 2] = nil
        self.matches[pos - 1] = nil
        self:add_match(pos - 2, endchar, "+display_math")
        self.verbatim_type = "display_math"
      elseif find(subject, "^%$", pos - 1) then
        self.matches[pos - 1] = nil
        self:add_match(pos - 1, endchar, "+inline_math")
        self.verbatim_type = "inline_math"
      else
        self:add_match(pos, endchar, "+verbatim")
        self.verbatim_type = "verbatim"
      end
      self.verbatim = endchar - pos + 1
      return endchar + 1
    end,

    -- 92 = \
    [92] = function(self, pos, endpos)
      local subject = self.subject
      local _, endchar = bounded_find(subject, "^[ \t]*\r?\n",  pos + 1, endpos)
      self:add_match(pos, pos, "escape")
      if endchar then
        -- see if there were preceding spaces
        if #self.matches > 0 then
          local sp, ep, annot = unpack_match(self.matches[#self.matches])
          if annot == "str" then
            while subject:byte(ep) == 32 or subject:byte(ep) == 9 do
              ep = ep -1
            end
            if sp == ep then
              self.matches[#self.matches] = nil
            else
              self:add_match(sp, ep, "str")
            end
          end
        end
        self:add_match(pos + 1, endchar, "hardbreak")
        return endchar + 1
      else
        local _, ec = bounded_find(subject, "^[%p ]", pos + 1, endpos)
        if not ec then
          self:add_match(pos, pos, "str")
          return pos + 1
        else
          self:add_match(pos, pos, "escape")
          if find(subject, "^ ", pos + 1) then
            self:add_match(pos + 1, ec, "nbsp")
          else
            self:add_match(pos + 1, ec, "str")
          end
          return ec + 1
        end
      end
    end,

    -- 60 = <
    [60] = function(self, pos, endpos)
      local subject = self.subject
      local starturl, endurl =
              bounded_find(subject, "^%<[^<>%s]+%>", pos, endpos)
      if starturl then
        local is_url = bounded_find(subject, "^%a+:", pos + 1, endurl)
        local is_email = bounded_find(subject, "^[^:]+%@", pos + 1, endurl)
        if is_email then
          self:add_match(starturl, starturl, "+email")
          self:add_match(starturl + 1, endurl - 1, "str")
          self:add_match(endurl, endurl, "-email")
          return endurl + 1
        elseif is_url then
          self:add_match(starturl, starturl, "+url")
          self:add_match(starturl + 1, endurl - 1, "str")
          self:add_match(endurl, endurl, "-url")
          return endurl + 1
        end
      end
    end,

    -- 126 = ~
    [126] = Parser.between_matched('~', 'subscript'),

    -- 94 = ^
    [94] = Parser.between_matched('^', 'superscript'),

    -- 91 = [
    [91] = function(self, pos, endpos)
      local sp, ep = bounded_find(self.subject, "^%^([^]]+)%]", pos + 1, endpos)
      if sp then -- footnote ref
        self:add_match(pos, ep, "footnote_reference")
        return ep + 1
      else
        self:add_opener("[", pos, pos)
        self:add_match(pos, pos, "str")
        return pos + 1
      end
    end,

    -- 93 = ]
    [93] = function(self, pos, endpos)
      local openers = self.openers["["]
      local subject = self.subject
      if openers and #openers > 0 then
        local opener = openers[#openers]
        if opener[3] == "reference_link" then
          -- found a reference link
          -- add the matches
          local is_image = bounded_find(subject, "^!", opener[1] - 1, endpos)
                  and not bounded_find(subject, "^[\\]", opener[1] - 2, endpos)
          if is_image then
            self:add_match(opener[1] - 1, opener[1] - 1, "image_marker")
            self:add_match(opener[1], opener[2], "+imagetext")
            self:add_match(opener[4], opener[5], "-imagetext")
          else
            self:add_match(opener[1], opener[2], "+linktext")
            self:add_match(opener[4], opener[5], "-linktext")
          end
          self:add_match(opener[5], opener[5], "+reference")
          self:add_match(pos, pos, "-reference")
          -- convert all matches to str
          self:str_matches(opener[5] + 1, pos - 1)
          -- remove from openers
          self:clear_openers(opener[1], pos)
          return pos + 1
        elseif bounded_find(subject, "^%[", pos + 1, endpos) then
          opener[3] = "reference_link"
          opener[4] = pos  -- intermediate ]
          opener[5] = pos + 1  -- intermediate [
          self:add_match(pos, pos + 1, "str")
          return pos + 2
        elseif bounded_find(subject, "^%(", pos + 1, endpos) then
          self.openers["("] = {} -- clear ( openers
          opener[3] = "explicit_link"
          opener[4] = pos  -- intermediate ]
          opener[5] = pos + 1  -- intermediate (
          self.destination = true
          self:add_match(pos, pos + 1, "str")
          return pos + 2
        elseif bounded_find(subject, "^%{", pos + 1, endpos) then
          -- assume this is attributes, bracketed span
          self:add_match(opener[1], opener[2], "+span")
          self:add_match(pos, pos, "-span")
          self:clear_openers(opener[1], pos)
          return pos + 1
        end
      end
    end,


    -- 40 = (
    [40] = function(self, pos)
      if not self.destination then return nil end
      self:add_opener("(", pos, pos)
      self:add_match(pos, pos, "str")
      return pos + 1
    end,

    -- 41 = )
    [41] = function(self, pos, endpos)
      if not self.destination then return nil end
      local parens = self.openers["("]
      if parens and #parens > 0 and parens[#parens][1] then
        parens[#parens] = nil -- clear opener
        self:add_match(pos, pos, "str")
        return pos + 1
      else
        local subject = self.subject
        local openers = self.openers["["]
        if openers and #openers > 0
            and openers[#openers][3] == "explicit_link" then
          local opener = openers[#openers]
          local startdest, enddest = opener[5], pos
          -- we have inline link
          local is_image = bounded_find(subject, "^!", opener[1] - 1, endpos)
                 and not bounded_find(subject, "^[\\]", opener[1] - 2, endpos)
          if is_image then
            self:add_match(opener[1] - 1, opener[1] - 1, "image_marker")
            self:add_match(opener[1], opener[2], "+imagetext")
            self:add_match(opener[4], opener[4], "-imagetext")
          else
            self:add_match(opener[1], opener[2], "+linktext")
            self:add_match(opener[4], opener[4], "-linktext")
          end
          self:add_match(startdest, startdest, "+destination")
          self:add_match(enddest, enddest, "-destination")
          self.destination = false
          -- convert all matches to str
          self:str_matches(opener[5] + 1, pos - 1)
          -- remove from openers
          self:clear_openers(opener[2], pos)
          return enddest + 1
        end
      end
    end,

    -- 95 = _
    [95] = Parser.between_matched('_', 'emph'),

    -- 42 = *
    [42] = Parser.between_matched('*', 'strong'),

    -- 123 = {
    [123] = function(self, pos, endpos)
      if bounded_find(self.subject, "^[_*~^+='\"-]", pos + 1, endpos) then
        self:add_match(pos, pos, "open_marker")
        return pos + 1
      elseif self.allow_attributes then
        self.attribute_parser = attributes.AttributeParser:new(self.subject)
        self.attribute_start = pos
        self.attribute_slices = {}
        return pos
      else
        self:add_match(pos, pos, "str")
        return pos + 1
      end
    end,

    -- 58 = :
    [58] = function(self, pos, endpos)
      local sp, ep = bounded_find(self.subject, "^%:[%w_+-]+%:", pos, endpos)
      if sp then
        self:add_match(sp, ep, "emoji")
        return ep + 1
      else
        self:add_match(pos, pos, "str")
        return pos + 1
      end
    end,

    -- 43 = +
    [43] = Parser.between_matched("+", "insert", "str",
                           function(self, pos)
                             return find(self.subject, "^%{", pos - 1) or
                                    find(self.subject, "^%}", pos + 1)
                           end),

    -- 61 = =
    [61] = Parser.between_matched("=", "mark", "str",
                           function(self, pos)
                             return find(self.subject, "^%{", pos - 1) or
                                    find(self.subject, "^%}", pos + 1)
                           end),

    -- 39 = '
    [39] = Parser.between_matched("'", "single_quoted", "right_single_quote",
                           function(self, pos) -- test to open
                             return pos == 1 or
                               find(self.subject, "^[%s\"'-([]", pos - 1)
                             end),

    -- 34 = "
    [34] = Parser.between_matched('"', "double_quoted", "left_double_quote"),

    -- 45 = -
    [45] = function(self, pos, endpos)
      local subject = self.subject
      local _, ep = find(subject, "^%-*", pos)
      local hyphens
      if endpos < ep then
        hyphens = 1 + endpos - pos
      else
        hyphens = 1 + ep - pos
      end
      if byte(subject, ep + 1) == 125 then -- }
        hyphens = hyphens - 1 -- last hyphen is close del
      end
      if byte(subject, pos - 1) == 123 or byte(subject, pos + 1) == 125 then
        return Parser.between_matched("-", "delete")(self, pos, endpos)
      end
      -- Try to construct a homogeneous sequence of dashes
      local all_em = hyphens % 3 == 0
      local all_en = hyphens % 2 == 0
      while hyphens > 0 do
        if all_em then
          self:add_match(pos, pos + 2, "em_dash")
          pos = pos + 3
          hyphens = hyphens - 3
        elseif all_en then
          self:add_match(pos, pos + 1, "en_dash")
          pos = pos + 2
          hyphens = hyphens - 2
        elseif hyphens >= 3 and (hyphens % 2 ~= 0 or hyphens > 4) then
          self:add_match(pos, pos + 2, "em_dash")
          pos = pos + 3
          hyphens = hyphens - 3
        elseif hyphens >= 2 then
          self:add_match(pos, pos + 1, "en_dash")
          pos = pos + 2
          hyphens = hyphens - 2
        else
          self:add_match(pos, pos, "str")
          pos = pos + 1
          hyphens = hyphens - 1
        end
      end
      return pos
    end,

    -- 46 = .
    [46] = function(self, pos, endpos)
      if bounded_find(self.subject, "^%.%.", pos + 1, endpos) then
        self:add_match(pos, pos +2, "ellipses")
        return pos + 3
      end
    end
  }

function Parser:single_char(pos)
  self:add_match(pos, pos, "str")
  return pos + 1
end

-- Feed a slice to the parser, updating state.
function Parser:feed(spos, endpos)
  local special = "[][\\`{}_*()!<>~^:=+$\r\n'\".-]"
  local subject = self.subject
  local matchers = self.matchers
  local pos
  if self.firstpos == 0 or spos < self.firstpos then
    self.firstpos = spos
  end
  if self.lastpos == 0 or endpos > self.lastpos then
    self.lastpos = endpos
  end
  pos = spos
  while pos <= endpos do
    if self.attribute_parser then
      local sp = pos
      local ep2 = bounded_find(subject, special, pos, endpos) or endpos
      local status, ep = self.attribute_parser:feed(sp, ep2)
      if status == "done" then
        local attribute_start = self.attribute_start
        -- add attribute matches
        self:add_match(attribute_start, attribute_start, "+attributes")
        self:add_match(ep, ep, "-attributes")
        local attr_matches = self.attribute_parser:get_matches()
        -- add attribute matches
        for i=1,#attr_matches do
          self:add_match(unpack_match(attr_matches[i]))
        end
        -- restore state to prior to adding attribute parser:
        self.attribute_parser = nil
        self.attribute_start = nil
        self.attribute_slices = nil
        pos = ep + 1
      elseif status == "fail" then
        -- backtrack:
        local slices = self.attribute_slices
        self.allow_attributes = false
        self.attribute_parser = nil
        self.attribute_start = nil
        for i=1,#slices do
          self:feed(unpack(slices[i]))
        end
        self.allow_attributes = true
        self.slices = nil
        pos = sp
      elseif status == "continue" then
        self.attribute_slices[#self.attribute_slices + 1] = {sp,ep}
        pos = ep + 1
      end
    else
      -- find next interesting character:
      local newpos = bounded_find(subject, special, pos, endpos) or endpos + 1
      if newpos > pos then
        self:add_match(pos, newpos - 1, "str")
        pos = newpos
        if pos > endpos then
          break -- otherwise, fall through:
        end
      end
      -- if we get here, then newpos = pos,
      -- i.e. we have something interesting at pos
      local c = byte(subject, pos)

      if c == 13 or c == 10 then -- cr or lf
        if c == 13 and bounded_find(subject, "^[%n]", pos + 1, endpos) then
          self:add_match(pos, pos + 1, "softbreak")
          pos = pos + 2
        else
          self:add_match(pos, pos, "softbreak")
          pos = pos + 1
        end
      elseif self.verbatim > 0 then
        if c == 96 then
          local _, endchar = bounded_find(subject, "^`+", pos, endpos)
          if endchar and endchar - pos + 1 == self.verbatim then
            -- check for raw attribute
            local sp, ep =
              bounded_find(subject, "^%{%=[^%s{}`]+%}", endchar + 1, endpos)
            if sp and self.verbatim_type == "verbatim" then -- raw
              self:add_match(pos, endchar, "-" .. self.verbatim_type)
              self:add_match(sp, ep, "raw_format")
              pos = ep + 1
            else
              self:add_match(pos, endchar, "-" .. self.verbatim_type)
              pos = endchar + 1
            end
            self.verbatim = 0
            self.verbatim_type = nil
          else
            endchar = endchar or endpos
            self:add_match(pos, endchar, "str")
            pos = endchar + 1
          end
        else
          self:add_match(pos, pos, "str")
          pos = pos + 1
        end
      else
        pos = (matchers[c] and matchers[c](self, pos, endpos))
               or self:single_char(pos)
      end
    end
  end
end

  -- Return true if we're parsing verbatim content.
function Parser:in_verbatim()
  return self.verbatim > 0
end

function Parser:get_matches()
  local sorted = {}
  local subject = self.subject
  local lastsp, lastep, lastannot
  for i=self.firstpos, self.lastpos do
    if self.matches[i] then
      local sp, ep, annot = unpack_match(self.matches[i])
      if annot == "str" and lastannot == "str" and lastep + 1 == sp then
          -- consolidate adjacent strs
        sorted[#sorted] = make_match(lastsp, ep, annot)
        lastsp, lastep, lastannot = lastsp, ep, annot
      else
        sorted[#sorted + 1] = self.matches[i]
        lastsp, lastep, lastannot = sp, ep, annot
      end
    end
  end
  if #sorted > 0 then
    local last = sorted[#sorted]
    local startpos, endpos, annot = unpack_match(last)
    -- remove final softbreak
    if annot == "softbreak" then
      sorted[#sorted] = nil
      last = sorted[#sorted]
      startpos, endpos, annot = unpack_match(last)
    end
    -- remove trailing spaces
    if annot == "str" and byte(subject, endpos) == 32 then
      while endpos > startpos and byte(subject, endpos) == 32 do
        endpos = endpos - 1
      end
      sorted[#sorted] = make_match(startpos, endpos, annot)
    end
    if self.verbatim > 0 then -- unclosed verbatim
      self.warn({ message = "Unclosed verbatim", pos = startpos })
      sorted[#sorted + 1] = make_match(startpos, endpos,
                                       "-" .. self.verbatim_type)
    end
  end
  return sorted
end

return { Parser = Parser }

end

package.preload["djot.json"] = function()
-- Modified from
-- json.lua
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--
-- Modifications to the original code:
--
-- * Removed JSON decoding code
-- * Add code to ignore keys beginning with '_'
-- * Revise short names used in internal AST to longer descriptive names,
--   e.g. c -> children.

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end

local longnames =
  { c = "children",
    t = "tag",
    s = "text" }

local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      -- Added by JGM:
      if string.sub(k,1,1) ~= "_" then
        local key = longnames[k] or k
        table.insert(res, encode(key, stack) .. ":" .. encode(v, stack))
      end
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end

return json

end

package.preload["djot.match"] = function()
local make_match, unpack_match
local unpack = unpack or table.unpack

if jit or not string.pack then
  -- for luajit or lua 5.1, we don't have string.pack/unpack, so we use arrays.
  -- This is faster than using ffi to pack things in C structs.

  make_match = function(startpos, endpos, annotation)
    return {startpos, endpos, annotation}
  end

  unpack_match = unpack

else
  -- for standard lua >= 5.2, we use string.pack/unpack which gives a
  -- more memory-efficient representation than arrays.

  make_match = function(startpos, endpos, annotation)
    return string.pack("=I4I4z", startpos, endpos, annotation)
  end

  unpack_match = function(match)
    local startpos, endpos, annotation = string.unpack("=I4I4z", match)
    return startpos, endpos, annotation
  end
end

local get_length = function(match)
  local startpos, endpos = unpack_match(match)
  return 1 + (endpos - startpos)
end

local format_match = function(match)
  local startpos, endpos, annotation = unpack_match(match)
  return string.format("%-s %d-%d\n", annotation, startpos, endpos)
end

local function matches_pattern(match, patt)
  if match then
    local _, _, annot = unpack_match(match)
    return string.find(annot, patt)
  end
end

return {
  make_match = make_match,
  unpack_match = unpack_match,
  get_length = get_length,
  format_match = format_match,
  matches_pattern = matches_pattern
}

end

local djot = require("djot")
function djot_to_html (input)
    local parser = djot.Parser:new(input)
    parser:parse()
    local html = parser:render_html()
    return html
end
