-- Autogenerated with "go run ./cmd/vendordjot". Do not edit.
-- https://github.com/jgm/djot/blob/main/LICENSE
-- Copyright (C) 2022 John MacFarlane
--
-- Permission is hereby granted, free of charge, to any person obtaining
-- a copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to
-- permit persons to whom the Software is furnished to do so, subject to
-- the following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-- IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-- CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-- TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-- SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
package.preload["djot"] = function()
local block = require("djot.block")
local ast = require("djot.ast")
local html = require("djot.html")
local match = require("djot.match")
local json = require("djot.json")

local unpack_match = match.unpack_match
local format_match = match.format_match

local StringHandle = {}

function StringHandle:new()
  local buffer = {}
  setmetatable(buffer, StringHandle)
  StringHandle.__index = StringHandle
  return buffer
end

function StringHandle:write(s)
  self[#self + 1] = s
end

function StringHandle:flush()
  local result = table.concat(self)
  return result
end

local Parser = block.Parser

function Parser:render_matches(handle, use_json)
  if not handle then
    handle = StringHandle:new()
  end
  local matches = self:get_matches()
  if use_json then
    local formatted_matches = {}
    for i=1,#matches do
      local startpos, endpos, annotation = unpack_match(matches[i])
      formatted_matches[#formatted_matches + 1] =
        { annotation, {startpos, endpos} }
    end
    handle:write(json.encode(formatted_matches) .. "\n")
  else
    for i=1,#matches do
      handle:write(format_match(matches[i]))
    end
  end
  return handle:flush()
end

function Parser:build_ast()
  self.ast = ast.to_ast(self.subject, self.matches, self.opts, self.warn)
end

function Parser:render_ast(handle, use_json)
  if not handle then
    handle = StringHandle:new()
  end
  if not self.ast then
    self:build_ast()
  end
  if use_json then
    handle:write(json.encode(self.ast) .. "\n")
  else
    ast.render(self.ast, handle)
  end
  return handle:flush()
end

function Parser:render_html(handle)
  if not handle then
    handle = StringHandle:new()
  end
  if not self.ast then
    self:build_ast()
  end
  local renderer = html.Renderer:new()
  renderer:render(self.ast, handle)
  return handle:flush()
end

return {
  Parser = Parser
}

end

package.preload["djot.ast"] = function()
local match = require("djot.match")
local emoji -- require this later, only if emoji encountered

local find, lower, sub, gsub, rep, format =
  string.find, string.lower, string.sub, string.gsub, string.rep, string.format

local unpack_match, get_length, matches_pattern =
  match.unpack_match, match.get_length, match.matches_pattern

local function get_string_content(node)
  local buffer = {}
  if node.s then
    buffer[#buffer + 1] = node.s
  elseif node.t == "softbreak" then
    buffer[#buffer + 1] = "\n"
  elseif node.c then
    for i=1, #node.c do
      buffer[#buffer + 1] = get_string_content(node.c[i])
    end
  end
  return table.concat(buffer)
end

local roman_digits = {
  i = 1,
  v = 5,
  x = 10,
  l = 50,
  c = 100,
  d = 500,
  m = 1000 }

local function roman_to_number(s)
  -- go backwards through the digits
  local total = 0
  local prevdigit = 0
  local i=#s
  while i > 0 do
    local c = lower(sub(s,i,i))
    local n = roman_digits[c]
    if n < prevdigit then -- e.g. ix
      total = total - n
    else
      total = total + n
    end
    assert(n ~= nil, "Encountered bad character in roman numeral " .. s)
    prevdigit = n
    i = i - 1
  end
  return total
end

local function get_list_start(marker, style)
  local numtype = string.gsub(style, "%p", "")
  local s = string.gsub(marker, "%p", "")
  if numtype == "1" then
    return tonumber(s)
  elseif numtype == "A" then
    return (string.byte(s) - string.byte("A") + 1)
  elseif numtype == "a" then
    return (string.byte(s) - string.byte("a") + 1)
  elseif numtype == "I" then
    return roman_to_number(s)
  elseif numtype == "i" then
    return roman_to_number(s)
  elseif numtype == "" then
    return nil
  end
end

local ignorable = {
  image_marker = true,
  escape = true,
  blankline = true,
  checkbox_checked = true,
  checkbox_unchecked = true
}

local function is_tight(matches, startidx, endidx, is_last_item)
  -- see if there are any blank lines between blocks in a list item.
  local blanklines = 0
  -- we don't care about blank lines at very end of list
  for i=startidx, endidx do
    local _, _, x = unpack_match(matches[i])
    if x == "blankline" then
      if not ((matches_pattern(matches[i+1], "%+list_item") or
              (matches_pattern(matches[i+1], "%-list_item") and
               (is_last_item or
                 matches_pattern(matches[i+2], "%-list_item"))))) then
        -- don't count blank lines before list starts
        -- don't count blank lines at end of nested lists or end of last item
        blanklines = blanklines + 1
      end
    end
  end
  return (blanklines == 0)
end

local function insert_attribute(attr, key, val)
  if not attr._keys then
    attr._keys = {}
  end
  local function add_key(k)
    local keys = attr._keys
    for i=1,#keys do
      if keys[i] == k then
        return
      end
    end
    keys[#keys + 1] = k
  end
  -- _keys records order of key insertion for deterministic output
  if key == "id" then
    attr.id = val
    add_key("id")
  elseif key == "class" then
    if attr.class then
      attr.class =
        attr.class .. " " .. val
    else
      attr.class = val
      add_key("class")
    end
  else
    attr[key] = val
    add_key(key)
  end
end

local function copy_attributes(target, source)
  if source then
    for k,v in pairs(source) do
      if k ~= "_keys" then
        insert_attribute(target, k, v)
      end
    end
  end
end

local function insert_attributes(targetnode, cs)
  targetnode.attr = targetnode.attr or {_keys = {}}
  local i=1
  while i <= #cs do
    local x, y = cs[i].t, cs[i].s
    if x == "id" or x == "class" then
      insert_attribute(targetnode.attr, x, y)
    elseif x == "key" then
      local valnode = cs[i + 1]
      if valnode.t == "value" then
        -- resolve backslash escapes
        insert_attribute(targetnode.attr, y, valnode.s:gsub("\\(%p)", "%1"))
      end
      i = i + 1
    end
    i = i + 1
  end
end

local function make_definition_list_item(result)
  result.t = "definition_list_item"
  if result.c and #result.c > 0 and
     result.c[1].t == "para" then
    result.c[1].t = "term"
  else
    table.insert(result.c, 1, {t = "term", c = {}})
  end
  if result.c[2] then
    local defn = {t = "definition", c = {}}
    for i=2,#result.c do
      defn.c[#defn.c + 1] = result.c[i]
      result.c[i] = nil
    end
    result.c[2] = defn
  end
end

-- create an abstract syntax tree based on an event
-- stream and references
local function to_ast(subject, matches, options, warn)
  if not options then
    options = {}
  end
  if not warn then
    warn = function() end
  end
  local idx = 1
  local matcheslen = #matches
  local sourcepos = options.sourcepos
  local references = {}
  local footnotes = {}
  local identifiers = {} -- identifiers used (to ensure uniqueness)

  -- generate auto identifier for heading
  local function get_identifier(s)
    local base = s:gsub("[][~!@#$%^&*(){}`,.<>\\|=+/?]","")
                  :gsub("^%s+",""):gsub("%s+$","")
                  :gsub("%s+","-")
    local i = 0
    local ident = base
    -- generate unique id
    while identifiers[ident] do
      i = i + 1
      ident = base .. tostring(i)
    end
    identifiers[ident] = true
    return ident
  end

  local function set_checkbox(node, startidx)
    -- determine if checked or unchecked
    local _,_,ann = unpack_match(matches[startidx + 1])
    if ann == "checkbox_checked" then
      node.checkbox = "checked"
    elseif ann == "checkbox_unchecked" then
      node.checkbox = "unchecked"
    end
  end

  local function get_node(maintag)
    local node = { t = maintag, c = {} }
    local stopper
    local block_attributes = nil
    if maintag then
      -- strip off data (e.g. for list_items)
      stopper = "^%-" .. gsub(maintag, "%[.*$", "")
    end
    while idx <= matcheslen do
      local matched = matches[idx]
      local startpos, endpos, annot = unpack_match(matched)
      if stopper and find(annot, stopper) then
        idx = idx + 1
        return node
      else
        local mod, tag = string.match(annot, "^([-+]?)(.*)")
        if ignorable[tag] then
          idx = idx + 1 -- skip
        elseif mod == "+" then -- open
          local startidx = idx
          idx = idx + 1
          local result = get_node(tag)
          if tag == "list_item[X]" then
            set_checkbox(result, startidx)
          end
          local _, finalpos = unpack_match(matches[idx - 1])
          if sourcepos then
            result.pos = {startpos, finalpos}
          end
          if block_attributes and tag ~= "block_attributes" then
            for i=1,#block_attributes do
              insert_attributes(result, block_attributes[i])
            end
            if result.attr and result.attr.id then
              identifiers[result.attr.id] = true
            end
            block_attributes = nil
            -- TODO where do we ever set this to true??
          end
          if tag == "verbatim" then
            local s = get_string_content(result)
            -- trim space next to ` at beginning or end
            if find(s, "^ +`") then
              s = s:sub(2)
            end
            if find(s, "` +$") then
              s = s:sub(1, #s - 1)
            end
            result = {t = "verbatim", s = s}
            -- check for raw_format, which makes this a raw node
            local sp,ep,ann = unpack_match(matches[idx])
            if ann == "raw_format" then
              local str = get_string_content(result)
              result.t = "raw_inline"
              result.s = str
              result.format = sub(subject, sp + 2, ep - 1)
              idx = idx + 1 -- skip the raw_format
            end
          elseif tag == "caption" then
            local prevnode = node.c[#node.c]
            if prevnode.t == "table" then
              -- move caption in table node
              table.insert(prevnode.c, 1, result)
              result = nil
            end
          elseif tag == "reference_definition" then
            local dest = ""
            local key
            for i=1,#result.c do
              if result.c[i].t == "reference_key" then
                key = result.c[i].s
              end
              if result.c[i].t == "reference_value" then
                dest = dest .. result.c[i].s
              end
            end
            references[key] = { destination = dest }
             if result.attr then
               references[key].attributes = result.attr
             end
          elseif tag == "footnote" then
            local label
            if result.c[1].t == "note_label" then
              label = result.c[1].s
              table.remove(result.c, 1)
            end
            if label then
              footnotes[label] = result
            end
            result = nil
          elseif tag == "inline_math" then
            result.t = "math"
            result.attr = {class = "math inline", _keys={"class"}}
          elseif tag == "display_math" then
            result.t = "math"
            result.attr = {class = "math display", _keys={"class"}}
          elseif tag == "url" then
            result.t = "url"
            result.destination = get_string_content(result)
          elseif tag == "email" then
            result.t = "email"
            result.destination = "mailto:" .. get_string_content(result)
          elseif tag == "imagetext" or tag == "linktext" then
            -- gobble destination or reference
            local nextmatch = matches[idx]
            local _, _, nextannot = unpack_match(nextmatch)
            if nextannot == "+destination" then
              idx = idx + 1
              local dest = get_node("destination")
              result.destination = get_string_content(dest):gsub("\r?\n", "")
            elseif nextannot == "+reference" then
              idx = idx + 1
              local ref = get_node("reference")
              if ref.t == "reference" and #ref.c > 0 then
                result.reference = get_string_content(ref):gsub("\r?\n", " ")
              else
                result.reference = get_string_content(result):gsub("\r?\n", " ")
              end
            end
            result.t = result.t:gsub("text","")
          elseif tag == "heading" then
            result.level = get_length(matched)
            local heading_str = get_string_content(result)
                                 :gsub("^%s+",""):gsub("%s+$","")
            if not (result.attr and result.attr.id) then
              local ident = get_identifier(heading_str)
              insert_attributes(result, {{t = "id", s = ident}})
            end
            -- insert into references unless there's a same-named one already:
            if not references[heading_str] then
              references[heading_str] = {destination = "#" .. result.attr.id}
            end
          elseif tag == "table" then
            -- look for a separator line
            -- if found, make the preceding rows headings
            -- and set attributes for column alignments on the table
            local i=1
            local aligns = {}
            while i <= #result.c do
              local found, align
              if result.c[i].t == "row" then
                local row = result.c[i].c
                for j=1,#row do
                  found, _, align = find(row[j].t, "^separator_(.*)")
                  if not found then
                    break
                  end
                  aligns[j] = align
                end
                if found and #aligns > 0 then
                  -- set previous row to head and adjust aligns
                  local prevrow = result.c[i - 1]
                  if prevrow and prevrow.t == "row" then
                    prevrow.head = true
                    for k=1,#prevrow.c do
                      -- set head on cells too
                      prevrow.c[k].head = true
                      if aligns[k] ~= "default" then
                        prevrow.c[k].align = aligns[k]
                      end
                    end
                  end
                  table.remove(result.c, i) -- remove sep line
                  -- we don't need to increment i because we removed ith elt
                else
                  if #aligns > 0 then
                    for l=1,#result.c[i].c do
                      if aligns[l] ~= "default" then
                        result.c[i].c[l].align = aligns[l]
                      end
                    end
                  end
                  i = i + 1
                end
              end
            end
            result.level = get_length(matched)
          elseif tag == "div" then
            if result.c[1] and result.c[1].t == "class" then
              result.attr = result.attr or {_keys = {}}
              insert_attribute(result.attr, "class", get_string_content(result.c[1]))
              table.remove(result.c, 1)
            end
          elseif tag == "code_block" then
            if result.c[1] then
              if result.c[1].t == "code_language" then
                result.lang = result.c[1].s
                table.remove(result.c, 1)
              elseif result.c[1].t == "raw_format" then
                local fmt = result.c[1].s:sub(2)
                table.remove(result.c, 1)
                result.t = "raw_block"
                result.format = fmt
              end
              result.s = get_string_content(result)
              result.c = nil
            end
          elseif tag == "block_attributes" then
            if block_attributes then
              block_attributes[#block_attributes + 1] = result.c
            else
              block_attributes = {result.c}
            end
            result = nil
          elseif tag == "attributes" then
            -- parse attributes, add to last node
            local prevnode = node.c[#node.c]
            local endswithspace = false
            if type(prevnode) == "table" then
              if prevnode.t == "str" then
                -- split off last consecutive word of string
                -- to which to attach attributes
                local lastwordpos = string.find(prevnode.s, "[^%s]+$")
                if not lastwordpos then
                  endswithspace = true
                elseif lastwordpos > 1 then
                  local newnode = {t = "str",
                                   s = sub(prevnode.s, lastwordpos, -1)}
                  prevnode.s = sub(prevnode.s, 1, lastwordpos - 1)
                  node.c[#node.c + 1] = newnode
                  prevnode = newnode
                end
              end
              if not endswithspace then
                insert_attributes(prevnode, result.c)
              else
                warn({message = "Ignoring unattached attribute", pos = startpos})
              end
            end
            result = nil
          elseif find(tag, "^list_item") then
            local marker = string.match(subject, "^%S+", startpos)
            local styles = {}
            gsub(tag, "%[([^]]*)%]", function(x) styles[#styles + 1] = x end)
            -- create a list node with the consecutive list items
            -- of the same kind
            local list = {t = "list", c = {result}}
            -- put the attributes from the first item on the list itself:
            list.attr = result.attr
            result.attr = nil
            result.t = "list_item"
            if marker == ":" then
              make_definition_list_item(result)
            end
            if sourcepos then
              list.pos = {result.pos[1], result.pos[2]}
            end
            -- now get remaining items
            local nextitem = matches[idx]
            while nextitem do
              local sp, _, ann = unpack_match(nextitem)
              if not find(ann, "^%+list_item") then
                break
              end
              -- check which of the styles this item matches
              local newstyles = {}
              gsub(ann, "%[([^]]*)%]",
                          function(x) newstyles[x] = true end)
              local matched_styles = {}
              for _,x in ipairs(styles) do
                if newstyles[x] then
                  matched_styles[#matched_styles + 1] = x
                end
              end
              if #styles > 0 and #matched_styles == 0 then
                break  -- does not match any styles
              end
              styles = matched_styles
              -- at this point styles contains the styles that match all items
              -- in the list so far...

              if #list.c > 0 then
                list.c[#list.c].tight =
                  is_tight(matches, startidx, idx - 1, false)
              end
              startidx = idx
              idx = idx + 1
              local item = get_node(tag)
              if tag == "list_item[X]" then
                set_checkbox(item, startidx)
              end
              item.t = "list_item"
              if sourcepos then
                item.pos = {sp, finalpos}
                list.pos[2] = item.pos[2]
              end
              if marker == ":" then
                make_definition_list_item(item)
              end
              list.c[#list.c + 1] = item
              nextitem = matches[idx]
            end
            if #list.c > 0 then
              list.c[#list.c].tight =
                is_tight(matches, startidx, idx - 1, true)
            end
            local tight = true
            for i=1,#list.c do
              tight = tight and list.c[i].tight
              list.c[i].tight = nil
            end
            list.list_style = styles[1] -- resolve, if still ambiguous
            list.tight = tight
            list.start = get_list_start(marker, list.list_style)
            result = list
          end
          node.c[#node.c + 1] = result
        elseif mod == "-" then -- close
          assert(false, "unmatched " .. annot .. " encountered at byte " ..
                   startpos)
          idx = idx + 1
          return nil
        elseif tag == "reference_key" then
          local key = sub(subject, startpos + 1, endpos - 1)
          local result = {t = "reference_key", s = key}
          idx = idx + 1
          node.c[#node.c + 1] = result
        elseif tag == "reference_value" then
          local val = sub(subject, startpos, endpos)
          local result = {t = "reference_value", s = val}
          idx = idx + 1
          node.c[#node.c + 1] = result
        else -- leaf
          local result
          if tag == "softbreak" then
            result = {t = tag}
          elseif tag == "footnote_reference" then
            result = {t = tag, s = sub(subject, startpos + 2, endpos - 1)}
          elseif tag == "emoji" then
            result = {t = "emoji",
                      alias = sub(subject, startpos + 1, endpos - 1)}
            emoji = require("djot.emoji")
            local found = emoji[result.alias]
            result.s = found
          else
            result = {t = tag, s = sub(subject, startpos, endpos)}
          end
          if sourcepos then
            result.pos = {startpos, endpos}
          end
          if block_attributes then
            for i=1,#block_attributes do
              insert_attributes(result, block_attributes[i])
            end
            block_attributes = nil
          end
          idx = idx + 1
          if result then
            node.c[#node.c + 1] = result
          end
        end
      end
    end
    return node
  end

  local doc = get_node("doc")
  doc.references = references
  doc.footnotes = footnotes
  return doc
end

local function render_node(node, handle, indent)
  indent = indent or 0
  handle:write(rep(" ", indent))
  if node.t then
    handle:write(node.t)
    if node.pos then
      handle:write(format(" (%d-%d)", node.pos[1], node.pos[2]))
    end
    for k,v in pairs(node) do
      if type(k) == "string" and k ~= "c" and
          k ~= "t" and k ~= "pos" and k ~= "attr"  and
          k ~= "references" and k ~= "footnotes" then
        handle:write(format(" %s=%q", k, tostring(v)))
      end
    end
    if node.attr then
      local keys = node.attr._keys
      for j=1,#keys do
        local k = keys[j]
        handle:write(format(" %s=%q", k, node.attr[k]))
      end
    end
  else
    io.stderr:write("Encountered node without tag:\n" ..
                      require'inspect'(node))
    os.exit(1)
  end
  handle:write("\n")
  if node.c then
    for _,v in ipairs(node.c) do
      render_node(v, handle, indent + 2)
    end
  end
end

local function render(doc, handle)
  render_node(doc, handle, 0)
  if doc.references then
    handle:write("references = {\n")
    for k,v in pairs(doc.references) do
      handle:write(format("  [%q] = %q,\n", k, v.destination))
    end
    handle:write("}\n")
  end
  if doc.footnotes then
    handle:write("footnotes = {\n")
    for k,v in pairs(doc.footnotes) do
      handle:write(format("  [%q] =\n", k))
      render_node(v, handle, 4)
    end
    handle:write("}\n")
  end
end

return { to_ast = to_ast,
         render = render,
         insert_attribute = insert_attribute,
         copy_attributes = copy_attributes }

end

package.preload["djot.attributes"] = function()
local find, sub = string.find, string.sub
local match = require("djot.match")
local make_match = match.make_match

-- parser for attributes
-- attributes { id = "foo", class = "bar baz",
--              key1 = "val1", key2 = "val2" }
-- syntax:
--
-- attributes <- '{' whitespace* attribute (whitespace attribute)* whitespace* '}'
-- attribute <- identifier | class | keyval
-- identifier <- '#' name
-- class <- '.' name
-- name <- (nonspace, nonpunctuation other than ':', '_', '-')+
-- keyval <- key '=' val
-- key <- (ASCII_ALPHANUM | ':' | '_' | '-')+
-- val <- bareval | quotedval
-- bareval <- (ASCII_ALPHANUM | ':' | '_' | '-')+
-- quotedval <- '"' ([^"] | '\"') '"'

-- states:
local SCANNING = 0
local SCANNING_ID = 1
local SCANNING_CLASS= 2
local SCANNING_KEY = 3
local SCANNING_VALUE = 4
local SCANNING_BARE_VALUE = 5
local SCANNING_QUOTED_VALUE = 6
local SCANNING_ESCAPED = 7
local SCANNING_COMMENT = 8
local FAIL = 9
local DONE = 10
local START = 11

local AttributeParser = {}

local handlers = {}

handlers[START] = function(self, pos)
  if find(self.subject, "^{", pos) then
    return SCANNING
  else
    return FAIL
  end
end

handlers[FAIL] = function(_self, _pos)
  return FAIL
end

handlers[DONE] = function(_self, _pos)
  return DONE
end

handlers[SCANNING] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == ' ' or c == '\t' or c == '\n' or c == '\r' then
    return SCANNING
  elseif c == '}' then
    return DONE
  elseif c == '#' then
    self.begin = pos
    return SCANNING_ID
  elseif c == '%' then
    self.begin = pos
    return SCANNING_COMMENT
  elseif c == '.' then
    self.begin = pos
    return SCANNING_CLASS
  elseif find(c, "^[%a%d_:-]") then
    self.begin = pos
    return SCANNING_KEY
  else -- TODO
    return FAIL
  end
end

handlers[SCANNING_COMMENT] = function(self, pos)
  if sub(self.subject, pos, pos) == "%" then
    return SCANNING
  else
    return SCANNING_COMMENT
  end
end

handlers[SCANNING_ID] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if find(c, "^[^%s%p]") or c == "_" or c == "-" or c == ":" then
    return SCANNING_ID
  elseif c == '}' then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "id")
    end
    self.begin = nil
    return DONE
  elseif find(c, "^%s") then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "id")
    end
    self.begin = nil
    return SCANNING
  else
    return FAIL
  end
end

handlers[SCANNING_CLASS] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if find(c, "^[^%s%p]") or c == "_" or c == "-" or c == ":" then
    return SCANNING_CLASS
  elseif c == '}' then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "class")
    end
    self.begin = nil
    return DONE
  elseif find(c, "^%s") then
    if self.lastpos > self.begin then
      self:add_match(self.begin + 1, self.lastpos, "class")
    end
    self.begin = nil
    return SCANNING
  else
    return FAIL
  end
end

handlers[SCANNING_KEY] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == "=" then
    self:add_match(self.begin, self.lastpos, "key")
    self.begin = nil
    return SCANNING_VALUE
  elseif find(c, "^[%a%d_:-]") then
    return SCANNING_KEY
  else
    return FAIL
  end
end

handlers[SCANNING_VALUE] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == '"' then
    self.begin = pos
    return SCANNING_QUOTED_VALUE
  elseif find(c, "^[%a%d_:-]") then
    self.begin = pos
    return SCANNING_BARE_VALUE
  else
    return FAIL
  end
end

handlers[SCANNING_BARE_VALUE] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if find(c, "^[%a%d_:-]") then
    return SCANNING_BARE_VALUE
  elseif c == '}' then
    self:add_match(self.begin, self.lastpos, "value")
    self.begin = nil
    return DONE
  elseif find(c, "^%s") then
    self:add_match(self.begin, self.lastpos, "value")
    self.begin = nil
    return SCANNING
  else
    return FAIL
  end
end

handlers[SCANNING_ESCAPED] = function(_self, _pos)
  return SCANNING_QUOTED_VALUE
end

handlers[SCANNING_QUOTED_VALUE] = function(self, pos)
  local c = sub(self.subject, pos, pos)
  if c == '"' then
    self:add_match(self.begin + 1, self.lastpos, "value")
    self.begin = nil
    return SCANNING
  elseif c == "\\" then
    return SCANNING_ESCAPED
  elseif c == "{" or c == "}" then
    return FAIL
  elseif c == "\n" then
    self:add_match(self.begin + 1, self.lastpos, "value")
    return SCANNING_QUOTED_VALUE
  else
    return SCANNING_QUOTED_VALUE
  end
end

function AttributeParser:new(subject)
  local state = {
    subject = subject,
    state = START,
    begin = nil,
    failed = nil,
    lastpos = nil,
    matches = {}
    }
  setmetatable(state, self)
  self.__index = self
  return state
end

function AttributeParser:add_match(sp, ep, tag)
  self.matches[#self.matches + 1] = make_match(sp, ep, tag)
end

function AttributeParser:get_matches()
  return self.matches
end

-- Feed parser a slice of text from the subject, between
-- startpos and endpos inclusive.  Return status, position,
-- where status is either "done" (position should point to
-- final '}'), "fail" (position should point to first character
-- that could not be parsed), or "continue" (position should
-- point to last character parsed).
function AttributeParser:feed(startpos, endpos)
  local pos = startpos
  while pos <= endpos do
    self.state = handlers[self.state](self, pos)
    if self.state == DONE then
      return "done", pos
    elseif self.state == FAIL then
      self.lastpos = pos
      return "fail", pos
    else
      self.lastpos = pos
      pos = pos + 1
    end
  end
  return "continue", endpos
end

--[[
local test = function()
  local parser = AttributeParser:new("{a=b #ident\n.class\nkey=val1\n .class key2=\"val two \\\" ok\" x")
  local x,y,z = parser:feed(1,56)
  print(require'inspect'(parser:get_matches{}))
end

test()
--]]

return { AttributeParser = AttributeParser }

end

package.preload["djot.block"] = function()
local inline = require("djot.inline")
local attributes = require("djot.attributes")
local match = require("djot.match")
local make_match, unpack_match = match.make_match, match.unpack_match
local unpack = unpack or table.unpack
local find, sub, byte = string.find, string.sub, string.byte

local Container = {}

function Container:new(spec, data)
  self = spec
  local contents = {}
  setmetatable(contents, self)
  self.__index = self
  if data then
    for k,v in pairs(data) do
      contents[k] = v
    end
  end
  return contents
end

local function get_list_style(marker)
  if marker == "+" or marker == "-" or marker == "*" or marker == ":" then
    return marker
  elseif find(marker, "^[+*-] %[[Xx ]%]") then
    return "X" -- task list
  elseif find(marker, "^%[[Xx ]%]") then
    return "X"
  elseif find(marker, "^[(]?%d+[).]") then
    return (marker:gsub("%d+","1"))
  -- in ambiguous cases we return two values
  elseif find(marker, "^[(]?[ivxlcdm][).]") then
    return (marker:gsub("%a+", "a")), (marker:gsub("%a+", "i"))
  elseif find(marker, "^[(]?[IVXLCDM][).]") then
    return (marker:gsub("%a+", "A")), (marker:gsub("%a+", "I"))
  elseif find(marker, "^[(]?%l[).]") then
    return (marker:gsub("%l", "a"))
  elseif find(marker, "^[(]?%u[).]") then
    return (marker:gsub("%u", "A"))
  elseif find(marker, "^[(]?[ivxlcdm]+[).]") then
    return (marker:gsub("%a+", "i"))
  elseif find(marker, "^[(]?[IVXLCDM]+[).]") then
    return (marker:gsub("%a+", "I"))
  else
    assert(false, "Could not identify list style for " .. marker)
  end
end

local Parser = {}

function Parser:new(subject, opts, warn)
  -- ensure the subject ends with a newline character
  if not subject:find("[\r\n]$") then
    subject = subject .. "\n"
  end
  local state = {
    warn = warn or function() end,
    subject = subject,
    indent = 0,
    startline = nil,
    starteol = nil,
    endeol = nil,
    matches = {},
    containers = {},
    pos = 1,
    last_matched_container = 0,
    timer = {},
    opts = opts or {},
    finished_line = false }
  setmetatable(state, self)
  self.__index = self
  return state
end

-- parameters are start and end position
function Parser:parse_table_row(sp, ep)
  local orig_matches = #self.matches  -- so we can rewind
  local startpos = self.pos
  self:add_match(sp, sp, "+row")
  -- skip | and any initial space in the cell:
  self.pos = find(self.subject, "%S", sp + 1)
  -- check to see if we have a separator line
  local seps = {}
  local p = self.pos
  local sepfound = false
  while not sepfound do
    local sepsp, sepep, left, right, trailing =
      find(self.subject, "^(%:?)%-%-*(%:?)([ \t]*%|[ \t]*)", p)
    if sepep then
      local st = "separator_default"
      if #left > 0 and #right > 0 then
        st = "separator_center"
      elseif #right > 0 then
        st = "separator_right"
      elseif #left > 0 then
        st = "separator_left"
      end
      seps[#seps + 1] = {sepsp, sepep - #trailing, st}
      p = sepep + 1
      if p == self.starteol then
        sepfound = true
        break
      end
    else
      break
    end
  end
  if sepfound then
    for i=1,#seps do
      self:add_match(unpack(seps[i]))
    end
    self:add_match(self.starteol - 1, self.starteol - 1, "-row")
    self.pos = self.starteol
    self.finished_line = true
    return true
  end
  local inline_parser = inline.Parser:new(self.subject, self.opts, self.warn)
  self:add_match(sp, sp, "+cell")
  while self.pos <= ep do
    -- parse a chunk as inline content
    local _,nextbar = self:find("^[^|\r\n]*|")
    inline_parser:feed(self.pos, nextbar - 1)
    if inline_parser:in_verbatim() then
      -- read the next | as part of verbatim
      inline_parser:feed(nextbar, nextbar)
      self.pos = nextbar + 1
    else
      self.pos = nextbar + 1  -- skip past the next |
      -- add a table cell
      local cell_matches = inline_parser:get_matches()
      for i=1,#cell_matches do
        local s,e,ann = unpack_match(cell_matches[i])
        if i == #cell_matches and ann == "str" then
          -- strip trailing space
          while byte(self.subject, e) == 32 and e >= s do
            e = e - 1
          end
        end
        self:add_match(s,e,ann)
      end
      self:add_match(nextbar, nextbar, "-cell")
      if nextbar < ep then
        -- reset inline parser state
        inline_parser = inline.Parser:new(self.subject, self.opts, self.warn)
        self:add_match(nextbar, nextbar, "+cell")
        self.pos = find(self.subject, "%S", self.pos)
      end
    end
  end
  if inline_parser:in_verbatim() then
    -- rewind, this is not a valid table row
    self.pos = startpos
    for i = orig_matches,#self.matches do
      self.matches[i] = nil
    end
    return false
  else
    self:add_match(self.pos, self.pos, "-row")
    self.pos = self.starteol
    self.finished_line = true
    return true
  end
end

function Parser:specs()
  return {
    { name = "para",
      is_para = true,
      content = "inline",
      continue = function()
        return self:find("^%S")
      end,
      open = function(spec)
        self:add_container(Container:new(spec,
            { inline_parser =
                inline.Parser:new(self.subject, self.opts, self.warn) }))
        self:add_match(self.pos, self.pos, "+para")
        return true
      end,
      close = function()
        self:get_inline_matches()
        self:add_match(self.pos - 1, self.pos - 1, "-para")
        self.containers[#self.containers] = nil
      end
    },

    { name = "caption",
      is_para = false,
      content = "inline",
      continue = function()
        return self:find("^%S")
      end,
      open = function(spec)
        local _, ep = self:find("^%^[ \t]+")
        if ep then
          self.pos = ep + 1
          self:add_container(Container:new(spec,
            { inline_parser =
                inline.Parser:new(self.subject, self.opts, self.warn) }))
          self:add_match(self.pos, self.pos, "+caption")
          return true
        end
      end,
      close = function()
        self:get_inline_matches()
        self:add_match(self.pos - 1, self.pos - 1, "-caption")
        self.containers[#self.containers] = nil
      end
    },

    { name = "blockquote",
      content = "block",
      continue = function()
        if self:find("^%>%s") then
          self.pos = self.pos + 1
          return true
        else
          return false
        end
      end,
      open = function(spec)
        if self:find("^%>%s") then
          self:add_container(Container:new(spec))
          self:add_match(self.pos, self.pos, "+blockquote")
          self.pos = self.pos + 1
          return true
        end
      end,
      close = function()
        self:add_match(self.pos, self.pos, "-blockquote")
        self.containers[#self.containers] = nil
      end
    },

    -- should go before reference definitions
    { name = "footnote",
      content = "block",
      continue = function(container)
        if self.indent > container.indent or self:find("^[\r\n]") then
          return true
        else
          return false
        end
      end,
      open = function(spec)
        local sp, ep, label = self:find("^%[%^([^]]+)%]:%s")
        if not sp then
          return nil
        end
        -- adding container will close others
        self:add_container(Container:new(spec, {note_label = label,
                                                indent = self.indent}))
        self:add_match(sp, sp, "+footnote")
        self:add_match(sp + 2, ep - 3, "note_label")
        self.pos = ep
        return true
      end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-footnote")
        self.containers[#self.containers] = nil
      end
    },

    -- should go before list_item_spec
    { name = "thematic_break",
      content = nil,
      continue = function()
        return false
      end,
      open = function(spec)
        local sp, ep = self:find("^[-*][ \t]*[-*][ \t]*[-*][-* \t]*[\r\n]")
        if ep then
          self:add_container(Container:new(spec))
          self:add_match(sp, ep, "thematic_break")
          self.pos = ep
          return true
        end
      end,
      close = function(_container)
        self.containers[#self.containers] = nil
      end
    },

    { name = "list_item",
      content = "block",
      continue = function(container)
        if self.indent > container.indent or self:find("^[\r\n]") then
          return true
        else
          return false
        end
      end,
      open = function(spec)
        local sp, ep = self:find("^[-*+:]%s")
        if not sp then
          sp, ep = self:find("^%d+[.)]%s")
        end
        if not sp then
          sp, ep = self:find("^%(%d+%)%s")
        end
        if not sp then
          sp, ep = self:find("^[ivxlcdmIVXLCDM]+[.)]%s")
        end
        if not sp then
          sp, ep = self:find("^%([ivxlcdmIVXLCDM]+%)%s")
        end
        if not sp then
          sp, ep = self:find("^%a[.)]%s")
        end
        if not sp then
          sp, ep = self:find("^%(%a%)%s")
        end
        if not sp then
          return nil
        end
        local marker = sub(self.subject, sp, ep - 1)
        local checkbox = nil
        if self:find("^[*+-] %[[Xx ]%]%s", sp + 1) then -- task list
          marker = sub(self.subject, sp, sp + 4)
          checkbox = sub(self.subject, sp + 3, sp + 3)
        end
        -- some items have ambiguous style
        local styles = {get_list_style(marker)}
        local data = { styles = styles,
                       indent = self.indent }
        -- adding container will close others
        self:add_container(Container:new(spec, data))
        local annot = "+list_item"
        for i=1,#styles do
          annot = annot .. "[" .. styles[i] .. "]"
        end
        self:add_match(sp, ep - 1, annot)
        self.pos = ep
        if checkbox then
          if checkbox == " " then
            self:add_match(sp + 2, sp + 4, "checkbox_unchecked")
          else
            self:add_match(sp + 2, sp + 4, "checkbox_checked")
          end
          self.pos = sp + 5
        end
        return true
      end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-list_item")
        self.containers[#self.containers] = nil
      end
    },

    { name = "reference_definition",
      content = nil,
      continue = function(container)
        if container.indent >= self.indent then
          return false
        end
        local _, ep, rest = self:find("^(%S+)")
        if ep then
          self:add_match(ep - #rest + 1, ep, "reference_value")
          container.value = rest
          self.pos = ep + 1
        end
        return true
      end,
      open = function(spec)
        local sp, ep, label, rest = self:find("^%[([^]\r\n]*)%]:[ \t]*(%S*)")
        if sp then
          self:add_container(Container:new(spec,
             { key = label,
               value = rest,
               indent = self.indent }))
          self:add_match(sp, sp, "+reference_definition")
          self:add_match(sp, sp + #label + 1, "reference_key")
          if #rest > 0 then
            self:add_match(ep - #rest + 1, ep, "reference_value")
          end
          self.pos = ep + 1
          return true
        end
      end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-reference_definition")
        self.containers[#self.containers] = nil
      end
    },

    { name = "heading",
      content = "inline",
      continue = function(_container)
        return false
      end,
      open = function(spec)
        local sp, ep = self:find("^#+")
        if ep and find(self.subject, "^%s", ep + 1) then
          local level = ep - sp + 1
          self:add_container(Container:new(spec, {level = level,
               inline_parser = inline.Parser:new(self.subject, self.opts,
                 self.warn) }))
          self:add_match(sp, ep, "+heading")
          self.pos = ep + 1
          return true
        end
      end,
      close = function(_container)
        self:get_inline_matches()
        local last = self.matches[#self.matches] or self.pos - 1
        local sp, ep, annot = unpack_match(last)
        -- handle final ###
        local endheadingpos = ep
        local endheadingendpos = ep
        if annot == "str" then
          local endheadingstart, _, hashes =
            find(sub(self.subject, sp, ep), "%s+(#+)$")
          if hashes then
            endheadingpos = endheadingpos - #hashes
            if endheadingstart == 1 then
              -- remove final str match
              self.matches[#self.matches] = nil
            else
              self.matches[#self.matches] =
                make_match(sp, sp + (endheadingstart - 2), "str")
            end
          end
        end
        self:add_match(endheadingpos, endheadingendpos, "-heading")
        self.containers[#self.containers] = nil
      end
    },

    { name = "code_block",
      content = "text",
      continue = function(container)
        local char = sub(container.border, 1, 1)
        local sp, ep, border = self:find("^(" .. container.border ..
                                 char .. "*)[ \t]*[\r\n]")
        if ep then
          container.end_fence_sp = sp
          container.end_fence_ep = sp + #border - 1
          self.pos = ep -- before newline
          self.finished_line = true
          return false
        else
          return true
        end
      end,
      open = function(spec)
        local sp, ep, border, ws, lang =
          self:find("^(~~~~*)([ \t]*)(%S*)[ \t]*[\r\n]")
        if not ep then
          sp, ep, border, ws, lang =
            self:find("^(````*)([ \t]*)([^%s`]*)[ \t]*[\r\n]")
        end
        if border then
          local is_raw = find(lang, "^=") and true or false
          self:add_container(Container:new(spec, {border = border,
                                                  indent = self.indent }))
          self:add_match(sp, sp + #border - 1, "+code_block")
          if #lang > 0 then
            local langstart = sp + #border + #ws
            if is_raw then
              self:add_match(langstart, langstart + #lang - 1, "raw_format")
            else
              self:add_match(langstart, langstart + #lang - 1, "code_language")
            end
          end
          self.pos = ep  -- before newline
          self.finished_line = true
          return true
        end
      end,
      close = function(container)
        local sp = container.end_fence_sp or self.pos
        local ep = container.end_fence_ep or self.pos
        self:add_match(sp, ep, "-code_block")
        if sp == ep then
          self.warn({ pos = self.pos, message = "Unclosed code block" })
        end
        self.containers[#self.containers] = nil
      end
    },

    { name = "fenced_div",
      content = "block",
      continue = function(container)
        local sp, ep, equals = self:find("^(::::*)[ \t]*[r\n]")
        if ep and #equals >= container.equals then
          container.end_fence_sp = sp
          container.end_fence_ep = sp + #equals - 1
          self.pos = ep -- before newline
          return false
        else
          return true
        end
      end,
      open = function(spec)
        local sp, ep1, equals = self:find("^(::::*)[ \t]*")
        if not ep1 then
          return false
        end
        local clsp, ep = find(self.subject, "^%w*", ep1 + 1)
        local _, eol = find(self.subject, "^[ \t]*[\r\n]", ep + 1)
        if eol then
          self:add_container(Container:new(spec, {equals = #equals}))
          self:add_match(sp, ep, "+div")
          if ep > clsp then
            self:add_match(clsp, ep, "class")
          end
          self.pos = eol + 1
          self.finished_line = true
          return true
        end
      end,
      close = function(container)
        local sp = container.end_fence_sp or self.pos
        local ep = container.end_fence_ep or self.pos
        -- check to make sure the match is in order
        self:add_match(sp, ep, "-div")
        if sp == ep then
          self.warn({pos = self.pos, message = "Unclosed div"})
        end
        self.containers[#self.containers] = nil
      end
    },

    { name = "table",
      content = "cells",
      continue = function(_container)
        local sp, ep = self:find("^|[^\r\n]*|")
        local eolsp = " *[\r\n]" -- make sure at end of line
        if sp and eolsp then
          return self:parse_table_row(sp, ep)
        end
      end,
      open = function(spec)
        local sp, ep = self:find("^|[^\r\n]*|")
        local eolsp = " *[\r\n]" -- make sure at end of line
        if sp and eolsp then
          self:add_container(Container:new(spec, { columns = 0 }))
          self:add_match(sp, sp, "+table")
          if self:parse_table_row(sp, ep) then
            return true
          else
            self.containers[#self.containers] = nil
            self.matches[#self.matches] = nil  -- remove +table match
            return false
          end
        end
     end,
      close = function(_container)
        self:add_match(self.pos, self.pos, "-table")
        self.containers[#self.containers] = nil
      end
    },

    { name = "attributes",
      content = "attributes",
      continue = function(container)
        if self.indent > container.indent then
          container.slices[#container.slices + 1] =
            {self.pos, self.endeol}
          self.pos = self.starteol
          return true
        else
          return false
        end
      end,
      open = function(spec)
        if self:find("^%{") then
          self:add_container(Container:new(spec,
                             { slices = {{self.pos, self.endeol}},
                               indent = self.indent }))
          self.pos = self.starteol
          return true
        end
      end,
      close = function(container)
        local attribute_parser = attributes.AttributeParser:new(self.subject)
        local slices = container.slices
        local status, finalpos
        for i=1,#slices do
          status, finalpos = attribute_parser:feed(unpack(slices[i]))
          if status ~= 'continue' then
            break
          end
        end
        -- make sure there's no extra content after the }
        if status == 'done' and find(self.subject, "^[ \t]*[\r\n]", finalpos + 1) then
          local attr_matches = attribute_parser:get_matches()
          self:add_match(slices[1][1], slices[1][1], "+block_attributes")
          for i=1,#attr_matches do
            self:add_match(unpack_match(attr_matches[i]))
          end
          self:add_match(slices[#slices][2], slices[#slices][2], "-block_attributes")
        else -- If not, parse it as inlines and add paragraph match
          container.inline_parser = inline.Parser:new(self.subject, self.opts)
          self:add_match(slices[1][1], slices[1][1], "+para")
          for i=1,#slices do
            container.inline_parser:feed(unpack(slices[i]))
          end
          self:get_inline_matches()
          self:add_match(slices[#slices][2], slices[#slices][2], "-para")
        end
        self.containers[#self.containers] = nil
      end
    }
  }
end

function Parser:get_inline_matches()
  local matches =
    self.containers[#self.containers].inline_parser:get_matches()
  for i=1,#matches do
    self.matches[#self.matches + 1] = matches[i]
  end
end

function Parser:find(patt)
  return find(self.subject, patt, self.pos)
end

function Parser:add_match(startpos, endpos, annotation)
  self.matches[#self.matches + 1] = make_match(startpos, endpos, annotation)
end

function Parser:add_container(container)
  local last_matched = self.last_matched_container
  while #self.containers > last_matched or
         (#self.containers > 0 and
          self.containers[#self.containers].content ~= "block") do
    self.containers[#self.containers]:close()
  end
  self.containers[#self.containers + 1] = container
end

function Parser:skip_space()
  local newpos, _ = find(self.subject, "[^ \t]", self.pos)
  if newpos then
    self.indent = newpos - self.startline
    self.pos = newpos
  end
end

function Parser:get_eol()
  local starteol, endeol = find(self.subject, "[\r]?[\n]", self.pos)
  if not endeol then
    starteol, endeol = #self.subject, #self.subject
  end
  self.starteol = starteol
  self.endeol = endeol
end

function Parser:parse()
  local specs = self:specs()
  local para_spec = specs[1]
  local subjectlen = #self.subject
  while self.pos <= subjectlen do

    self.indent = 0
    self.startline = self.pos
    self.finished_line = false
    self:get_eol()

    -- check open containers for continuation
    self.last_matched_container = 0
    local idx = 0
    while idx < #self.containers do
      idx = idx + 1
      local container = self.containers[idx]
      -- skip any indentation
      self:skip_space()
      if container:continue() then
        self.last_matched_container = idx
      else
        break
      end
    end

    -- if we hit a close fence, we can move to next line
    if self.finished_line then
      while #self.containers > self.last_matched_container do
        self.containers[#self.containers]:close()
      end
    end

    if not self.finished_line then
      -- check for new containers
      self:skip_space()
      local is_blank = (self.pos == self.starteol)

      local new_starts = false
      local last_match = self.containers[self.last_matched_container]
      local check_starts = not is_blank and
                          (not last_match or last_match.content == "block") and
                            not self:find("^%a+%s") -- optimization
      while check_starts do
        check_starts = false
        for i=1,#specs do
          local spec = specs[i]
          if not spec.is_para then
            if spec:open() then
              self.last_matched_container = #self.containers
              if self.finished_line then
                check_starts = false
              else
                self:skip_space()
                new_starts = true
                check_starts = spec.content ~= "text"
              end
              break
            end
          end
        end
      end

      if not self.finished_line then
        -- handle remaining content
        self:skip_space()

        is_blank = (self.pos == self.starteol)

        local is_lazy = not is_blank and
                        not new_starts and
                        self.last_matched_container < #self.containers and
                        self.containers[#self.containers].content == 'inline'

        if not is_lazy and
          self.last_matched_container < #self.containers then
          while #self.containers > self.last_matched_container do
            self.containers[#self.containers]:close()
          end
        end

        local tip = self.containers[#self.containers]

        -- add para by default if there's text
        if not tip or tip.content == 'block' then
          if is_blank then
            if not new_starts then
              -- need to track these for tight/loose lists
              self:add_match(self.pos, self.endeol, "blankline")
            end
          else
            para_spec:open()
          end
          tip = self.containers[#self.containers]
        end

        if tip then
          if tip.content == "text" then
            local startpos = self.pos
            if tip.indent and self.indent > tip.indent then
              -- get back the leading spaces we gobbled
              startpos = startpos - (self.indent - tip.indent)
            end
            self:add_match(startpos, self.endeol, "str")
          elseif tip.content == "inline" then
            if not is_blank then
              tip.inline_parser:feed(self.pos, self.endeol)
            end
          end
        end
      end
    end

    self.pos = self.endeol + 1
  end
  self:finish()

end

function Parser:finish()
  -- close unmatched containers
  while #self.containers > 0 do
    self.containers[#self.containers]:close()
  end
end

function Parser:get_matches()
  return self.matches
end

return { Parser = Parser,
         Container = Container }

end

package.preload["djot.emoji"] = function()
return {grinning="😀",
smiley="😃",
smile="😄",
grin="😁",
laughing="😆",
satisfied="😆",
sweat_smile="😅",
rofl="🤣",
joy="😂",
slightly_smiling_face="🙂",
upside_down_face="🙃",
wink="😉",
blush="😊",
innocent="😇",
smiling_face_with_three_hearts="🥰",
heart_eyes="😍",
star_struck="🤩",
kissing_heart="😘",
kissing="😗",
relaxed="☺️",
kissing_closed_eyes="😚",
kissing_smiling_eyes="😙",
smiling_face_with_tear="🥲",
yum="😋",
stuck_out_tongue="😛",
stuck_out_tongue_winking_eye="😜",
zany_face="🤪",
stuck_out_tongue_closed_eyes="😝",
money_mouth_face="🤑",
hugs="🤗",
hand_over_mouth="🤭",
shushing_face="🤫",
thinking="🤔",
zipper_mouth_face="🤐",
raised_eyebrow="🤨",
neutral_face="😐",
expressionless="😑",
no_mouth="😶",
face_in_clouds="😶‍🌫️",
smirk="😏",
unamused="😒",
roll_eyes="🙄",
grimacing="😬",
face_exhaling="😮‍💨",
lying_face="🤥",
relieved="😌",
pensive="😔",
sleepy="😪",
drooling_face="🤤",
sleeping="😴",
mask="😷",
face_with_thermometer="🤒",
face_with_head_bandage="🤕",
nauseated_face="🤢",
vomiting_face="🤮",
sneezing_face="🤧",
hot_face="🥵",
cold_face="🥶",
woozy_face="🥴",
dizzy_face="😵",
face_with_spiral_eyes="😵‍💫",
exploding_head="🤯",
cowboy_hat_face="🤠",
partying_face="🥳",
disguised_face="🥸",
sunglasses="😎",
nerd_face="🤓",
monocle_face="🧐",
confused="😕",
worried="😟",
slightly_frowning_face="🙁",
frowning_face="☹️",
open_mouth="😮",
hushed="😯",
astonished="😲",
flushed="😳",
pleading_face="🥺",
frowning="😦",
anguished="😧",
fearful="😨",
cold_sweat="😰",
disappointed_relieved="😥",
cry="😢",
sob="😭",
scream="😱",
confounded="😖",
persevere="😣",
disappointed="😞",
sweat="😓",
weary="😩",
tired_face="😫",
yawning_face="🥱",
triumph="😤",
rage="😡",
pout="😡",
angry="😠",
cursing_face="🤬",
smiling_imp="😈",
imp="👿",
skull="💀",
skull_and_crossbones="☠️",
hankey="💩",
poop="💩",
shit="💩",
clown_face="🤡",
japanese_ogre="👹",
japanese_goblin="👺",
ghost="👻",
alien="👽",
space_invader="👾",
robot="🤖",
smiley_cat="😺",
smile_cat="😸",
joy_cat="😹",
heart_eyes_cat="😻",
smirk_cat="😼",
kissing_cat="😽",
scream_cat="🙀",
crying_cat_face="😿",
pouting_cat="😾",
see_no_evil="🙈",
hear_no_evil="🙉",
speak_no_evil="🙊",
kiss="💋",
love_letter="💌",
cupid="💘",
gift_heart="💝",
sparkling_heart="💖",
heartpulse="💗",
heartbeat="💓",
revolving_hearts="💞",
two_hearts="💕",
heart_decoration="💟",
heavy_heart_exclamation="❣️",
broken_heart="💔",
heart_on_fire="❤️‍🔥",
mending_heart="❤️‍🩹",
heart="❤️",
orange_heart="🧡",
yellow_heart="💛",
green_heart="💚",
blue_heart="💙",
purple_heart="💜",
brown_heart="🤎",
black_heart="🖤",
white_heart="🤍",
["100"]="💯",
anger="💢",
boom="💥",
collision="💥",
dizzy="💫",
sweat_drops="💦",
dash="💨",
hole="🕳️",
bomb="💣",
speech_balloon="💬",
eye_speech_bubble="👁️‍🗨️",
left_speech_bubble="🗨️",
right_anger_bubble="🗯️",
thought_balloon="💭",
zzz="💤",
wave="👋",
raised_back_of_hand="🤚",
raised_hand_with_fingers_splayed="🖐️",
hand="✋",
raised_hand="✋",
vulcan_salute="🖖",
ok_hand="👌",
pinched_fingers="🤌",
pinching_hand="🤏",
v="✌️",
crossed_fingers="🤞",
love_you_gesture="🤟",
metal="🤘",
call_me_hand="🤙",
point_left="👈",
point_right="👉",
["point_up_2"]="👆",
middle_finger="🖕",
fu="🖕",
point_down="👇",
point_up="☝️",
["+1"]="👍",
thumbsup="👍",
["-1"]="👎",
thumbsdown="👎",
fist_raised="✊",
fist="✊",
fist_oncoming="👊",
facepunch="👊",
punch="👊",
fist_left="🤛",
fist_right="🤜",
clap="👏",
raised_hands="🙌",
open_hands="👐",
palms_up_together="🤲",
handshake="🤝",
pray="🙏",
writing_hand="✍️",
nail_care="💅",
selfie="🤳",
muscle="💪",
mechanical_arm="🦾",
mechanical_leg="🦿",
leg="🦵",
foot="🦶",
ear="👂",
ear_with_hearing_aid="🦻",
nose="👃",
brain="🧠",
anatomical_heart="🫀",
lungs="🫁",
tooth="🦷",
bone="🦴",
eyes="👀",
eye="👁️",
tongue="👅",
lips="👄",
baby="👶",
child="🧒",
boy="👦",
girl="👧",
adult="🧑",
blond_haired_person="👱",
man="👨",
bearded_person="🧔",
man_beard="🧔‍♂️",
woman_beard="🧔‍♀️",
red_haired_man="👨‍🦰",
curly_haired_man="👨‍🦱",
white_haired_man="👨‍🦳",
bald_man="👨‍🦲",
woman="👩",
red_haired_woman="👩‍🦰",
person_red_hair="🧑‍🦰",
curly_haired_woman="👩‍🦱",
person_curly_hair="🧑‍🦱",
white_haired_woman="👩‍🦳",
person_white_hair="🧑‍🦳",
bald_woman="👩‍🦲",
person_bald="🧑‍🦲",
blond_haired_woman="👱‍♀️",
blonde_woman="👱‍♀️",
blond_haired_man="👱‍♂️",
older_adult="🧓",
older_man="👴",
older_woman="👵",
frowning_person="🙍",
frowning_man="🙍‍♂️",
frowning_woman="🙍‍♀️",
pouting_face="🙎",
pouting_man="🙎‍♂️",
pouting_woman="🙎‍♀️",
no_good="🙅",
no_good_man="🙅‍♂️",
ng_man="🙅‍♂️",
no_good_woman="🙅‍♀️",
ng_woman="🙅‍♀️",
ok_person="🙆",
ok_man="🙆‍♂️",
ok_woman="🙆‍♀️",
tipping_hand_person="💁",
information_desk_person="💁",
tipping_hand_man="💁‍♂️",
sassy_man="💁‍♂️",
tipping_hand_woman="💁‍♀️",
sassy_woman="💁‍♀️",
raising_hand="🙋",
raising_hand_man="🙋‍♂️",
raising_hand_woman="🙋‍♀️",
deaf_person="🧏",
deaf_man="🧏‍♂️",
deaf_woman="🧏‍♀️",
bow="🙇",
bowing_man="🙇‍♂️",
bowing_woman="🙇‍♀️",
facepalm="🤦",
man_facepalming="🤦‍♂️",
woman_facepalming="🤦‍♀️",
shrug="🤷",
man_shrugging="🤷‍♂️",
woman_shrugging="🤷‍♀️",
health_worker="🧑‍⚕️",
man_health_worker="👨‍⚕️",
woman_health_worker="👩‍⚕️",
student="🧑‍🎓",
man_student="👨‍🎓",
woman_student="👩‍🎓",
teacher="🧑‍🏫",
man_teacher="👨‍🏫",
woman_teacher="👩‍🏫",
judge="🧑‍⚖️",
man_judge="👨‍⚖️",
woman_judge="👩‍⚖️",
farmer="🧑‍🌾",
man_farmer="👨‍🌾",
woman_farmer="👩‍🌾",
cook="🧑‍🍳",
man_cook="👨‍🍳",
woman_cook="👩‍🍳",
mechanic="🧑‍🔧",
man_mechanic="👨‍🔧",
woman_mechanic="👩‍🔧",
factory_worker="🧑‍🏭",
man_factory_worker="👨‍🏭",
woman_factory_worker="👩‍🏭",
office_worker="🧑‍💼",
man_office_worker="👨‍💼",
woman_office_worker="👩‍💼",
scientist="🧑‍🔬",
man_scientist="👨‍🔬",
woman_scientist="👩‍🔬",
technologist="🧑‍💻",
man_technologist="👨‍💻",
woman_technologist="👩‍💻",
singer="🧑‍🎤",
man_singer="👨‍🎤",
woman_singer="👩‍🎤",
artist="🧑‍🎨",
man_artist="👨‍🎨",
woman_artist="👩‍🎨",
pilot="🧑‍✈️",
man_pilot="👨‍✈️",
woman_pilot="👩‍✈️",
astronaut="🧑‍🚀",
man_astronaut="👨‍🚀",
woman_astronaut="👩‍🚀",
firefighter="🧑‍🚒",
man_firefighter="👨‍🚒",
woman_firefighter="👩‍🚒",
police_officer="👮",
cop="👮",
policeman="👮‍♂️",
policewoman="👮‍♀️",
detective="🕵️",
male_detective="🕵️‍♂️",
female_detective="🕵️‍♀️",
guard="💂",
guardsman="💂‍♂️",
guardswoman="💂‍♀️",
ninja="🥷",
construction_worker="👷",
construction_worker_man="👷‍♂️",
construction_worker_woman="👷‍♀️",
prince="🤴",
princess="👸",
person_with_turban="👳",
man_with_turban="👳‍♂️",
woman_with_turban="👳‍♀️",
man_with_gua_pi_mao="👲",
woman_with_headscarf="🧕",
person_in_tuxedo="🤵",
man_in_tuxedo="🤵‍♂️",
woman_in_tuxedo="🤵‍♀️",
person_with_veil="👰",
man_with_veil="👰‍♂️",
woman_with_veil="👰‍♀️",
bride_with_veil="👰‍♀️",
pregnant_woman="🤰",
breast_feeding="🤱",
woman_feeding_baby="👩‍🍼",
man_feeding_baby="👨‍🍼",
person_feeding_baby="🧑‍🍼",
angel="👼",
santa="🎅",
mrs_claus="🤶",
mx_claus="🧑‍🎄",
superhero="🦸",
superhero_man="🦸‍♂️",
superhero_woman="🦸‍♀️",
supervillain="🦹",
supervillain_man="🦹‍♂️",
supervillain_woman="🦹‍♀️",
mage="🧙",
mage_man="🧙‍♂️",
mage_woman="🧙‍♀️",
fairy="🧚",
fairy_man="🧚‍♂️",
fairy_woman="🧚‍♀️",
vampire="🧛",
vampire_man="🧛‍♂️",
vampire_woman="🧛‍♀️",
merperson="🧜",
merman="🧜‍♂️",
mermaid="🧜‍♀️",
elf="🧝",
elf_man="🧝‍♂️",
elf_woman="🧝‍♀️",
genie="🧞",
genie_man="🧞‍♂️",
genie_woman="🧞‍♀️",
zombie="🧟",
zombie_man="🧟‍♂️",
zombie_woman="🧟‍♀️",
massage="💆",
massage_man="💆‍♂️",
massage_woman="💆‍♀️",
haircut="💇",
haircut_man="💇‍♂️",
haircut_woman="💇‍♀️",
walking="🚶",
walking_man="🚶‍♂️",
walking_woman="🚶‍♀️",
standing_person="🧍",
standing_man="🧍‍♂️",
standing_woman="🧍‍♀️",
kneeling_person="🧎",
kneeling_man="🧎‍♂️",
kneeling_woman="🧎‍♀️",
person_with_probing_cane="🧑‍🦯",
man_with_probing_cane="👨‍🦯",
woman_with_probing_cane="👩‍🦯",
person_in_motorized_wheelchair="🧑‍🦼",
man_in_motorized_wheelchair="👨‍🦼",
woman_in_motorized_wheelchair="👩‍🦼",
person_in_manual_wheelchair="🧑‍🦽",
man_in_manual_wheelchair="👨‍🦽",
woman_in_manual_wheelchair="👩‍🦽",
runner="🏃",
running="🏃",
running_man="🏃‍♂️",
running_woman="🏃‍♀️",
woman_dancing="💃",
dancer="💃",
man_dancing="🕺",
business_suit_levitating="🕴️",
dancers="👯",
dancing_men="👯‍♂️",
dancing_women="👯‍♀️",
sauna_person="🧖",
sauna_man="🧖‍♂️",
sauna_woman="🧖‍♀️",
climbing="🧗",
climbing_man="🧗‍♂️",
climbing_woman="🧗‍♀️",
person_fencing="🤺",
horse_racing="🏇",
skier="⛷️",
snowboarder="🏂",
golfing="🏌️",
golfing_man="🏌️‍♂️",
golfing_woman="🏌️‍♀️",
surfer="🏄",
surfing_man="🏄‍♂️",
surfing_woman="🏄‍♀️",
rowboat="🚣",
rowing_man="🚣‍♂️",
rowing_woman="🚣‍♀️",
swimmer="🏊",
swimming_man="🏊‍♂️",
swimming_woman="🏊‍♀️",
bouncing_ball_person="⛹️",
bouncing_ball_man="⛹️‍♂️",
basketball_man="⛹️‍♂️",
bouncing_ball_woman="⛹️‍♀️",
basketball_woman="⛹️‍♀️",
weight_lifting="🏋️",
weight_lifting_man="🏋️‍♂️",
weight_lifting_woman="🏋️‍♀️",
bicyclist="🚴",
biking_man="🚴‍♂️",
biking_woman="🚴‍♀️",
mountain_bicyclist="🚵",
mountain_biking_man="🚵‍♂️",
mountain_biking_woman="🚵‍♀️",
cartwheeling="🤸",
man_cartwheeling="🤸‍♂️",
woman_cartwheeling="🤸‍♀️",
wrestling="🤼",
men_wrestling="🤼‍♂️",
women_wrestling="🤼‍♀️",
water_polo="🤽",
man_playing_water_polo="🤽‍♂️",
woman_playing_water_polo="🤽‍♀️",
handball_person="🤾",
man_playing_handball="🤾‍♂️",
woman_playing_handball="🤾‍♀️",
juggling_person="🤹",
man_juggling="🤹‍♂️",
woman_juggling="🤹‍♀️",
lotus_position="🧘",
lotus_position_man="🧘‍♂️",
lotus_position_woman="🧘‍♀️",
bath="🛀",
sleeping_bed="🛌",
people_holding_hands="🧑‍🤝‍🧑",
two_women_holding_hands="👭",
couple="👫",
two_men_holding_hands="👬",
couplekiss="💏",
couplekiss_man_woman="👩‍❤️‍💋‍👨",
couplekiss_man_man="👨‍❤️‍💋‍👨",
couplekiss_woman_woman="👩‍❤️‍💋‍👩",
couple_with_heart="💑",
couple_with_heart_woman_man="👩‍❤️‍👨",
couple_with_heart_man_man="👨‍❤️‍👨",
couple_with_heart_woman_woman="👩‍❤️‍👩",
family="👪",
family_man_woman_boy="👨‍👩‍👦",
family_man_woman_girl="👨‍👩‍👧",
family_man_woman_girl_boy="👨‍👩‍👧‍👦",
family_man_woman_boy_boy="👨‍👩‍👦‍👦",
family_man_woman_girl_girl="👨‍👩‍👧‍👧",
family_man_man_boy="👨‍👨‍👦",
family_man_man_girl="👨‍👨‍👧",
family_man_man_girl_boy="👨‍👨‍👧‍👦",
family_man_man_boy_boy="👨‍👨‍👦‍👦",
family_man_man_girl_girl="👨‍👨‍👧‍👧",
family_woman_woman_boy="👩‍👩‍👦",
family_woman_woman_girl="👩‍👩‍👧",
family_woman_woman_girl_boy="👩‍👩‍👧‍👦",
family_woman_woman_boy_boy="👩‍👩‍👦‍👦",
family_woman_woman_girl_girl="👩‍👩‍👧‍👧",
family_man_boy="👨‍👦",
family_man_boy_boy="👨‍👦‍👦",
family_man_girl="👨‍👧",
family_man_girl_boy="👨‍👧‍👦",
family_man_girl_girl="👨‍👧‍👧",
family_woman_boy="👩‍👦",
family_woman_boy_boy="👩‍👦‍👦",
family_woman_girl="👩‍👧",
family_woman_girl_boy="👩‍👧‍👦",
family_woman_girl_girl="👩‍👧‍👧",
speaking_head="🗣️",
bust_in_silhouette="👤",
busts_in_silhouette="👥",
people_hugging="🫂",
footprints="👣",
monkey_face="🐵",
monkey="🐒",
gorilla="🦍",
orangutan="🦧",
dog="🐶",
["dog2"]="🐕",
guide_dog="🦮",
service_dog="🐕‍🦺",
poodle="🐩",
wolf="🐺",
fox_face="🦊",
raccoon="🦝",
cat="🐱",
["cat2"]="🐈",
black_cat="🐈‍⬛",
lion="🦁",
tiger="🐯",
["tiger2"]="🐅",
leopard="🐆",
horse="🐴",
racehorse="🐎",
unicorn="🦄",
zebra="🦓",
deer="🦌",
bison="🦬",
cow="🐮",
ox="🐂",
water_buffalo="🐃",
["cow2"]="🐄",
pig="🐷",
["pig2"]="🐖",
boar="🐗",
pig_nose="🐽",
ram="🐏",
sheep="🐑",
goat="🐐",
dromedary_camel="🐪",
camel="🐫",
llama="🦙",
giraffe="🦒",
elephant="🐘",
mammoth="🦣",
rhinoceros="🦏",
hippopotamus="🦛",
mouse="🐭",
["mouse2"]="🐁",
rat="🐀",
hamster="🐹",
rabbit="🐰",
["rabbit2"]="🐇",
chipmunk="🐿️",
beaver="🦫",
hedgehog="🦔",
bat="🦇",
bear="🐻",
polar_bear="🐻‍❄️",
koala="🐨",
panda_face="🐼",
sloth="🦥",
otter="🦦",
skunk="🦨",
kangaroo="🦘",
badger="🦡",
feet="🐾",
paw_prints="🐾",
turkey="🦃",
chicken="🐔",
rooster="🐓",
hatching_chick="🐣",
baby_chick="🐤",
hatched_chick="🐥",
bird="🐦",
penguin="🐧",
dove="🕊️",
eagle="🦅",
duck="🦆",
swan="🦢",
owl="🦉",
dodo="🦤",
feather="🪶",
flamingo="🦩",
peacock="🦚",
parrot="🦜",
frog="🐸",
crocodile="🐊",
turtle="🐢",
lizard="🦎",
snake="🐍",
dragon_face="🐲",
dragon="🐉",
sauropod="🦕",
["t-rex"]="🦖",
whale="🐳",
["whale2"]="🐋",
dolphin="🐬",
flipper="🐬",
seal="🦭",
fish="🐟",
tropical_fish="🐠",
blowfish="🐡",
shark="🦈",
octopus="🐙",
shell="🐚",
snail="🐌",
butterfly="🦋",
bug="🐛",
ant="🐜",
bee="🐝",
honeybee="🐝",
beetle="🪲",
lady_beetle="🐞",
cricket="🦗",
cockroach="🪳",
spider="🕷️",
spider_web="🕸️",
scorpion="🦂",
mosquito="🦟",
fly="🪰",
worm="🪱",
microbe="🦠",
bouquet="💐",
cherry_blossom="🌸",
white_flower="💮",
rosette="🏵️",
rose="🌹",
wilted_flower="🥀",
hibiscus="🌺",
sunflower="🌻",
blossom="🌼",
tulip="🌷",
seedling="🌱",
potted_plant="🪴",
evergreen_tree="🌲",
deciduous_tree="🌳",
palm_tree="🌴",
cactus="🌵",
ear_of_rice="🌾",
herb="🌿",
shamrock="☘️",
four_leaf_clover="🍀",
maple_leaf="🍁",
fallen_leaf="🍂",
leaves="🍃",
grapes="🍇",
melon="🍈",
watermelon="🍉",
tangerine="🍊",
orange="🍊",
mandarin="🍊",
lemon="🍋",
banana="🍌",
pineapple="🍍",
mango="🥭",
apple="🍎",
green_apple="🍏",
pear="🍐",
peach="🍑",
cherries="🍒",
strawberry="🍓",
blueberries="🫐",
kiwi_fruit="🥝",
tomato="🍅",
olive="🫒",
coconut="🥥",
avocado="🥑",
eggplant="🍆",
potato="🥔",
carrot="🥕",
corn="🌽",
hot_pepper="🌶️",
bell_pepper="🫑",
cucumber="🥒",
leafy_green="🥬",
broccoli="🥦",
garlic="🧄",
onion="🧅",
mushroom="🍄",
peanuts="🥜",
chestnut="🌰",
bread="🍞",
croissant="🥐",
baguette_bread="🥖",
flatbread="🫓",
pretzel="🥨",
bagel="🥯",
pancakes="🥞",
waffle="🧇",
cheese="🧀",
meat_on_bone="🍖",
poultry_leg="🍗",
cut_of_meat="🥩",
bacon="🥓",
hamburger="🍔",
fries="🍟",
pizza="🍕",
hotdog="🌭",
sandwich="🥪",
taco="🌮",
burrito="🌯",
tamale="🫔",
stuffed_flatbread="🥙",
falafel="🧆",
egg="🥚",
fried_egg="🍳",
shallow_pan_of_food="🥘",
stew="🍲",
fondue="🫕",
bowl_with_spoon="🥣",
green_salad="🥗",
popcorn="🍿",
butter="🧈",
salt="🧂",
canned_food="🥫",
bento="🍱",
rice_cracker="🍘",
rice_ball="🍙",
rice="🍚",
curry="🍛",
ramen="🍜",
spaghetti="🍝",
sweet_potato="🍠",
oden="🍢",
sushi="🍣",
fried_shrimp="🍤",
fish_cake="🍥",
moon_cake="🥮",
dango="🍡",
dumpling="🥟",
fortune_cookie="🥠",
takeout_box="🥡",
crab="🦀",
lobster="🦞",
shrimp="🦐",
squid="🦑",
oyster="🦪",
icecream="🍦",
shaved_ice="🍧",
ice_cream="🍨",
doughnut="🍩",
cookie="🍪",
birthday="🎂",
cake="🍰",
cupcake="🧁",
pie="🥧",
chocolate_bar="🍫",
candy="🍬",
lollipop="🍭",
custard="🍮",
honey_pot="🍯",
baby_bottle="🍼",
milk_glass="🥛",
coffee="☕",
teapot="🫖",
tea="🍵",
sake="🍶",
champagne="🍾",
wine_glass="🍷",
cocktail="🍸",
tropical_drink="🍹",
beer="🍺",
beers="🍻",
clinking_glasses="🥂",
tumbler_glass="🥃",
cup_with_straw="🥤",
bubble_tea="🧋",
beverage_box="🧃",
mate="🧉",
ice_cube="🧊",
chopsticks="🥢",
plate_with_cutlery="🍽️",
fork_and_knife="🍴",
spoon="🥄",
hocho="🔪",
knife="🔪",
amphora="🏺",
earth_africa="🌍",
earth_americas="🌎",
earth_asia="🌏",
globe_with_meridians="🌐",
world_map="🗺️",
japan="🗾",
compass="🧭",
mountain_snow="🏔️",
mountain="⛰️",
volcano="🌋",
mount_fuji="🗻",
camping="🏕️",
beach_umbrella="🏖️",
desert="🏜️",
desert_island="🏝️",
national_park="🏞️",
stadium="🏟️",
classical_building="🏛️",
building_construction="🏗️",
bricks="🧱",
rock="🪨",
wood="🪵",
hut="🛖",
houses="🏘️",
derelict_house="🏚️",
house="🏠",
house_with_garden="🏡",
office="🏢",
post_office="🏣",
european_post_office="🏤",
hospital="🏥",
bank="🏦",
hotel="🏨",
love_hotel="🏩",
convenience_store="🏪",
school="🏫",
department_store="🏬",
factory="🏭",
japanese_castle="🏯",
european_castle="🏰",
wedding="💒",
tokyo_tower="🗼",
statue_of_liberty="🗽",
church="⛪",
mosque="🕌",
hindu_temple="🛕",
synagogue="🕍",
shinto_shrine="⛩️",
kaaba="🕋",
fountain="⛲",
tent="⛺",
foggy="🌁",
night_with_stars="🌃",
cityscape="🏙️",
sunrise_over_mountains="🌄",
sunrise="🌅",
city_sunset="🌆",
city_sunrise="🌇",
bridge_at_night="🌉",
hotsprings="♨️",
carousel_horse="🎠",
ferris_wheel="🎡",
roller_coaster="🎢",
barber="💈",
circus_tent="🎪",
steam_locomotive="🚂",
railway_car="🚃",
bullettrain_side="🚄",
bullettrain_front="🚅",
["train2"]="🚆",
metro="🚇",
light_rail="🚈",
station="🚉",
tram="🚊",
monorail="🚝",
mountain_railway="🚞",
train="🚋",
bus="🚌",
oncoming_bus="🚍",
trolleybus="🚎",
minibus="🚐",
ambulance="🚑",
fire_engine="🚒",
police_car="🚓",
oncoming_police_car="🚔",
taxi="🚕",
oncoming_taxi="🚖",
car="🚗",
red_car="🚗",
oncoming_automobile="🚘",
blue_car="🚙",
pickup_truck="🛻",
truck="🚚",
articulated_lorry="🚛",
tractor="🚜",
racing_car="🏎️",
motorcycle="🏍️",
motor_scooter="🛵",
manual_wheelchair="🦽",
motorized_wheelchair="🦼",
auto_rickshaw="🛺",
bike="🚲",
kick_scooter="🛴",
skateboard="🛹",
roller_skate="🛼",
busstop="🚏",
motorway="🛣️",
railway_track="🛤️",
oil_drum="🛢️",
fuelpump="⛽",
rotating_light="🚨",
traffic_light="🚥",
vertical_traffic_light="🚦",
stop_sign="🛑",
construction="🚧",
anchor="⚓",
boat="⛵",
sailboat="⛵",
canoe="🛶",
speedboat="🚤",
passenger_ship="🛳️",
ferry="⛴️",
motor_boat="🛥️",
ship="🚢",
airplane="✈️",
small_airplane="🛩️",
flight_departure="🛫",
flight_arrival="🛬",
parachute="🪂",
seat="💺",
helicopter="🚁",
suspension_railway="🚟",
mountain_cableway="🚠",
aerial_tramway="🚡",
artificial_satellite="🛰️",
rocket="🚀",
flying_saucer="🛸",
bellhop_bell="🛎️",
luggage="🧳",
hourglass="⌛",
hourglass_flowing_sand="⏳",
watch="⌚",
alarm_clock="⏰",
stopwatch="⏱️",
timer_clock="⏲️",
mantelpiece_clock="🕰️",
["clock12"]="🕛",
["clock1230"]="🕧",
["clock1"]="🕐",
["clock130"]="🕜",
["clock2"]="🕑",
["clock230"]="🕝",
["clock3"]="🕒",
["clock330"]="🕞",
["clock4"]="🕓",
["clock430"]="🕟",
["clock5"]="🕔",
["clock530"]="🕠",
["clock6"]="🕕",
["clock630"]="🕡",
["clock7"]="🕖",
["clock730"]="🕢",
["clock8"]="🕗",
["clock830"]="🕣",
["clock9"]="🕘",
["clock930"]="🕤",
["clock10"]="🕙",
["clock1030"]="🕥",
["clock11"]="🕚",
["clock1130"]="🕦",
new_moon="🌑",
waxing_crescent_moon="🌒",
first_quarter_moon="🌓",
moon="🌔",
waxing_gibbous_moon="🌔",
full_moon="🌕",
waning_gibbous_moon="🌖",
last_quarter_moon="🌗",
waning_crescent_moon="🌘",
crescent_moon="🌙",
new_moon_with_face="🌚",
first_quarter_moon_with_face="🌛",
last_quarter_moon_with_face="🌜",
thermometer="🌡️",
sunny="☀️",
full_moon_with_face="🌝",
sun_with_face="🌞",
ringed_planet="🪐",
star="⭐",
["star2"]="🌟",
stars="🌠",
milky_way="🌌",
cloud="☁️",
partly_sunny="⛅",
cloud_with_lightning_and_rain="⛈️",
sun_behind_small_cloud="🌤️",
sun_behind_large_cloud="🌥️",
sun_behind_rain_cloud="🌦️",
cloud_with_rain="🌧️",
cloud_with_snow="🌨️",
cloud_with_lightning="🌩️",
tornado="🌪️",
fog="🌫️",
wind_face="🌬️",
cyclone="🌀",
rainbow="🌈",
closed_umbrella="🌂",
open_umbrella="☂️",
umbrella="☔",
parasol_on_ground="⛱️",
zap="⚡",
snowflake="❄️",
snowman_with_snow="☃️",
snowman="⛄",
comet="☄️",
fire="🔥",
droplet="💧",
ocean="🌊",
jack_o_lantern="🎃",
christmas_tree="🎄",
fireworks="🎆",
sparkler="🎇",
firecracker="🧨",
sparkles="✨",
balloon="🎈",
tada="🎉",
confetti_ball="🎊",
tanabata_tree="🎋",
bamboo="🎍",
dolls="🎎",
flags="🎏",
wind_chime="🎐",
rice_scene="🎑",
red_envelope="🧧",
ribbon="🎀",
gift="🎁",
reminder_ribbon="🎗️",
tickets="🎟️",
ticket="🎫",
medal_military="🎖️",
trophy="🏆",
medal_sports="🏅",
["1st_place_medal"]="🥇",
["2nd_place_medal"]="🥈",
["3rd_place_medal"]="🥉",
soccer="⚽",
baseball="⚾",
softball="🥎",
basketball="🏀",
volleyball="🏐",
football="🏈",
rugby_football="🏉",
tennis="🎾",
flying_disc="🥏",
bowling="🎳",
cricket_game="🏏",
field_hockey="🏑",
ice_hockey="🏒",
lacrosse="🥍",
ping_pong="🏓",
badminton="🏸",
boxing_glove="🥊",
martial_arts_uniform="🥋",
goal_net="🥅",
golf="⛳",
ice_skate="⛸️",
fishing_pole_and_fish="🎣",
diving_mask="🤿",
running_shirt_with_sash="🎽",
ski="🎿",
sled="🛷",
curling_stone="🥌",
dart="🎯",
yo_yo="🪀",
kite="🪁",
["8ball"]="🎱",
crystal_ball="🔮",
magic_wand="🪄",
nazar_amulet="🧿",
video_game="🎮",
joystick="🕹️",
slot_machine="🎰",
game_die="🎲",
jigsaw="🧩",
teddy_bear="🧸",
pinata="🪅",
nesting_dolls="🪆",
spades="♠️",
hearts="♥️",
diamonds="♦️",
clubs="♣️",
chess_pawn="♟️",
black_joker="🃏",
mahjong="🀄",
flower_playing_cards="🎴",
performing_arts="🎭",
framed_picture="🖼️",
art="🎨",
thread="🧵",
sewing_needle="🪡",
yarn="🧶",
knot="🪢",
eyeglasses="👓",
dark_sunglasses="🕶️",
goggles="🥽",
lab_coat="🥼",
safety_vest="🦺",
necktie="👔",
shirt="👕",
tshirt="👕",
jeans="👖",
scarf="🧣",
gloves="🧤",
coat="🧥",
socks="🧦",
dress="👗",
kimono="👘",
sari="🥻",
one_piece_swimsuit="🩱",
swim_brief="🩲",
shorts="🩳",
bikini="👙",
womans_clothes="👚",
purse="👛",
handbag="👜",
pouch="👝",
shopping="🛍️",
school_satchel="🎒",
thong_sandal="🩴",
mans_shoe="👞",
shoe="👞",
athletic_shoe="👟",
hiking_boot="🥾",
flat_shoe="🥿",
high_heel="👠",
sandal="👡",
ballet_shoes="🩰",
boot="👢",
crown="👑",
womans_hat="👒",
tophat="🎩",
mortar_board="🎓",
billed_cap="🧢",
military_helmet="🪖",
rescue_worker_helmet="⛑️",
prayer_beads="📿",
lipstick="💄",
ring="💍",
gem="💎",
mute="🔇",
speaker="🔈",
sound="🔉",
loud_sound="🔊",
loudspeaker="📢",
mega="📣",
postal_horn="📯",
bell="🔔",
no_bell="🔕",
musical_score="🎼",
musical_note="🎵",
notes="🎶",
studio_microphone="🎙️",
level_slider="🎚️",
control_knobs="🎛️",
microphone="🎤",
headphones="🎧",
radio="📻",
saxophone="🎷",
accordion="🪗",
guitar="🎸",
musical_keyboard="🎹",
trumpet="🎺",
violin="🎻",
banjo="🪕",
drum="🥁",
long_drum="🪘",
iphone="📱",
calling="📲",
phone="☎️",
telephone="☎️",
telephone_receiver="📞",
pager="📟",
fax="📠",
battery="🔋",
electric_plug="🔌",
computer="💻",
desktop_computer="🖥️",
printer="🖨️",
keyboard="⌨️",
computer_mouse="🖱️",
trackball="🖲️",
minidisc="💽",
floppy_disk="💾",
cd="💿",
dvd="📀",
abacus="🧮",
movie_camera="🎥",
film_strip="🎞️",
film_projector="📽️",
clapper="🎬",
tv="📺",
camera="📷",
camera_flash="📸",
video_camera="📹",
vhs="📼",
mag="🔍",
mag_right="🔎",
candle="🕯️",
bulb="💡",
flashlight="🔦",
izakaya_lantern="🏮",
lantern="🏮",
diya_lamp="🪔",
notebook_with_decorative_cover="📔",
closed_book="📕",
book="📖",
open_book="📖",
green_book="📗",
blue_book="📘",
orange_book="📙",
books="📚",
notebook="📓",
ledger="📒",
page_with_curl="📃",
scroll="📜",
page_facing_up="📄",
newspaper="📰",
newspaper_roll="🗞️",
bookmark_tabs="📑",
bookmark="🔖",
label="🏷️",
moneybag="💰",
coin="🪙",
yen="💴",
dollar="💵",
euro="💶",
pound="💷",
money_with_wings="💸",
credit_card="💳",
receipt="🧾",
chart="💹",
envelope="✉️",
email="📧",
["e-mail"]="📧",
incoming_envelope="📨",
envelope_with_arrow="📩",
outbox_tray="📤",
inbox_tray="📥",
package="📦",
mailbox="📫",
mailbox_closed="📪",
mailbox_with_mail="📬",
mailbox_with_no_mail="📭",
postbox="📮",
ballot_box="🗳️",
["pencil2"]="✏️",
black_nib="✒️",
fountain_pen="🖋️",
pen="🖊️",
paintbrush="🖌️",
crayon="🖍️",
memo="📝",
pencil="📝",
briefcase="💼",
file_folder="📁",
open_file_folder="📂",
card_index_dividers="🗂️",
date="📅",
calendar="📆",
spiral_notepad="🗒️",
spiral_calendar="🗓️",
card_index="📇",
chart_with_upwards_trend="📈",
chart_with_downwards_trend="📉",
bar_chart="📊",
clipboard="📋",
pushpin="📌",
round_pushpin="📍",
paperclip="📎",
paperclips="🖇️",
straight_ruler="📏",
triangular_ruler="📐",
scissors="✂️",
card_file_box="🗃️",
file_cabinet="🗄️",
wastebasket="🗑️",
lock="🔒",
unlock="🔓",
lock_with_ink_pen="🔏",
closed_lock_with_key="🔐",
key="🔑",
old_key="🗝️",
hammer="🔨",
axe="🪓",
pick="⛏️",
hammer_and_pick="⚒️",
hammer_and_wrench="🛠️",
dagger="🗡️",
crossed_swords="⚔️",
gun="🔫",
boomerang="🪃",
bow_and_arrow="🏹",
shield="🛡️",
carpentry_saw="🪚",
wrench="🔧",
screwdriver="🪛",
nut_and_bolt="🔩",
gear="⚙️",
clamp="🗜️",
balance_scale="⚖️",
probing_cane="🦯",
link="🔗",
chains="⛓️",
hook="🪝",
toolbox="🧰",
magnet="🧲",
ladder="🪜",
alembic="⚗️",
test_tube="🧪",
petri_dish="🧫",
dna="🧬",
microscope="🔬",
telescope="🔭",
satellite="📡",
syringe="💉",
drop_of_blood="🩸",
pill="💊",
adhesive_bandage="🩹",
stethoscope="🩺",
door="🚪",
elevator="🛗",
mirror="🪞",
window="🪟",
bed="🛏️",
couch_and_lamp="🛋️",
chair="🪑",
toilet="🚽",
plunger="🪠",
shower="🚿",
bathtub="🛁",
mouse_trap="🪤",
razor="🪒",
lotion_bottle="🧴",
safety_pin="🧷",
broom="🧹",
basket="🧺",
roll_of_paper="🧻",
bucket="🪣",
soap="🧼",
toothbrush="🪥",
sponge="🧽",
fire_extinguisher="🧯",
shopping_cart="🛒",
smoking="🚬",
coffin="⚰️",
headstone="🪦",
funeral_urn="⚱️",
moyai="🗿",
placard="🪧",
atm="🏧",
put_litter_in_its_place="🚮",
potable_water="🚰",
wheelchair="♿",
mens="🚹",
womens="🚺",
restroom="🚻",
baby_symbol="🚼",
wc="🚾",
passport_control="🛂",
customs="🛃",
baggage_claim="🛄",
left_luggage="🛅",
warning="⚠️",
children_crossing="🚸",
no_entry="⛔",
no_entry_sign="🚫",
no_bicycles="🚳",
no_smoking="🚭",
do_not_litter="🚯",
["non-potable_water"]="🚱",
no_pedestrians="🚷",
no_mobile_phones="📵",
underage="🔞",
radioactive="☢️",
biohazard="☣️",
arrow_up="⬆️",
arrow_upper_right="↗️",
arrow_right="➡️",
arrow_lower_right="↘️",
arrow_down="⬇️",
arrow_lower_left="↙️",
arrow_left="⬅️",
arrow_upper_left="↖️",
arrow_up_down="↕️",
left_right_arrow="↔️",
leftwards_arrow_with_hook="↩️",
arrow_right_hook="↪️",
arrow_heading_up="⤴️",
arrow_heading_down="⤵️",
arrows_clockwise="🔃",
arrows_counterclockwise="🔄",
back="🔙",
["end"]="🔚",
on="🔛",
soon="🔜",
top="🔝",
place_of_worship="🛐",
atom_symbol="⚛️",
om="🕉️",
star_of_david="✡️",
wheel_of_dharma="☸️",
yin_yang="☯️",
latin_cross="✝️",
orthodox_cross="☦️",
star_and_crescent="☪️",
peace_symbol="☮️",
menorah="🕎",
six_pointed_star="🔯",
aries="♈",
taurus="♉",
gemini="♊",
cancer="♋",
leo="♌",
virgo="♍",
libra="♎",
scorpius="♏",
sagittarius="♐",
capricorn="♑",
aquarius="♒",
pisces="♓",
ophiuchus="⛎",
twisted_rightwards_arrows="🔀",
["repeat"]="🔁",
repeat_one="🔂",
arrow_forward="▶️",
fast_forward="⏩",
next_track_button="⏭️",
play_or_pause_button="⏯️",
arrow_backward="◀️",
rewind="⏪",
previous_track_button="⏮️",
arrow_up_small="🔼",
arrow_double_up="⏫",
arrow_down_small="🔽",
arrow_double_down="⏬",
pause_button="⏸️",
stop_button="⏹️",
record_button="⏺️",
eject_button="⏏️",
cinema="🎦",
low_brightness="🔅",
high_brightness="🔆",
signal_strength="📶",
vibration_mode="📳",
mobile_phone_off="📴",
female_sign="♀️",
male_sign="♂️",
transgender_symbol="⚧️",
heavy_multiplication_x="✖️",
heavy_plus_sign="➕",
heavy_minus_sign="➖",
heavy_division_sign="➗",
infinity="♾️",
bangbang="‼️",
interrobang="⁉️",
question="❓",
grey_question="❔",
grey_exclamation="❕",
exclamation="❗",
heavy_exclamation_mark="❗",
wavy_dash="〰️",
currency_exchange="💱",
heavy_dollar_sign="💲",
medical_symbol="⚕️",
recycle="♻️",
fleur_de_lis="⚜️",
trident="🔱",
name_badge="📛",
beginner="🔰",
o="⭕",
white_check_mark="✅",
ballot_box_with_check="☑️",
heavy_check_mark="✔️",
x="❌",
negative_squared_cross_mark="❎",
curly_loop="➰",
loop="➿",
part_alternation_mark="〽️",
eight_spoked_asterisk="✳️",
eight_pointed_black_star="✴️",
sparkle="❇️",
copyright="©️",
registered="®️",
tm="™️",
hash="#️⃣",
asterisk="*️⃣",
zero="0️⃣",
one="1️⃣",
two="2️⃣",
three="3️⃣",
four="4️⃣",
five="5️⃣",
six="6️⃣",
seven="7️⃣",
eight="8️⃣",
nine="9️⃣",
keycap_ten="🔟",
capital_abcd="🔠",
abcd="🔡",
["1234"]="🔢",
symbols="🔣",
abc="🔤",
a="🅰️",
ab="🆎",
b="🅱️",
cl="🆑",
cool="🆒",
free="🆓",
information_source="ℹ️",
id="🆔",
m="Ⓜ️",
new="🆕",
ng="🆖",
["o2"]="🅾️",
ok="🆗",
parking="🅿️",
sos="🆘",
up="🆙",
vs="🆚",
koko="🈁",
sa="🈂️",
["u6708"]="🈷️",
["u6709"]="🈶",
["u6307"]="🈯",
ideograph_advantage="🉐",
["u5272"]="🈹",
["u7121"]="🈚",
["u7981"]="🈲",
accept="🉑",
["u7533"]="🈸",
["u5408"]="🈴",
["u7a7a"]="🈳",
congratulations="㊗️",
secret="㊙️",
["u55b6"]="🈺",
["u6e80"]="🈵",
red_circle="🔴",
orange_circle="🟠",
yellow_circle="🟡",
green_circle="🟢",
large_blue_circle="🔵",
purple_circle="🟣",
brown_circle="🟤",
black_circle="⚫",
white_circle="⚪",
red_square="🟥",
orange_square="🟧",
yellow_square="🟨",
green_square="🟩",
blue_square="🟦",
purple_square="🟪",
brown_square="🟫",
black_large_square="⬛",
white_large_square="⬜",
black_medium_square="◼️",
white_medium_square="◻️",
black_medium_small_square="◾",
white_medium_small_square="◽",
black_small_square="▪️",
white_small_square="▫️",
large_orange_diamond="🔶",
large_blue_diamond="🔷",
small_orange_diamond="🔸",
small_blue_diamond="🔹",
small_red_triangle="🔺",
small_red_triangle_down="🔻",
diamond_shape_with_a_dot_inside="💠",
radio_button="🔘",
white_square_button="🔳",
black_square_button="🔲",
checkered_flag="🏁",
triangular_flag_on_post="🚩",
crossed_flags="🎌",
black_flag="🏴",
white_flag="🏳️",
rainbow_flag="🏳️‍🌈",
transgender_flag="🏳️‍⚧️",
pirate_flag="🏴‍☠️",
ascension_island="🇦🇨",
andorra="🇦🇩",
united_arab_emirates="🇦🇪",
afghanistan="🇦🇫",
antigua_barbuda="🇦🇬",
anguilla="🇦🇮",
albania="🇦🇱",
armenia="🇦🇲",
angola="🇦🇴",
antarctica="🇦🇶",
argentina="🇦🇷",
american_samoa="🇦🇸",
austria="🇦🇹",
australia="🇦🇺",
aruba="🇦🇼",
aland_islands="🇦🇽",
azerbaijan="🇦🇿",
bosnia_herzegovina="🇧🇦",
barbados="🇧🇧",
bangladesh="🇧🇩",
belgium="🇧🇪",
burkina_faso="🇧🇫",
bulgaria="🇧🇬",
bahrain="🇧🇭",
burundi="🇧🇮",
benin="🇧🇯",
st_barthelemy="🇧🇱",
bermuda="🇧🇲",
brunei="🇧🇳",
bolivia="🇧🇴",
caribbean_netherlands="🇧🇶",
brazil="🇧🇷",
bahamas="🇧🇸",
bhutan="🇧🇹",
bouvet_island="🇧🇻",
botswana="🇧🇼",
belarus="🇧🇾",
belize="🇧🇿",
canada="🇨🇦",
cocos_islands="🇨🇨",
congo_kinshasa="🇨🇩",
central_african_republic="🇨🇫",
congo_brazzaville="🇨🇬",
switzerland="🇨🇭",
cote_divoire="🇨🇮",
cook_islands="🇨🇰",
chile="🇨🇱",
cameroon="🇨🇲",
cn="🇨🇳",
colombia="🇨🇴",
clipperton_island="🇨🇵",
costa_rica="🇨🇷",
cuba="🇨🇺",
cape_verde="🇨🇻",
curacao="🇨🇼",
christmas_island="🇨🇽",
cyprus="🇨🇾",
czech_republic="🇨🇿",
de="🇩🇪",
diego_garcia="🇩🇬",
djibouti="🇩🇯",
denmark="🇩🇰",
dominica="🇩🇲",
dominican_republic="🇩🇴",
algeria="🇩🇿",
ceuta_melilla="🇪🇦",
ecuador="🇪🇨",
estonia="🇪🇪",
egypt="🇪🇬",
western_sahara="🇪🇭",
eritrea="🇪🇷",
es="🇪🇸",
ethiopia="🇪🇹",
eu="🇪🇺",
european_union="🇪🇺",
finland="🇫🇮",
fiji="🇫🇯",
falkland_islands="🇫🇰",
micronesia="🇫🇲",
faroe_islands="🇫🇴",
fr="🇫🇷",
gabon="🇬🇦",
gb="🇬🇧",
uk="🇬🇧",
grenada="🇬🇩",
georgia="🇬🇪",
french_guiana="🇬🇫",
guernsey="🇬🇬",
ghana="🇬🇭",
gibraltar="🇬🇮",
greenland="🇬🇱",
gambia="🇬🇲",
guinea="🇬🇳",
guadeloupe="🇬🇵",
equatorial_guinea="🇬🇶",
greece="🇬🇷",
south_georgia_south_sandwich_islands="🇬🇸",
guatemala="🇬🇹",
guam="🇬🇺",
guinea_bissau="🇬🇼",
guyana="🇬🇾",
hong_kong="🇭🇰",
heard_mcdonald_islands="🇭🇲",
honduras="🇭🇳",
croatia="🇭🇷",
haiti="🇭🇹",
hungary="🇭🇺",
canary_islands="🇮🇨",
indonesia="🇮🇩",
ireland="🇮🇪",
israel="🇮🇱",
isle_of_man="🇮🇲",
india="🇮🇳",
british_indian_ocean_territory="🇮🇴",
iraq="🇮🇶",
iran="🇮🇷",
iceland="🇮🇸",
it="🇮🇹",
jersey="🇯🇪",
jamaica="🇯🇲",
jordan="🇯🇴",
jp="🇯🇵",
kenya="🇰🇪",
kyrgyzstan="🇰🇬",
cambodia="🇰🇭",
kiribati="🇰🇮",
comoros="🇰🇲",
st_kitts_nevis="🇰🇳",
north_korea="🇰🇵",
kr="🇰🇷",
kuwait="🇰🇼",
cayman_islands="🇰🇾",
kazakhstan="🇰🇿",
laos="🇱🇦",
lebanon="🇱🇧",
st_lucia="🇱🇨",
liechtenstein="🇱🇮",
sri_lanka="🇱🇰",
liberia="🇱🇷",
lesotho="🇱🇸",
lithuania="🇱🇹",
luxembourg="🇱🇺",
latvia="🇱🇻",
libya="🇱🇾",
morocco="🇲🇦",
monaco="🇲🇨",
moldova="🇲🇩",
montenegro="🇲🇪",
st_martin="🇲🇫",
madagascar="🇲🇬",
marshall_islands="🇲🇭",
macedonia="🇲🇰",
mali="🇲🇱",
myanmar="🇲🇲",
mongolia="🇲🇳",
macau="🇲🇴",
northern_mariana_islands="🇲🇵",
martinique="🇲🇶",
mauritania="🇲🇷",
montserrat="🇲🇸",
malta="🇲🇹",
mauritius="🇲🇺",
maldives="🇲🇻",
malawi="🇲🇼",
mexico="🇲🇽",
malaysia="🇲🇾",
mozambique="🇲🇿",
namibia="🇳🇦",
new_caledonia="🇳🇨",
niger="🇳🇪",
norfolk_island="🇳🇫",
nigeria="🇳🇬",
nicaragua="🇳🇮",
netherlands="🇳🇱",
norway="🇳🇴",
nepal="🇳🇵",
nauru="🇳🇷",
niue="🇳🇺",
new_zealand="🇳🇿",
oman="🇴🇲",
panama="🇵🇦",
peru="🇵🇪",
french_polynesia="🇵🇫",
papua_new_guinea="🇵🇬",
philippines="🇵🇭",
pakistan="🇵🇰",
poland="🇵🇱",
st_pierre_miquelon="🇵🇲",
pitcairn_islands="🇵🇳",
puerto_rico="🇵🇷",
palestinian_territories="🇵🇸",
portugal="🇵🇹",
palau="🇵🇼",
paraguay="🇵🇾",
qatar="🇶🇦",
reunion="🇷🇪",
romania="🇷🇴",
serbia="🇷🇸",
ru="🇷🇺",
rwanda="🇷🇼",
saudi_arabia="🇸🇦",
solomon_islands="🇸🇧",
seychelles="🇸🇨",
sudan="🇸🇩",
sweden="🇸🇪",
singapore="🇸🇬",
st_helena="🇸🇭",
slovenia="🇸🇮",
svalbard_jan_mayen="🇸🇯",
slovakia="🇸🇰",
sierra_leone="🇸🇱",
san_marino="🇸🇲",
senegal="🇸🇳",
somalia="🇸🇴",
suriname="🇸🇷",
south_sudan="🇸🇸",
sao_tome_principe="🇸🇹",
el_salvador="🇸🇻",
sint_maarten="🇸🇽",
syria="🇸🇾",
swaziland="🇸🇿",
tristan_da_cunha="🇹🇦",
turks_caicos_islands="🇹🇨",
chad="🇹🇩",
french_southern_territories="🇹🇫",
togo="🇹🇬",
thailand="🇹🇭",
tajikistan="🇹🇯",
tokelau="🇹🇰",
timor_leste="🇹🇱",
turkmenistan="🇹🇲",
tunisia="🇹🇳",
tonga="🇹🇴",
tr="🇹🇷",
trinidad_tobago="🇹🇹",
tuvalu="🇹🇻",
taiwan="🇹🇼",
tanzania="🇹🇿",
ukraine="🇺🇦",
uganda="🇺🇬",
us_outlying_islands="🇺🇲",
united_nations="🇺🇳",
us="🇺🇸",
uruguay="🇺🇾",
uzbekistan="🇺🇿",
vatican_city="🇻🇦",
st_vincent_grenadines="🇻🇨",
venezuela="🇻🇪",
british_virgin_islands="🇻🇬",
us_virgin_islands="🇻🇮",
vietnam="🇻🇳",
vanuatu="🇻🇺",
wallis_futuna="🇼🇫",
samoa="🇼🇸",
kosovo="🇽🇰",
yemen="🇾🇪",
mayotte="🇾🇹",
south_africa="🇿🇦",
zambia="🇿🇲",
zimbabwe="🇿🇼",
england="🏴󠁧󠁢󠁥󠁮󠁧󠁿",
scotland="🏴󠁧󠁢󠁳󠁣󠁴󠁿",
wales="🏴󠁧󠁢󠁷󠁬󠁳󠁿"}

end

package.preload["djot.html"] = function()
local ast = require("djot.ast")
local unpack = unpack or table.unpack
local insert_attribute, copy_attributes =
  ast.insert_attribute, ast.copy_attributes
local format = string.format
local find, gsub = string.find, string.gsub

-- Produce a copy of a table.
local function copy(tbl)
  local result = {}
  if tbl then
    for k,v in pairs(tbl) do
      local newv = v
      if type(v) == "table" then
        newv = copy(v)
      end
      result[k] = newv
    end
  end
  return result
end

local function to_text(node)
  local buffer = {}
  if node.t == "str" then
    buffer[#buffer + 1] = node.s
  elseif node.t == "nbsp" then
    buffer[#buffer + 1] = "\160"
  elseif node.t == "softbreak" then
    buffer[#buffer + 1] = " "
  elseif node.c and #node.c > 0 then
    for i=1,#node.c do
      buffer[#buffer + 1] = to_text(node.c[i])
    end
  end
  return table.concat(buffer)
end

local Renderer = {}

function Renderer:new()
  local state = {
    out = function(s)
      io.stdout:write(s)
    end,
    tight = false,
    footnote_index = {},
    next_footnote_index = 1,
    references = nil,
    footnotes = nil }
  setmetatable(state, self)
  self.__index = self
  return state
end

Renderer.html_escapes =
   { ["<"] = "&lt;",
     [">"] = "&gt;",
     ["&"] = "&amp;",
     ['"'] = "&quot;" }

function Renderer:escape_html(s)
  if find(s, '[<>&]') then
    return (gsub(s, '[<>&]', self.html_escapes))
  else
    return s
  end
end

function Renderer:escape_html_attribute(s)
  if find(s, '[<>&"]') then
    return (gsub(s, '[<>&"]', self.html_escapes))
  else
    return s
  end
end

function Renderer:render(doc, handle)
  self.references = doc.references
  self.footnotes = doc.footnotes
  if handle then
    self.out = function(s)
      handle:write(s)
    end
  end
  self[doc.t](self, doc)
end


function Renderer:render_children(node)
  if node.c and #node.c > 0 then
    local oldtight
    if node.tight ~= nil then
      oldtight = self.tight
      self.tight = node.tight
    end
    for i=1,#node.c do
      self[node.c[i].t](self, node.c[i])
    end
    if node.tight ~= nil then
      self.tight = oldtight
    end
  end
end

function Renderer:render_attrs(node)
  if node.attr then
    local keys = node.attr._keys or {}
    for i=1,#keys do
      local k = keys[i]
      if k == nil then
        break
      end
      self.out(" " .. k .. "=" .. '"' ..
            self:escape_html_attribute(node.attr[k]) .. '"')
    end
  end
  if node.pos then
    local sp, ep = unpack(node.pos)
    self.out(' data-startpos="' .. tostring(sp) ..
      '" data-endpos="' .. tostring(ep) .. '"')
  end
end

function Renderer:render_tag(tag, node)
  self.out("<" .. tag)
  self:render_attrs(node)
  self.out(">")
end

function Renderer:add_backlink(nodes, i)
  local backlink = {t = "link",
                    destination = "#fnref" .. tostring(i),
                    attr = {role = "doc-backlink", _keys = {"role"}},
                    c = {{t = "str", s = "↩︎︎"}}}
  if nodes.c[#nodes.c].t == "para" then
    table.insert(nodes.c[#nodes.c].c, backlink)
  else
    table.insert(nodes.c, {t = "para", c = {backlink}})
  end
end

function Renderer:doc(node)
  self:render_children(node)
  -- render notes
  if self.next_footnote_index > 1 then
    local ordered_footnotes = {}
    for k,v in pairs(self.footnotes) do
      if self.footnote_index[k] then
        ordered_footnotes[self.footnote_index[k]] = v
      end
    end
    self.out('<section role="doc-endnotes">\n<hr>\n<ol>\n')
    for i=1,#ordered_footnotes do
      self.out(format('<li id="fn%d">\n', i))
      self:add_backlink(ordered_footnotes[i],i)
      self:render_children(ordered_footnotes[i])
      self.out('</li>\n')
    end
    self.out('</ol>\n</section>\n')
  end
end

function Renderer:raw_block(node)
  if node.format == "html" then
    self.out(node.s)  -- no escaping
  end
end

function Renderer:para(node)
  if not self.tight then
    self:render_tag("p", node)
  end
  self:render_children(node)
  if not self.tight then
    self.out("</p>")
  end
  self.out("\n")
end

function Renderer:blockquote(node)
  self:render_tag("blockquote", node)
  self.out("\n")
  self:render_children(node)
  self.out("</blockquote>\n")
end

function Renderer:div(node)
  self:render_tag("div", node)
  self.out("\n")
  self:render_children(node)
  self.out("</div>\n")
end

function Renderer:heading(node)
  self:render_tag("h" .. node.level , node)
  self:render_children(node)
  self.out("</h" .. node.level .. ">\n")
end

function Renderer:thematic_break(node)
  self:render_tag("hr", node)
  self.out("\n")
end

function Renderer:code_block(node)
  self:render_tag("pre", node)
  self.out("<code")
  if node.lang and #node.lang > 0 then
    self.out(" class=\"language-" .. node.lang .. "\"")
  end
  self.out(">")
  self.out(self:escape_html(node.s))
  self.out("</code></pre>\n")
end

function Renderer:table(node)
  self:render_tag("table", node)
  self.out("\n")
  self:render_children(node)
  self.out("</table>\n")
end

function Renderer:row(node)
  self:render_tag("tr", node)
  self.out("\n")
  self:render_children(node)
  self.out("</tr>\n")
end

function Renderer:cell(node)
  local tag
  if node.head then
    tag = "th"
  else
    tag = "td"
  end
  local attr = copy(node.attr)
  if node.align then
    insert_attribute(attr, "style", "text-align: " .. node.align .. ";")
  end
  self:render_tag(tag, {attr = attr})
  self:render_children(node)
  self.out("</" .. tag .. ">\n")
end

function Renderer:caption(node)
  self:render_tag("caption", node)
  self:render_children(node)
  self.out("</caption>\n")
end

function Renderer:list(node)
  local sty = node.list_style
  if sty == "*" or sty == "+" or sty == "-" then
    self:render_tag("ul", node)
    self.out("\n")
    self:render_children(node)
    self.out("</ul>\n")
  elseif sty == "X" then
    local attr = copy(node.attr)
    if attr.class then
      attr.class = "task-list " .. attr.class
    else
      insert_attribute(attr, "class", "task-list")
    end
    self:render_tag("ul", {attr = attr})
    self.out("\n")
    self:render_children(node)
    self.out("</ul>\n")
  elseif sty == ":" then
    self:render_tag("dl", node)
    self.out("\n")
    self:render_children(node)
    self.out("</dl>\n")
  else
    self.out("<ol")
    if node.start and node.start > 1 then
      self.out(" start=\"" .. node.start .. "\"")
    end
    local list_type = gsub(node.list_style, "%p", "")
    if list_type ~= "1" then
      self.out(" type=\"" .. list_type .. "\"")
    end
    self:render_attrs(node)
    self.out(">\n")
    self:render_children(node)
    self.out("</ol>\n")
  end
end

function Renderer:list_item(node)
  if node.checkbox then
     if node.checkbox == "checked" then
       self.out('<li class="checked">')
     elseif node.checkbox == "unchecked" then
       self.out('<li class="unchecked">')
     end
  else
    self:render_tag("li", node)
  end
  self.out("\n")
  self:render_children(node)
  self.out("</li>\n")
end

function Renderer:term(node)
  self:render_tag("dt", node)
  self:render_children(node)
  self.out("</dt>\n")
end

function Renderer:definition(node)
  self:render_tag("dd", node)
  self.out("\n")
  self:render_children(node)
  self.out("</dd>\n")
end

function Renderer:definition_list_item(node)
  self:render_children(node)
end

function Renderer:reference_definition()
end

function Renderer:footnote_reference(node)
  local label = node.s
  local index = self.footnote_index[label]
  if not index then
    index = self.next_footnote_index
    self.footnote_index[label] = index
    self.next_footnote_index = self.next_footnote_index + 1
  end
  self.out(format('<a href="#fn%d" role="doc-noteref"><sup>%d</sup></a>',
              index, index))
end

function Renderer:raw_inline(node)
  if node.format == "html" then
    self.out(node.s)  -- no escaping
  end
end

function Renderer:str(node)
  -- add a span, if needed, to contain attribute on a bare string:
  if node.attr then
    self:render_tag("span", node)
    self.out(self:escape_html(node.s))
    self.out("</span>")
  else
    self.out(self:escape_html(node.s))
  end
end

function Renderer:softbreak()
  self.out("\n")
end

function Renderer:hardbreak()
  self.out("<br>\n")
end

function Renderer:nbsp()
  self.out("&nbsp;")
end

function Renderer:verbatim(node)
  self:render_tag("code", node)
  self.out(self:escape_html(node.s))
  self.out("</code>")
end

function Renderer:link(node)
  local attrs = {}
  if node.reference then
    local ref = self.references[node.reference]
    if ref then
      if ref.attributes then
        attrs = copy(ref.attributes)
      end
      insert_attribute(attrs, "href", ref.destination)
    end
  elseif node.destination then
    insert_attribute(attrs, "href", node.destination)
  end
  -- link's attributes override reference's:
  copy_attributes(attrs, node.attr)
  self:render_tag("a", {attr = attrs})
  self:render_children(node)
  self.out("</a>")
end

Renderer.url = Renderer.link

Renderer.email = Renderer.link

function Renderer:image(node)
  local attrs = {}
  local alt_text = to_text(node)
  if #alt_text > 0 then
    insert_attribute(attrs, "alt", to_text(node))
  end
  if node.reference then
    local ref = self.references[node.reference]
    if ref then
      if ref.attributes then
        attrs = copy(ref.attributes)
      end
      insert_attribute(attrs, "src", ref.destination)
    end
  elseif node.destination then
    insert_attribute(attrs, "src", node.destination)
  end
  -- image's attributes override reference's:
  copy_attributes(attrs, node.attr)
  self:render_tag("img", {attr = attrs})
end

function Renderer:span(node)
  self:render_tag("span", node)
  self:render_children(node)
  self.out("</span>")
end

function Renderer:mark(node)
  self:render_tag("mark", node)
  self:render_children(node)
  self.out("</mark>")
end

function Renderer:insert(node)
  self:render_tag("ins", node)
  self:render_children(node)
  self.out("</ins>")
end

function Renderer:delete(node)
  self:render_tag("del", node)
  self:render_children(node)
  self.out("</del>")
end

function Renderer:subscript(node)
  self:render_tag("sub", node)
  self:render_children(node)
  self.out("</sub>")
end

function Renderer:superscript(node)
  self:render_tag("sup", node)
  self:render_children(node)
  self.out("</sup>")
end

function Renderer:emph(node)
  self:render_tag("em", node)
  self:render_children(node)
  self.out("</em>")
end

function Renderer:strong(node)
  self:render_tag("strong", node)
  self:render_children(node)
  self.out("</strong>")
end

function Renderer:double_quoted(node)
  self.out("&ldquo;")
  self:render_children(node)
  self.out("&rdquo;")
end

function Renderer:single_quoted(node)
  self.out("&lsquo;")
  self:render_children(node)
  self.out("&rsquo;")
end

function Renderer:left_double_quote()
  self.out("&ldquo;")
end

function Renderer:right_double_quote()
  self.out("&rdquo;")
end

function Renderer:left_single_quote()
  self.out("&lsquo;")
end

function Renderer:right_single_quote()
  self.out("&rsquo;")
end

function Renderer:ellipses()
  self.out("&hellip;")
end

function Renderer:em_dash()
  self.out("&mdash;")
end

function Renderer:en_dash()
  self.out("&ndash;")
end

function Renderer:emoji(node)
  self.out(node.s or (":" .. node.alias .. ":"))
end

function Renderer:math(node)
  local math_t = "inline"
  if find(node.attr.class, "display") then
    math_t = "display"
  end
  self:render_tag("span", node)
  if math_t == "inline" then
    self.out("\\(")
  else
    self.out("\\[")
  end
  self:render_children(node)
  if math_t == "inline" then
    self.out("\\)")
  else
    self.out("\\]")
  end
  self.out("</span>")
end

return { Renderer = Renderer }

end

package.preload["djot.inline"] = function()
-- this allows the code to work with both lua and luajit:
local unpack = unpack or table.unpack
local match = require("djot.match")
local attributes = require("djot.attributes")
local make_match, unpack_match, matches_pattern =
  match.make_match, match.unpack_match, match.matches_pattern
local find, byte = string.find, string.byte

-- allow up to 3 captures...
local function bounded_find(subj, patt, startpos, endpos)
  local sp,ep,c1,c2,c3 = find(subj, patt, startpos)
  if ep and ep <= endpos then
    return sp,ep,c1,c2,c3
  end
end

local Parser = {}

function Parser:new(subject, opts, warn)
  local state =
    { opts = opts or {}, -- options
      warn = warn or function() end, -- function to issue warnings
      subject = subject, -- text to parse
      matches = {}, -- table pos : (endpos, annotation)
      openers = {}, -- map from closer_type to array of (pos, data) in reverse order
      verbatim = 0, -- parsing verbatim span to be ended by n backticks
      verbatim_type = nil, -- whether verbatim is math or regular
      destination = false, -- parsing link destination in ()
      firstpos = 0, -- position of first slice
      lastpos = 0,  -- position of last slice
      allow_attributes = true, -- allow parsing of attributes
      attribute_parser = nil,  -- attribute parser
      attribute_start = nil,  -- start of potential attribute
      attribute_slices = nil, -- slices we've tried to parse as attributes
    }
  setmetatable(state, self)
  self.__index = self
  return state
end

function Parser:add_match(startpos, endpos, annotation)
  self.matches[startpos] = make_match(startpos, endpos, annotation)
end

function Parser:add_opener(name, ...)
  -- 1 = startpos, 2 = endpos, 3 = annotation, 4 = substartpos, 5 = endpos
  if not self.openers[name] then
    self.openers[name] = {}
  end
  table.insert(self.openers[name], {...})
end

function Parser:clear_openers(startpos, endpos)
  -- remove other openers in between the matches
  for _,v in pairs(self.openers) do
    local i = #v
    while v[i] do
      local sp,ep,_,sp2,ep2 = unpack(v[i])
      if sp >= startpos and ep <= endpos then
        v[i] = nil
      elseif (sp2 and sp2 >= startpos) and (ep2 and ep2 <= endpos) then
        v[i][3] = nil
        v[i][4] = nil
        v[i][5] = nil
      else
        break
      end
      i = i - 1
    end
  end
end

function Parser:str_matches(startpos, endpos)
  for i = startpos, endpos do
    local m = self.matches[i]
    if m then
      local sp, ep, annot = unpack_match(m)
      if annot ~= "str" and annot ~= "escape" then
        self.matches[i] = make_match(sp, ep, "str")
      end
    end
  end
end

function Parser.between_matched(c, annotation, defaultmatch, opentest)
  return function(self, pos)
    local defaultmatch = defaultmatch or "str"
    local subject = self.subject
    local can_open = find(subject, "^%S", pos + 1)
    local can_close = find(subject, "^%S", pos - 1)
    local has_open_marker = matches_pattern(self.matches[pos - 1], "^open%_marker")
    local has_close_marker = byte(subject, pos + 1) == 125 -- }
    local endcloser = pos
    local startopener = pos

    if type(opentest) == "function" then
      can_open = can_open and opentest(self, pos)
    end

    -- allow explicit open/close markers to override:
    if has_open_marker then
      can_open = true
      can_close = false
      startopener = pos - 1
    end
    if not has_open_marker and has_close_marker then
      can_close = true
      can_open = false
      endcloser = pos + 1
    end

    if has_open_marker and defaultmatch:match("^right") then
      defaultmatch = defaultmatch:gsub("^right", "left")
    elseif has_close_marker and defaultmatch:match("^left") then
      defaultmatch = defaultmatch:gsub("^left", "right")
    end

    local openers = self.openers[c]
    if can_close and openers and #openers > 0 then
       -- check openers for a match
      local openpos, openposend = unpack(openers[#openers])
      if openposend ~= pos - 1 then -- exclude empty emph
        self:clear_openers(openpos, pos)
        self:add_match(openpos, openposend, "+" .. annotation)
        self:add_match(pos, endcloser, "-" .. annotation)
        return endcloser + 1
      end
    end
    -- if we get here, we didn't match an opener
    if can_open then
      self:add_opener(c, startopener, pos)
      self:add_match(startopener, pos, defaultmatch)
      return pos + 1
    else
      self:add_match(pos, endcloser, defaultmatch)
      return endcloser + 1
    end
  end
end

Parser.matchers = {
    -- 96 = `
    [96] = function(self, pos, endpos)
      local subject = self.subject
      local _, endchar = bounded_find(subject, "^`*", pos, endpos)
      if not endchar then
        return nil
      end
      if find(subject, "^%$%$", pos - 2) then
        self.matches[pos - 2] = nil
        self.matches[pos - 1] = nil
        self:add_match(pos - 2, endchar, "+display_math")
        self.verbatim_type = "display_math"
      elseif find(subject, "^%$", pos - 1) then
        self.matches[pos - 1] = nil
        self:add_match(pos - 1, endchar, "+inline_math")
        self.verbatim_type = "inline_math"
      else
        self:add_match(pos, endchar, "+verbatim")
        self.verbatim_type = "verbatim"
      end
      self.verbatim = endchar - pos + 1
      return endchar + 1
    end,

    -- 92 = \
    [92] = function(self, pos, endpos)
      local subject = self.subject
      local _, endchar = bounded_find(subject, "^[ \t]*\r?\n",  pos + 1, endpos)
      self:add_match(pos, pos, "escape")
      if endchar then
        -- see if there were preceding spaces
        if #self.matches > 0 then
          local sp, ep, annot = unpack_match(self.matches[#self.matches])
          if annot == "str" then
            while subject:byte(ep) == 32 or subject:byte(ep) == 9 do
              ep = ep -1
            end
            if sp == ep then
              self.matches[#self.matches] = nil
            else
              self:add_match(sp, ep, "str")
            end
          end
        end
        self:add_match(pos + 1, endchar, "hardbreak")
        return endchar + 1
      else
        local _, ec = bounded_find(subject, "^[%p ]", pos + 1, endpos)
        if not ec then
          self:add_match(pos, pos, "str")
          return pos + 1
        else
          self:add_match(pos, pos, "escape")
          if find(subject, "^ ", pos + 1) then
            self:add_match(pos + 1, ec, "nbsp")
          else
            self:add_match(pos + 1, ec, "str")
          end
          return ec + 1
        end
      end
    end,

    -- 60 = <
    [60] = function(self, pos, endpos)
      local subject = self.subject
      local starturl, endurl =
              bounded_find(subject, "^%<[^<>%s]+%>", pos, endpos)
      if starturl then
        local is_url = bounded_find(subject, "^%a+:", pos + 1, endurl)
        local is_email = bounded_find(subject, "^[^:]+%@", pos + 1, endurl)
        if is_email then
          self:add_match(starturl, starturl, "+email")
          self:add_match(starturl + 1, endurl - 1, "str")
          self:add_match(endurl, endurl, "-email")
          return endurl + 1
        elseif is_url then
          self:add_match(starturl, starturl, "+url")
          self:add_match(starturl + 1, endurl - 1, "str")
          self:add_match(endurl, endurl, "-url")
          return endurl + 1
        end
      end
    end,

    -- 126 = ~
    [126] = Parser.between_matched('~', 'subscript'),

    -- 94 = ^
    [94] = Parser.between_matched('^', 'superscript'),

    -- 91 = [
    [91] = function(self, pos, endpos)
      local sp, ep = bounded_find(self.subject, "^%^([^]]+)%]", pos + 1, endpos)
      if sp then -- footnote ref
        self:add_match(pos, ep, "footnote_reference")
        return ep + 1
      else
        self:add_opener("[", pos, pos)
        self:add_match(pos, pos, "str")
        return pos + 1
      end
    end,

    -- 93 = ]
    [93] = function(self, pos, endpos)
      local openers = self.openers["["]
      local subject = self.subject
      if openers and #openers > 0 then
        local opener = openers[#openers]
        if opener[3] == "reference_link" then
          -- found a reference link
          -- add the matches
          local is_image = bounded_find(subject, "^!", opener[1] - 1, endpos)
                  and not bounded_find(subject, "^[\\]", opener[1] - 2, endpos)
          if is_image then
            self:add_match(opener[1] - 1, opener[1] - 1, "image_marker")
            self:add_match(opener[1], opener[2], "+imagetext")
            self:add_match(opener[4], opener[5], "-imagetext")
          else
            self:add_match(opener[1], opener[2], "+linktext")
            self:add_match(opener[4], opener[5], "-linktext")
          end
          self:add_match(opener[5], opener[5], "+reference")
          self:add_match(pos, pos, "-reference")
          -- convert all matches to str
          self:str_matches(opener[5] + 1, pos - 1)
          -- remove from openers
          self:clear_openers(opener[1], pos)
          return pos + 1
        elseif bounded_find(subject, "^%[", pos + 1, endpos) then
          opener[3] = "reference_link"
          opener[4] = pos  -- intermediate ]
          opener[5] = pos + 1  -- intermediate [
          self:add_match(pos, pos + 1, "str")
          return pos + 2
        elseif bounded_find(subject, "^%(", pos + 1, endpos) then
          self.openers["("] = {} -- clear ( openers
          opener[3] = "explicit_link"
          opener[4] = pos  -- intermediate ]
          opener[5] = pos + 1  -- intermediate (
          self.destination = true
          self:add_match(pos, pos + 1, "str")
          return pos + 2
        elseif bounded_find(subject, "^%{", pos + 1, endpos) then
          -- assume this is attributes, bracketed span
          self:add_match(opener[1], opener[2], "+span")
          self:add_match(pos, pos, "-span")
          self:clear_openers(opener[1], pos)
          return pos + 1
        end
      end
    end,


    -- 40 = (
    [40] = function(self, pos)
      if not self.destination then return nil end
      self:add_opener("(", pos, pos)
      self:add_match(pos, pos, "str")
      return pos + 1
    end,

    -- 41 = )
    [41] = function(self, pos, endpos)
      if not self.destination then return nil end
      local parens = self.openers["("]
      if parens and #parens > 0 and parens[#parens][1] then
        parens[#parens] = nil -- clear opener
        self:add_match(pos, pos, "str")
        return pos + 1
      else
        local subject = self.subject
        local openers = self.openers["["]
        if openers and #openers > 0
            and openers[#openers][3] == "explicit_link" then
          local opener = openers[#openers]
          local startdest, enddest = opener[5], pos
          -- we have inline link
          local is_image = bounded_find(subject, "^!", opener[1] - 1, endpos)
                 and not bounded_find(subject, "^[\\]", opener[1] - 2, endpos)
          if is_image then
            self:add_match(opener[1] - 1, opener[1] - 1, "image_marker")
            self:add_match(opener[1], opener[2], "+imagetext")
            self:add_match(opener[4], opener[4], "-imagetext")
          else
            self:add_match(opener[1], opener[2], "+linktext")
            self:add_match(opener[4], opener[4], "-linktext")
          end
          self:add_match(startdest, startdest, "+destination")
          self:add_match(enddest, enddest, "-destination")
          self.destination = false
          -- convert all matches to str
          self:str_matches(opener[5] + 1, pos - 1)
          -- remove from openers
          self:clear_openers(opener[2], pos)
          return enddest + 1
        end
      end
    end,

    -- 95 = _
    [95] = Parser.between_matched('_', 'emph'),

    -- 42 = *
    [42] = Parser.between_matched('*', 'strong'),

    -- 123 = {
    [123] = function(self, pos, endpos)
      if bounded_find(self.subject, "^[_*~^+='\"-]", pos + 1, endpos) then
        self:add_match(pos, pos, "open_marker")
        return pos + 1
      elseif self.allow_attributes then
        self.attribute_parser = attributes.AttributeParser:new(self.subject)
        self.attribute_start = pos
        self.attribute_slices = {}
        return pos
      else
        self:add_match(pos, pos, "str")
        return pos + 1
      end
    end,

    -- 58 = :
    [58] = function(self, pos, endpos)
      local sp, ep = bounded_find(self.subject, "^%:[%w_+-]+%:", pos, endpos)
      if sp then
        self:add_match(sp, ep, "emoji")
        return ep + 1
      else
        self:add_match(pos, pos, "str")
        return pos + 1
      end
    end,

    -- 43 = +
    [43] = Parser.between_matched("+", "insert", "str",
                           function(self, pos)
                             return find(self.subject, "^%{", pos - 1) or
                                    find(self.subject, "^%}", pos + 1)
                           end),

    -- 61 = =
    [61] = Parser.between_matched("=", "mark", "str",
                           function(self, pos)
                             return find(self.subject, "^%{", pos - 1) or
                                    find(self.subject, "^%}", pos + 1)
                           end),

    -- 39 = '
    [39] = Parser.between_matched("'", "single_quoted", "right_single_quote",
                           function(self, pos) -- test to open
                             return pos == 1 or
                               find(self.subject, "^[%s\"'-([]", pos - 1)
                             end),

    -- 34 = "
    [34] = Parser.between_matched('"', "double_quoted", "left_double_quote"),

    -- 45 = -
    [45] = function(self, pos, endpos)
      local subject = self.subject
      local _, ep = find(subject, "^%-*", pos)
      local hyphens
      if endpos < ep then
        hyphens = 1 + endpos - pos
      else
        hyphens = 1 + ep - pos
      end
      if byte(subject, ep + 1) == 125 then -- }
        hyphens = hyphens - 1 -- last hyphen is close del
      end
      if byte(subject, pos - 1) == 123 or byte(subject, pos + 1) == 125 then
        return Parser.between_matched("-", "delete")(self, pos, endpos)
      end
      -- Try to construct a homogeneous sequence of dashes
      local all_em = hyphens % 3 == 0
      local all_en = hyphens % 2 == 0
      while hyphens > 0 do
        if all_em then
          self:add_match(pos, pos + 2, "em_dash")
          pos = pos + 3
          hyphens = hyphens - 3
        elseif all_en then
          self:add_match(pos, pos + 1, "en_dash")
          pos = pos + 2
          hyphens = hyphens - 2
        elseif hyphens >= 3 and (hyphens % 2 ~= 0 or hyphens > 4) then
          self:add_match(pos, pos + 2, "em_dash")
          pos = pos + 3
          hyphens = hyphens - 3
        elseif hyphens >= 2 then
          self:add_match(pos, pos + 1, "en_dash")
          pos = pos + 2
          hyphens = hyphens - 2
        else
          self:add_match(pos, pos, "str")
          pos = pos + 1
          hyphens = hyphens - 1
        end
      end
      return pos
    end,

    -- 46 = .
    [46] = function(self, pos, endpos)
      if bounded_find(self.subject, "^%.%.", pos + 1, endpos) then
        self:add_match(pos, pos +2, "ellipses")
        return pos + 3
      end
    end
  }

function Parser:single_char(pos)
  self:add_match(pos, pos, "str")
  return pos + 1
end

-- Feed a slice to the parser, updating state.
function Parser:feed(spos, endpos)
  local special = "[][\\`{}_*()!<>~^:=+$\r\n'\".-]"
  local subject = self.subject
  local matchers = self.matchers
  local pos
  if self.firstpos == 0 or spos < self.firstpos then
    self.firstpos = spos
  end
  if self.lastpos == 0 or endpos > self.lastpos then
    self.lastpos = endpos
  end
  pos = spos
  while pos <= endpos do
    if self.attribute_parser then
      local sp = pos
      local ep2 = bounded_find(subject, special, pos, endpos) or endpos
      local status, ep = self.attribute_parser:feed(sp, ep2)
      if status == "done" then
        local attribute_start = self.attribute_start
        -- add attribute matches
        self:add_match(attribute_start, attribute_start, "+attributes")
        self:add_match(ep, ep, "-attributes")
        local attr_matches = self.attribute_parser:get_matches()
        -- add attribute matches
        for i=1,#attr_matches do
          self:add_match(unpack_match(attr_matches[i]))
        end
        -- restore state to prior to adding attribute parser:
        self.attribute_parser = nil
        self.attribute_start = nil
        self.attribute_slices = nil
        pos = ep + 1
      elseif status == "fail" then
        -- backtrack:
        local slices = self.attribute_slices
        self.allow_attributes = false
        self.attribute_parser = nil
        self.attribute_start = nil
        for i=1,#slices do
          self:feed(unpack(slices[i]))
        end
        self.allow_attributes = true
        self.slices = nil
        pos = sp
      elseif status == "continue" then
        self.attribute_slices[#self.attribute_slices + 1] = {sp,ep}
        pos = ep + 1
      end
    else
      -- find next interesting character:
      local newpos = bounded_find(subject, special, pos, endpos) or endpos + 1
      if newpos > pos then
        self:add_match(pos, newpos - 1, "str")
        pos = newpos
        if pos > endpos then
          break -- otherwise, fall through:
        end
      end
      -- if we get here, then newpos = pos,
      -- i.e. we have something interesting at pos
      local c = byte(subject, pos)

      if c == 13 or c == 10 then -- cr or lf
        if c == 13 and bounded_find(subject, "^[%n]", pos + 1, endpos) then
          self:add_match(pos, pos + 1, "softbreak")
          pos = pos + 2
        else
          self:add_match(pos, pos, "softbreak")
          pos = pos + 1
        end
      elseif self.verbatim > 0 then
        if c == 96 then
          local _, endchar = bounded_find(subject, "^`+", pos, endpos)
          if endchar and endchar - pos + 1 == self.verbatim then
            -- check for raw attribute
            local sp, ep =
              bounded_find(subject, "^%{%=[^%s{}`]+%}", endchar + 1, endpos)
            if sp and self.verbatim_type == "verbatim" then -- raw
              self:add_match(pos, endchar, "-" .. self.verbatim_type)
              self:add_match(sp, ep, "raw_format")
              pos = ep + 1
            else
              self:add_match(pos, endchar, "-" .. self.verbatim_type)
              pos = endchar + 1
            end
            self.verbatim = 0
            self.verbatim_type = nil
          else
            endchar = endchar or endpos
            self:add_match(pos, endchar, "str")
            pos = endchar + 1
          end
        else
          self:add_match(pos, pos, "str")
          pos = pos + 1
        end
      else
        pos = (matchers[c] and matchers[c](self, pos, endpos))
               or self:single_char(pos)
      end
    end
  end
end

  -- Return true if we're parsing verbatim content.
function Parser:in_verbatim()
  return self.verbatim > 0
end

function Parser:get_matches()
  local sorted = {}
  local subject = self.subject
  local lastsp, lastep, lastannot
  for i=self.firstpos, self.lastpos do
    if self.matches[i] then
      local sp, ep, annot = unpack_match(self.matches[i])
      if annot == "str" and lastannot == "str" and lastep + 1 == sp then
          -- consolidate adjacent strs
        sorted[#sorted] = make_match(lastsp, ep, annot)
        lastsp, lastep, lastannot = lastsp, ep, annot
      else
        sorted[#sorted + 1] = self.matches[i]
        lastsp, lastep, lastannot = sp, ep, annot
      end
    end
  end
  if #sorted > 0 then
    local last = sorted[#sorted]
    local startpos, endpos, annot = unpack_match(last)
    -- remove final softbreak
    if annot == "softbreak" then
      sorted[#sorted] = nil
      last = sorted[#sorted]
      startpos, endpos, annot = unpack_match(last)
    end
    -- remove trailing spaces
    if annot == "str" and byte(subject, endpos) == 32 then
      while endpos > startpos and byte(subject, endpos) == 32 do
        endpos = endpos - 1
      end
      sorted[#sorted] = make_match(startpos, endpos, annot)
    end
    if self.verbatim > 0 then -- unclosed verbatim
      self.warn({ message = "Unclosed verbatim", pos = startpos })
      sorted[#sorted + 1] = make_match(startpos, endpos,
                                       "-" .. self.verbatim_type)
    end
  end
  return sorted
end

return { Parser = Parser }

end

package.preload["djot.json"] = function()
-- Modified from
-- json.lua
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--
-- Modifications to the original code:
--
-- * Removed JSON decoding code
-- * Add code to ignore keys beginning with '_'
-- * Revise short names used in internal AST to longer descriptive names,
--   e.g. c -> children.

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end

local longnames =
  { c = "children",
    t = "tag",
    s = "text" }

local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      -- Added by JGM:
      if string.sub(k,1,1) ~= "_" then
        local key = longnames[k] or k
        table.insert(res, encode(key, stack) .. ":" .. encode(v, stack))
      end
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end

return json

end

package.preload["djot.match"] = function()
local make_match, unpack_match
local unpack = unpack or table.unpack

if jit or not string.pack then
  -- for luajit or lua 5.1, we don't have string.pack/unpack, so we use arrays.
  -- This is faster than using ffi to pack things in C structs.

  make_match = function(startpos, endpos, annotation)
    return {startpos, endpos, annotation}
  end

  unpack_match = unpack

else
  -- for standard lua >= 5.2, we use string.pack/unpack which gives a
  -- more memory-efficient representation than arrays.

  make_match = function(startpos, endpos, annotation)
    return string.pack("=I4I4z", startpos, endpos, annotation)
  end

  unpack_match = function(match)
    local startpos, endpos, annotation = string.unpack("=I4I4z", match)
    return startpos, endpos, annotation
  end
end

local get_length = function(match)
  local startpos, endpos = unpack_match(match)
  return 1 + (endpos - startpos)
end

local format_match = function(match)
  local startpos, endpos, annotation = unpack_match(match)
  return string.format("%-s %d-%d\n", annotation, startpos, endpos)
end

local function matches_pattern(match, patt)
  if match then
    local _, _, annot = unpack_match(match)
    return string.find(annot, patt)
  end
end

return {
  make_match = make_match,
  unpack_match = unpack_match,
  get_length = get_length,
  format_match = format_match,
  matches_pattern = matches_pattern
}

end

local djot = require("djot")
function djot_to_html (input)
    local parser = djot.Parser:new(input)
    parser:parse()
    local html = parser:render_html()
    return html
end
